class Solver{_debug=!0;_pro;_iterLimit=null;_timeLimit=null;_targetDeg=.8;#t=[];constructor(t){this._pro=t}name(){return""}exec(){return!1}setIterationLimit(t=null){this._iterLimit=t}setTimeLimit(t=null){this._timeLimit=t}setTargetRate(t=null){this._targetDeg=t}solve(){return this.exec()}addListener(t){this.#t.add(t)}removeListener(t){this.#t.splice(this.#t.indexOf(t),1)}foundSolution(t,e){let s=!1;for(const i of this.#t)i.foundSolution(t,e)&&(s=!0);return s}}class DomainPruner{static#e=-1;#s;#i=0;constructor(t){this.#s=new Array(t),this.#s.fill(DomainPruner.#e)}hiddenSize(){return this.#i}hide(t,e){this.#s[t]===DomainPruner.#e&&++this.#i,this.#s[t]=e}isEmpty(){return this.#s.length===this.#i}isValueHidden(t){return this.#s[t]!==DomainPruner.#e}reveal(t){for(let e=0;e<this.#s.length;e++)this.#s[e]===t&&(this.#s[e]=DomainPruner.#e,--this.#i)}revealAll(){this.#s.fill(DomainPruner.#e),this.#i=0}}class Breakout extends Solver{#n;constructor(t){super(t),this.#n=new Array(this._pro.constraintSize()),this.#n.fill(1)}name(){return"Breakout"}#o(t,e){let s=0;for(const i of t){const t=i.value(),n=i.constraints(),o=i.domain();let r=0;for(const t of n)r+=(1-t.isSatisfied())*this.#n[t.index()];t:for(let a=0;a<o.size();++a){const l=o.at(a);if(t===l)continue;i.assign(l);let h=r;for(const t of n)if(h-=(1-t.isSatisfied())*this.#n[t.index()],h<s)continue t;h>s?(s=h,e.clear(),e.addVariable(i,l)):0!==s&&e.addVariable(i,l)}i.assign(t)}}#r(t){const e=new Set;for(let s=0;s<t.length;++s){const i=t[s];for(let t=0;t<i.size();++t)e.add(i.at(t))}return Array.from(e)}exec(){const t=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;for(const t of this._pro.variables())t.isEmpty()&&t.assign(t.domain().at(0));const s=[],i=new AssignmentList;for(;;){if(this._pro.violatingConstraints(s),(this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debug&&console.log("stop: current degree is above the target"),!0;if(this._iterLimit&&this._iterLimit<e++)return this._debug&&console.log("stop: number of iterations has reached the limit"),!1;if(t<Date.now())return this._debug&&console.log("stop: time limit has been reached"),!1;if(this._debug&&console.log(s.length+" violations"),this.#o(this.#r(s),i),0<i.size()){const t=i.arbitraryAssignment();t.apply(),i.clear(),this._debug&&console.log("\t"+t)}else{for(let t=0;t<s.length;++t)this.#n[s[t].index()]++;this._debug&&console.log("breakout")}}}}class ForwardChecking extends Solver{#a;#l=new AssignmentList;#h;#c=!1;#u;#f;constructor(t){super(t),this.#a=[...this._pro.variables()];for(const t of this.#a)t.solverObject=new DomainPruner(t.domain().size());this.#g()}name(){return"Forward Checking"}#g(){const t=[];this.#h=[];for(let e=0;e<this.#a.length;++e){this.#h.push(new Array(this.#a.length));for(let s=0;s<this.#a.length;++s)s<e&&(this._pro.constraintsBetween(this.#a[s],this.#a[e],t),this.#h[e][s]=[...t])}}#d(t,e){return t<e?this.#h[e][t]:this.#h[t][e]}#m(t,e){for(const s of this.#a){if(!s.isEmpty())continue;const i=s.domain(),n=s.solverObject,o=this.#d(e,s.index());for(const e of o)if(1===e.emptyVariableSize()){for(let o=0,r=i.size();o<r;++o)n.isValueHidden(o)||(s.assign(i.at(o)),0===e.isSatisfied()&&n.hide(o,t));if(s.clear(),n.isEmpty())return!1}}return!0}#b(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<this.#a.length;++s){const i=this.#a[s];if(!i.isEmpty())continue;const n=i.domain().size()-i.solverObject.hiddenSize();n<e&&(e=n,t=s)}return t}#p(t){if(this._iterLimit&&this._iterLimit<this.#u++)return this._debug&&console.log("stop: number of iterations has reached the limit"),!1;if(this.#f<Date.now())return this._debug&&console.log("stop: time limit has been reached"),!1;if(t===this._pro.variableSize())return this.#l.setProblem(this._pro),!0;const e=this.#c?this.#b():t,s=this.#a[e],i=s.domain(),n=s.solverObject;for(let o=0,r=i.size();o<r;++o)if(!n.isValueHidden(o)){if(s.assign(i.at(o)),this.#m(t,e)&&this.#p(t+1))return!0;for(const e of this.#a)e.solverObject.reveal(t)}return s.clear(),!1}exec(){this.#f=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#u=0,this._pro.clearAllVariables();const t=this.#p(0);for(let t=0;t<this.#l.size();++t){const e=this.#l.get(t);e.apply(),e.variable().solverObject.revealAll()}return t}setTargetRate(){}setUsingMinimumRemainingValuesHeuristics(t){this.#c=t}}class MaxForwardChecking extends Solver{#a;#l=new AssignmentList;#_;#v;#w=new Set;#C=[];#u;#f;constructor(t){super(t),this.#a=[...this._pro.variables()];for(const t of this.#a)t.solverObject=new DomainPruner(t.domain().size());this.#_=this._pro.constraintSize()}name(){return"Forward Checking for Max CSPs"}#p(t,e){if(this._iterLimit&&this._iterLimit<this.#u++)return!1;if(this.#f<Date.now())return!1;if(t===this._pro.variableSize()){const t=this._pro.violatingConstraintSize();return t<this.#_&&(this.#_=t,this.#l.setProblem(this._pro),this._debug&&console.log(`   refreshed ${this.#_}`),(this._targetDeg??1)<=this._pro.satisfiedConstraintRate())}const s=this.#a[t],i=s.domain(),n=s.solverObject;for(let o=0;o<i.size();++o)if(!(n.isValueHidden(o)||(s.assign(i.at(o)),this.#v=e+this.#D(t,s),this.#v>this.#_))){if(this.#m(t)&&this.#p(t+1,this.#v))return!0;for(const e of this.#a)e.solverObject.reveal(t)}return s.clear(),!1}#m(t){const e=this.#a[t];for(let s=t+1;s<this.#a.length;++s){const i=this.#a[s];this._pro.constraintsBetween(e,i,this.#C);for(const e of this.#C)if(1===e.emptyVariableSize()&&this.#z(i,e,t)&&i.solverObject.isEmpty())return!1}return!0}#D(t,e){let s=0;this.#w.clear();for(let i=0;i<t;++i){this._pro.constraintsBetween(e,this.#a[i],this.#C);for(const t of this.#C)this.#w.has(t)||(0===t.isSatisfied()&&++s,this.#w.add(t))}return s}#z(t,e,s){let i=!1;const n=t.domain(),o=t.solverObject;for(let r=0;r<n.size();++r)o.isValueHidden(r)||(t.assign(n.at(r)),0===e.isSatisfied()&&this.#v+1>this.#_&&(o.hide(r,s),i=!0));return i}exec(){this.#f=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#u=0,this._pro.clearAllVariables();const t=this.#p(0,0);this._debug&&(t?console.log("stop: current degree is above the target"):(this._iterLimit&&this._iterLimit<this.#u&&console.log("stop: number of iterations has reached the limit"),this.#f<Date.now()&&console.log("stop: time limit has been reached")));for(let t=0;t<this.#l.size();++t){const e=this.#l.get(t);e.apply(),e.variable().solverObject.revealAll()}return t}}class GENET extends Solver{static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}#S=[];#L;constructor(t){if(super(t),!this.#E())throw new Exception}name(){return"GENET"}#E(){this._debug&&console.log("network creation start");const t=[];for(const t of this._pro.variables()){if(0===t.domain().size())return!1;this.#S.push(new GENET.Cluster(t))}for(const e of this._pro.constraints())if(1===e.size()){const s=e.at(0),i=this.#S[e.at(0).index()];for(let n=0;n<i.size();++n){const o=s.value();s.assign(i.get(n)._value),0===e.isSatisfied()&&t.push(new GENET.Connection(i.get(n))),s.assign(o)}}else{const s=e.at(0),i=e.at(1),n=this.#S[e.at(0).index()],o=this.#S[e.at(1).index()];for(let r=0;r<n.size();++r){const a=s.value();s.assign(n.get(r)._value);for(let s=0;s<o.size();++s){const a=i.value();i.assign(o.get(s)._value),0===e.isSatisfied()&&t.push(new GENET.Connection(n.get(r),o.get(s))),i.assign(a)}s.assign(a)}}for(const t of this.#S)for(const e of t._neurons)e.lockConnections();return this.#L=t,this._debug&&console.log("network creation complete"),!0}#V(t){for(let e=t.length;e>1;--e){const s=GENET.nextInt(e),i=t[e-1];t[e-1]=t[s],t[s]=i}return t}exec(){const t=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;const s=new AssignmentList,i=[];for(let t=0;t<this.#S.length;t++)i.push(t);let n=this._pro.satisfiedConstraintRate();for(;;){if(this._iterLimit&&this._iterLimit<e++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(t<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}let o=!1;for(const t of this.#V(i))this.#S[t].setActivityMaximumInput()&&(o=!0);if(o){for(const t of this.#S)t.applyToVariable();const t=this._pro.satisfiedConstraintRate();if(n<t&&(n=t,this._debug&&console.log(`satisfied constraint rate: ${t}`),s.setProblem(this._pro),this._targetDeg??1<=n))return this._debug&&console.log("stop: current degree is above the target"),s.apply(),!0}else for(const t of this.#L)t.refreshWeight()}return s.apply(),!1}}{class t{static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}#y;#x;#N=[];_neurons;constructor(e){this.#y=e;const i=e.domain();this._neurons=[];for(let t=0;t<i.size();++t)this._neurons.push(new s(i.at(t)));this.#A(t.nextInt(this._neurons.length))}#A(t){for(const t of this._neurons)t._isActive=!1;this._neurons[t]._isActive=!0,this.#x=t}applyToVariable(){this.#y.assign(this._neurons[this.#x]._value)}get(t){return this._neurons[t]}neurons(){return this._neurons}setActivityMaximumInput(){this.#N.length=0;let e=Number.NEGATIVE_INFINITY,s=!1;for(let t=0;t<this._neurons.length;++t){const i=this._neurons[t].getInput();e<=i&&(e<i&&(e=i,this.#N.length=0,s=!1),this.#N.push(t),this.#x===t&&(s=!0))}return!s&&0!==this.#N.length&&(this.#A(this.#N[t.nextInt(this.#N.length)]),!0)}size(){return this._neurons.length}}GENET.Cluster=t;class e{#k;#T;_weight;constructor(t,e=null){this._weight=-1,this.#k=t,this.#k.addConnection(this),this.#T=e,null!==this.#T&&this.#T.addConnection(this)}getNeuron(t){return t===this.#k?this.#T:t===this.#T?this.#k:null}refreshWeight(){this.#k._isActive&&(null===this.#T||this.#T._isActive)&&(this._weight+=-1)}}GENET.Connection=e;class s{#R=[];#L;_value;_isActive=!1;constructor(t){this._value=t}addConnection(t){this.#R.push(t)}lockConnections(){this.#L=[...this.#R],this.#R=null}getInput(){let t=0;for(const e of this.#L){const s=e.getNeuron(this);t+=e._weight*(null===s||s._isActive?1:0)}return t}}GENET.Neuron=s}class LocalChanges extends Solver{static#M(t,e){const s=new Set(t);for(const t of e)s.add(t);return s}static#F(t,e){const s=new Set(t);for(const t of e)s.delete(t);return s}static#I(t,e){const s=new Set(t);return s.add(e),s}static#O(t,e){const s=new Set(t);return s.delete(e),s}#u;#f;#W;constructor(t,e=!1){super(t),e&&this._pro.clearAllVariables()}name(){return"Local Changes"}#j(t,e,s){const i=new Set,n=new Set,o=[];for(const s of t){this._pro.constraintsBetween(e,s,o);for(const t of o)n.add(t)}const r=e.value();e.assign(s);for(const t of n)if(0===t.isSatisfied())for(let e=0;e<t.size();++e)i.add(t.at(e));return e.assign(r),i.delete(e),i}#P(t,e,s){const i=new Set,n=[];for(const s of t){this._pro.constraintsBetween(e,s,n);for(const t of n)i.add(t)}const o=e.value();e.assign(s);for(const t of i)if(0===t.isSatisfied())return e.assign(o),!1;return e.assign(o),!0}#U(t,e,s,i){if(!this.#P(t,s,i))return!1;const n=LocalChanges.#M(t,e);if(this.#P(n,s,i))return!0;const o=this.#j(n,s,i),r=LocalChanges.#F(n,o);this.#P(r,s,i)||this._debug&&console.log("bug");for(const t of o)t.clear();return t=LocalChanges.#I(t,s),e=LocalChanges.#F(e,o),this.#B(t,e,o)}#H(t,e,s,i){if(0===i.size)return!1;const n=i.values().next().value,o=AssignmentList.fromVariables(e);s.assign(n);const r=this.#U(t,e,s,n);return r||this.#W?r:(s.clear(),o.apply(),this.#H(t,e,s,LocalChanges.#O(i,n)))}#B(t,e,s){if(this._debug&&console.log(`V1 ${t.size}, V2' ${e.size}, V3' ${s.size}`),(this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debug&&console.log("stop: current degree is above the target"),this.#W=!0,!0;if(this._iterLimit&&this._iterLimit<this.#u++)return this._debug&&console.log("stop: number of iterations has reached the limit"),this.#W=!0,!1;if(this.#f<Date.now())return this._debug&&console.log("stop: time limit has been reached"),this.#W=!0,!1;if(0===s.size)return!0;const i=s.values().next().value,n=i.domain(),o=new Set;for(let t=0;t<n.size();++t)o.add(n.at(t));const r=this.#H(t,e,i,o);return!r||this.#W?r:(e=LocalChanges.#I(e,i),s=LocalChanges.#O(s,i),this.#B(t,e,s))}exec(){this.#f=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#u=0,this.#W=!1,0===this._pro.emptyVariableSize()&&this._pro.clearAllVariables();const t=new Set,e=new Set;for(const s of this._pro.variables())(s.isEmpty()?e:t).add(s);return this.#B(new Set,t,e)}}class LocalChangesEx extends Solver{static#M(t,e){const s=new Set(t);for(const t of e)s.add(t);return s}static#F(t,e){const s=new Set(t);for(const t of e)s.delete(t);return s}static#I(t,e){const s=new Set(t);return s.add(e),s}static#O(t,e){const s=new Set(t);return s.delete(e),s}#u;#f;#W;constructor(t,e=!1){super(t),e&&this._pro.clearAllVariables()}name(){return"Local Changes Ex"}#j(t,e,s){const i=new Set,n=new Set,o=[];for(const s of t){this._pro.constraintsBetween(e,s,o);for(const t of o)n.add(t)}const r=e.value();e.assign(s);for(const t of n)if(0===t.isSatisfied())for(let e=0;e<t.size();++e)i.add(t.at(e));return e.assign(r),i.delete(e),i}#P(t,e,s){const i=new Set,n=[];for(const s of t){this._pro.constraintsBetween(e,s,n);for(const t of n)i.add(t)}const o=e.value();e.assign(s);for(const t of i)if(0===t.isSatisfied())return e.assign(o),!1;return e.assign(o),!0}#U(t,e,s){if(!this.#P(t,s,s.value()))return!1;const i=LocalChangesEx.#M(t,e);if(this.#P(i,s,s.value()))return!0;const n=this.#j(i,s,s.value());return e=LocalChangesEx.#F(e,n),t=LocalChangesEx.#I(t,s),this.#B(t,e,n)}#H(t,e,s){const i=s.domain();for(let n=0;n<i.size();++n){const o=i.at(n),r=AssignmentList.fromVariables(e);s.assign(o);const a=this.#U(t,e,s);if(a||this.#W)return a;s.clear(),r.apply()}return!1}#B(t,e,s){for(e=new Set(e),s=new Set(s);;){if(this._debug&&console.log(`V1 ${t.size}, V2' ${e.size}, V3' ${s.size}`),(this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debug&&console.log("stop: current degree is above the target"),this.#W=!0,!0;if(this._iterLimit&&this._iterLimit<this.#u++)return this._debug&&console.log("stop: number of iterations has reached the limit"),this.#W=!0,!1;if(this.#f<Date.now())return this._debug&&console.log("stop: time limit has been reached"),this.#W=!0,!1;if(0===s.size)return!0;const i=s.values().next().value,n=this.#H(t,e,i);if(!n||this.#W)return n;e.add(i),s.delete(i)}}exec(){this.#f=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#u=0,this.#W=!1,0===this._pro.emptyVariableSize()&&this._pro.clearAllVariables();const t=new Set,e=new Set;for(const s of this._pro.variables())(s.isEmpty()?e:t).add(s);return this.#B(new Set,t,e)}}class CrispSRS3 extends Solver{#X=new Set;#$=new Set;#G=[];#q=[];#Y=!0;constructor(t){super(t);for(const t of this._pro.constraints())this.#G.push(new CrispSRS3.TreeNode(t)),this.#q.push(null)}name(){return"SRS 3 for Crisp CSPs"}#J(t){const e=t.index();return null===this.#q[e]&&(this.#q[e]=t.neighbors([])),this.#q[e]}#K(t){this._debug&&console.log("repair");const e=new AssignmentList;let s=0;for(let i=0;i<t.size();++i){const n=t.at(i),o=n.value(),r=n.constraints(),a=n.domain();let l=0;for(const t of r)l+=1-t.isSatisfied();t:for(let i=0;i<a.size();++i){const h=a.at(i);if(o===h)continue;if(n.assign(h),1!==t.isSatisfied())continue;let c=l;for(const t of r)if(c-=1-t.isSatisfied(),c<s)continue t;c>s?(s=c,e.clear(),e.addVariable(n,h)):0!==s&&e.addVariable(n,h)}n.assign(o)}if(e.size()>0){const t=this.#Y?e.arbitraryAssignment():e.get(0);return t.apply(),this._debug&&console.log("\t"+t),!0}return!1}#Q(t,e){const s=[];let i=t;for(;;){i=i.parent(),s.length=0,i.getDescendants(s),i.clear();for(const t of e)this.#$.delete(t),this.#X.delete(t);if(e.delete(i))break;if(this.#$.add(i),null!==i.parent()&&!this.#K(i.parent().getObject()))break}}#Z(t){this._debug&&console.log("spread"),this.#X.add(t);for(const e of this.#J(t.getObject())){const s=this.#G[e.index()];this.#X.has(s)||this.#$.has(s)||(s.clear(),t.add(s),this.#$.add(s))}}#tt(t){this._debug&&console.log("srs");const e=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let s=0;this.#X.clear(),this.#$.clear();for(const e of t)this.#$.add(e);for(;t.size&&this.#$.size;){if((this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debug&&console.log("stop: current degree is above the target"),!0;if(this._iterLimit&&this._iterLimit<s++)return this._debug&&console.log("stop: number of iterations has reached the limit"),!1;if(e<Date.now())return this._debug&&console.log("stop: time limit has been reached"),!1;const i=this.#$.values().next().value;this.#$.delete(i),this.#K(i.getObject())?t.delete(i)||(null!==i.parent()&&this.#K(i.parent().getObject())?this.#Q(i,t):this.#Z(i)):this.#Z(i)}return!1}exec(){const t=this._pro.violatingConstraints([]),e=new Set;for(const s of t){const t=this.#G[s.index()];e.add(t)}return!!this.#tt(e)||0===e.length}setRandomness(t){this.#Y=t}}{class t{#et=[];#st;#it;constructor(t){this.#it=t}add(t){t.#st=this,this.#et.push(t)}clear(){for(const t of this.#et)t.#st=null;this.#et.length=0}getDescendants(t){t.push(this);for(const e of this.#et)e.getDescendants(t)}getObject(){return this.#it}parent(){return this.#st}}CrispSRS3.TreeNode=t}class FuzzyBreakout extends Solver{#n;#nt;#Y=!0;constructor(t){super(t),this.#n=new Array(this._pro.constraintSize()),this.#n.fill(1)}name(){return"Fuzzy Breakout"}foundSolution(){return!1}#o(t,e){let s=0;for(const i of t){const t=i.value(),n=i.constraints(),o=i.domain();let r=0;for(const t of n)r+=(1-t.satisfactionDegree())*this.#n[t.index()];t:for(let a=0;a<o.size();++a){const l=o.at(a);if(t===l)continue;i.assign(l);let h=r;for(const t of n)if(h-=(1-t.satisfactionDegree())*this.#n[t.index()],h<s)continue t;h>s?(s=h,e.clear(),e.addVariable(i,l)):0!==s&&e.addVariable(i,l)}i.assign(t)}}#ot(t){const e=new Set;for(let s=0;s<t.length;++s){const i=t[s];for(let t=0;t<i.size();++t)e.add(i.at(t))}return Array.from(e)}exec(){const t=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;for(const t of this._pro.variables())t.isEmpty()&&t.assign(t.domain().at(0));const s=this._pro.worstSatisfactionDegree(),i=[],n=new AssignmentList,o=new AssignmentList;for(;;){const s=this._pro.constraintsWithWorstSatisfactionDegree(i);if(null!==this._targetDeg&&this._targetDeg<=s)return this._debug&&console.log("stop: current degree is above the target"),!0;if(this._iterLimit&&this._iterLimit<e++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(t<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}if(this._debug&&console.log("worst satisfaction degree: "+s),this.#nt<s&&(o.setProblem(this._pro),this.#nt=s,foundSolution(o,this.#nt)))return!0;if(this.#o(this.#ot(i),n),0<n.size()){const t=this.#Y?n.arbitraryAssignment():n.get(0);t.apply(),n.clear(),this._debug&&console.log("\t"+t)}else{for(let t=0;t<i.length;++t)this.#n[i[t].index()]++;this._debug&&console.log("breakout")}}return null===this._targetDeg&&s<this._pro.worstSatisfactionDegree()}setRandomness(t){this.#Y=t}}class FuzzyForwardChecking extends Solver{static CONTINUE=0;static TERMINATE=1;#a;#l=new AssignmentList;#h;#rt=0;#u;#f;#c=!1;#at=0;#lt;#ht;#w;#ct=!1;constructor(t,e=null){super(t),this.#a=[...this._pro.variables()],this.#lt=new Array(this._pro.variableSize()),this.#g(),this.#w=new Array(this._pro.constraintSize());const s=[];for(const t of this._pro.constraints())1===t.size()&&s.push(t);this.#ht=[...s],e&&(this.#rt=e)}name(){return"Forward Checking for Fuzzy CSPs"}#g(){const t=[];this.#h=[];for(let e=0;e<this.#a.length;++e){this.#h.push(new Array(this.#a.length));for(let s=0;s<this.#a.length;s++)s<e&&(this._pro.constraintsBetween(this.#a[s],this.#a[e],t),this.#h[e][s]=[...t])}}#d(t,e){return t<e?this.#h[e][t]:this.#h[t][e]}#ut(){for(const t of this.#ht){const e=t.at(0),s=e.value(),i=e.domain(),n=e.solverObject;for(let s=0,o=i.size();s<o;++s)e.assign(i.at(s)),t.satisfactionDegree()<=this.#rt&&n.hide(s,-1);if(e.assign(s),n.isEmpty())return!1}return!0}#ft(t,e,s){const i=e.domain(),n=e.solverObject;for(let o=0,r=i.size();o<r;++o)n.isValueHidden(o)||(e.assign(i.at(o)),s.satisfactionDegree()<=this.#rt&&n.hide(o,t));return e.clear(),!n.isEmpty()}#gt(t,e,s){const i=e.domain(),n=e.solverObject,o=null;for(let t=0,i=s.size();t<i;++t){const i=s.at(t);if(i.isEmpty()&&i!==e){o=i;break}}const r=o.domain(),a=o.solverObject;t:for(let l=0,h=i.size();l<h;++l)if(!n.isValueHidden(l)){e.assign(i.at(l));for(let t=0,e=r.size();t<e;++t){if(a.isValueHidden(t))continue;o.assign(r.at(t));if(s.satisfactionDegree()>this.#rt)continue t}n.hide(l,t)}return o.clear(),e.clear(),!n.isEmpty()}#dt(t,e,s){const i=e.domain(),n=e.solverObject;let o=null,r=null;for(let t=0,i=s.size();t<i;++t){let i=s.at(t);if(i.isEmpty()&&i!==e){if(null!==o){r=i;break}o=i}}const a=o.domain(),l=r.domain(),h=o.solverObject,c=r.solverObject;t:for(let u=0,f=i.size();u<f;++u)if(!n.isValueHidden(u)){e.assign(i.at(u));for(let t=0,e=a.size();t<e;++t)if(!h.isValueHidden(t)){o.assign(a.at(t));for(let t=0,e=l.size();t<e;++t){if(c.isValueHidden(t))continue;r.assign(l.at(t));if(s.satisfactionDegree()>this.#rt)continue t}}n.hide(u,t)}return r.clear(),o.clear(),e.clear(),!n.isEmpty()}#mt(t,e,s,i){const n=e.domain(),o=e.solverObject,r=new Array(i-1);let a=0;for(let t=0,i=s.size();t<i;++t){const i=s.at(t);i.isEmpty()&&i!==e&&(r[a++]=i)}const l=new Array(r.length);t:for(let i=0,a=n.size();i<a;++i)if(!o.isValueHidden(i)){e.assign(n.at(i)),l.fill(0);e:for(;;){let t=!1;for(let e=0;e<r.length;++e){const s=r[e].domain();if(r[e].solverObject.isValueHidden(l[e])){t=!0;break}r[e].assign(s.at(l[e]))}if(!t){if(s.satisfactionDegree()>this.#rt)continue t}for(let t=0;t<r.length&&(l[t]++,!(l[t]<r[t].domain().size()));++t)if(l[t]=0,t===r.length-1)break e}o.hide(i,t)}for(const t of r)t.clear();return e.clear(),!o.isEmpty()}#m(t,e){for(const s of this.#a){if(!s.isEmpty())continue;const i=this.#d(e,s.index());for(const e of i){const i=e.emptyVariableSize();if(1===i){if(!this.#ft(t,s,e))return!1}else if(this.#ct)if(2===i){if(!this.#gt(t,s,e))return!1}else if(3===i){if(!this.#dt(t,s,e))return!1}else if(i>3&&!this.#mt(t,s,e,i))return!1}}return!0}#bt(t){this.#w.fill(!1);for(let e=0;e<this.#a.length;++e){const s=this.#a[e];if(s===t||s.isEmpty())continue;const i=this.#d(t.index(),e);for(const t of i){if(this.#w[t.index()])continue;const e=t.satisfactionDegree();if(e!==Constraint.UNDEFINED&&e<=this.#rt)return!1;this.#w[t.index()]=!0}}return!0}#pt(){for(let t=0;t<this.#lt.length;++t){const e=this.#lt[t].index();for(let s=t+1;s<this.#lt.length;++s){const i=this.#lt[s],n=this.#d(e,i.index());for(const e of n){const s=i.value(),n=i.domain(),o=i.solverObject;for(let s=0,r=n.size();s<r;++s)o.isValueHidden(s)||(i.assign(n.at(s)),e.satisfactionDegree()<=this.#rt&&o.hide(s,t));i.assign(s)}}}}#b(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<this.#a.length;++s){const i=this.#a[s];if(!i.isEmpty())continue;const n=i.domain().size()-i.solverObject.hiddenSize();n<e&&(e=n,t=s)}return t}#p(t){let e=FuzzyForwardChecking.CONTINUE;const s=this.#c?this.#b():t,i=this.#a[s],n=i.domain(),o=i.solverObject;this.#lt[t]=i;for(let r=0,a=n.size();r<a;++r){if(o.isValueHidden(r))continue;if(this._iterLimit&&this._iterLimit<this.#u++||this.#f<Date.now()){e=FuzzyForwardChecking.TERMINATE;break}i.assign(n.at(r));for(const e of this.#a)e.solverObject.reveal(t);if(!this.#bt(i))continue;if(!this.#m(t,s))continue;const a=t+1;if(e=a===this.#a.length-1?this.#_t(a):this.#p(a),e===FuzzyForwardChecking.TERMINATE)break}if(e===FuzzyForwardChecking.CONTINUE)for(const e of this.#a)e.solverObject.reveal(t);return i.clear(),e}#_t(t){let e=FuzzyForwardChecking.CONTINUE;const s=this.#a[this.#c?this.#b():t],i=s.domain(),n=s.solverObject;this.#lt[t]=s;for(let t=0,o=i.size();t<o;++t){if(n.isValueHidden(t))continue;if(this._iterLimit&&this._iterLimit<this.#u++||this.#f<Date.now()){e=FuzzyForwardChecking.TERMINATE;break}s.assign(i.at(t));const o=this._pro.worstSatisfactionDegree();if(o>this.#rt){if(this.#rt=o,this.#l.setProblem(this._pro),e=FuzzyForwardChecking.TERMINATE,null!==this._targetDeg&&this._targetDeg<=this.#rt)break;this.#ut(),this.#pt()}}return s.clear(),e}exec(){this.#f=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#u=0;for(const t of this.#a)t.solverObject=new DomainPruner(t.domain().size());if(this._pro.clearAllVariables(),!this.#ut())return!1;let t=!1;for(;;){if(this.#p(0)===FuzzyForwardChecking.TERMINATE){if(this._iterLimit&&this._iterLimit<this.#u++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(this.#f<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}}if(this.#l.isEmpty())break;if(this._debug&&console.log(`\tfound a solution: ${this.#rt}`),this.foundSolution(this.#l,this.#rt)){t=!0;break}if(null===this._targetDeg)t=!0,this.#rt+=this.#at;else if(this._targetDeg<=this.#rt){this._debug&&console.log("stop: current degree is above the target"),t=!0;break}for(const t of this.#a)t.solverObject.revealAll()}this.#l.apply();for(const t of this.#a)t.solverObject=null;return t}setTargetRate(t=null){if(this._targetDeg=t,null===this._targetDeg)this.#rt=0;else{let t=Number.MIN_VALUE;for(this.#rt=this._targetDeg-t;this.#rt>=this._targetDeg;)t*=10,this.#rt=this._targetDeg-t}}setUsingMinimumRemainingValuesHeuristics(t){this.#c=t}setIncrementStepOfWorstSatisfactionDegree(t){this.#at=t}setIntensivePruning(t){this.#ct=t}}class FuzzyForwardCheckingBc extends Solver{static CONTINUE=0;static TERMINATE=1;#a;#l=new AssignmentList;#h;#rt=0;#u;#f;#c=!1;#at=0;constructor(t,e=null){super(t),this.#a=[...this._pro.variables()],this.#g(),this.#rt=Math.max(0,t.worstSatisfactionDegree()),e&&(this.#rt=e)}name(){return"Forward Checking for Fuzzy CSPs of Binary Constraints"}foundSolution(){return!1}#g(){const t=[];this.#h=[];for(let e=0;e<this.#a.length;++e){this.#h.push(new Array(this.#a.length));for(let s=0;s<this.#a.length;s++)s<e&&(this._pro.constraintsBetween(this.#a[s],this.#a[e],t),this.#h[e][s]=[...t])}}#d(t,e){return t<e?this.#h[e][t]:this.#h[t][e]}#ft(t,e,s){const i=e.domain(),n=e.solverObject;for(let o=0,r=i.size();o<r;++o)n.isValueHidden(o)||(e.assign(i.at(o)),s.satisfactionDegree()<=this.#rt&&n.hide(o,t));return e.clear(),!n.isEmpty()}#m(t,e){for(const s of this.#a){if(!s.isEmpty())continue;const i=this.#d(e,s.index());for(const e of i)if(2===e.size()&&!this.#ft(t,s,e))return!1}return!0}#b(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<this.#a.length;++s){const i=this.#a[s];if(!i.isEmpty())continue;const n=i.domain().size()-i.solverObject.hiddenSize();n<e&&(e=n,t=s)}return t}#p(t){let e=FuzzyForwardCheckingBc.CONTINUE;const s=this.#c?this.#b():t,i=this.#a[s],n=i.domain(),o=i.solverObject;for(let r=0,a=n.size();r<a;++r){if(o.isValueHidden(r))continue;if(this._iterLimit&&this._iterLimit<this.#u++||this.#f<Date.now()){e=FuzzyForwardCheckingBc.TERMINATE;break}i.assign(n.at(r));for(const e of this.#a)e.solverObject.reveal(t);if(!this.#m(t,s))continue;const a=t+1;if(e=a===this.#a.length-1?this.#_t(a):this.#p(a),e===FuzzyForwardCheckingBc.TERMINATE)break}if(e===FuzzyForwardCheckingBc.CONTINUE)for(const e of this.#a)e.solverObject.reveal(t);return i.clear(),e}#_t(t){let e=FuzzyForwardCheckingBc.CONTINUE;const s=this.#a[this.#c?this.#b():t],i=s.domain(),n=s.solverObject;for(let t=0,o=i.size();t<o;++t){if(n.isValueHidden(t))continue;if(this._iterLimit&&this._iterLimit<this.#u++||this.#f<Date.now()){e=FuzzyForwardCheckingBc.TERMINATE;break}s.assign(i.at(t));const o=this._pro.worstSatisfactionDegree();if(o>this.#rt&&(this.#rt=o,this.#l.setProblem(this._pro),e=FuzzyForwardCheckingBc.TERMINATE,null!==this._targetDeg&&this._targetDeg<=this.#rt))break}return s.clear(),e}exec(){this.#f=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#u=0;for(const t of this.#a)t.solverObject=new DomainPruner(t.domain().size());this._pro.clearAllVariables();const t=new AssignmentList;let e=!1;for(;;){if(this.#p(0)===FuzzyForwardCheckingBc.TERMINATE){if(this._iterLimit&&this._iterLimit<this.#u++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(this.#f<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}}if(this.#l.isEmpty())break;if(t.setAssignmentList(this.#l),this.#l.clear(),this._debug&&console.log(`\tfound a solution: ${this.#rt}`),this.foundSolution(t,this.#rt)){e=!0;break}if(null===this._targetDeg){if(e=!0,this.#rt+this.#at>1)break;this.#rt+=this.#rt+this.#at>1?0:this.#at}else if(this._targetDeg<=this.#rt){this._debug&&console.log("stop: current degree is above the target"),e=!0;break}for(const t of this.#a)t.solverObject.revealAll()}t.apply();for(const t of this.#a)t.solverObject=null;return e}setTargetRate(t=null){if(this._targetDeg=t,null===this._targetDeg)this.#rt=0;else{let t=Number.MIN_VALUE;for(this.#rt=this._targetDeg-t;this.#rt>=this._targetDeg;)t*=10,this.#rt=this._targetDeg-t}}setUsingMinimumRemainingValuesHeuristics(t){this.#c=t}setIncrementStepOfWorstSatisfactionDegree(t){this.#at=t}}class FuzzyGENET extends Solver{static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}#S=[];#L;constructor(t,e=1){if(super(t),!this.#E(e))throw new Exception}name(){return"Fuzzy GENET"}#E(t){this._debug&&console.log("network creation start");const e=[];for(const t of this._pro.variables()){if(0===t.domain().size())return!1;this.#S.push(new FuzzyGENET.Cluster(t))}for(const s of this._pro.constraints())if(1===s.size()){const i=s.at(0),n=this.#S[s.at(0).index()];for(let o=0;o<n.size();++o){const r=i.value();i.assign(n.get(o)._value),s.satisfactionDegree()<=t&&e.push(new FuzzyGENET.Connection(s,n.get(o))),i.assign(r)}}else{const i=s.at(0),n=s.at(1),o=this.#S[s.at(0).index()],r=this.#S[s.at(1).index()];for(let a=0;a<o.size();++a){const l=i.value();i.assign(o.get(a)._value);for(let i=0;i<r.size();++i){const l=n.value();n.assign(r.get(i)._value),s.satisfactionDegree()<=t&&e.push(new FuzzyGENET.Connection(s,o.get(a),r.get(i))),n.assign(l)}i.assign(l)}}for(const t of this.#S)for(const e of t._neurons)e.lockConnections();return this.#L=e,this._debug&&console.log("network creation complete"),!0}#V(t){for(let e=t.length;e>1;--e){const s=GENET.nextInt(e),i=t[e-1];t[e-1]=t[s],t[s]=i}return t}exec(){const t=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;const s=new AssignmentList,i=[];for(let t=0;t<this.#S.length;t++)i.push(t);let n=this._pro.worstSatisfactionDegree(),o=!1;for(;;){if(this._iterLimit&&this._iterLimit<e++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(t<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}let r=!1;for(const t of this.#V(i))this.#S[t].setActivityMaximumInput()&&(r=!0);if(r){for(const t of this.#S)t.applyToVariable();const t=this._pro.worstSatisfactionDegree();if(n<t){if(n=t,this._debug&&console.log(`worst satisfaction degree: ${t}`),s.setProblem(this._pro),this.foundSolution(s,t)){o=!0;break}if(null===this._targetDeg)o=!0;else if(this._targetDeg<=n){this._debug&&console.log("stop: current degree is above the target"),o=!0;break}}}else for(const t of this.#L)t.refreshWeight()}return s.apply(),o}}{class t{static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}#y;#x;#N=[];_neurons;constructor(e){this.#y=e;const i=e.domain();this._neurons=[];for(let t=0;t<i.size();++t)this._neurons.push(new s(i.at(t)));this.#A(t.nextInt(this._neurons.length))}#A(t){for(const t of this._neurons)t._isActive=!1;this._neurons[t]._isActive=!0,this.#x=t}applyToVariable(){this.#y.assign(this._neurons[this.#x]._value)}get(t){return this._neurons[t]}neurons(){return this._neurons}setActivityMaximumInput(){this.#N.length=0;let e=Number.NEGATIVE_INFINITY,s=!1;for(let t=0;t<this._neurons.length;++t){const i=this._neurons[t].getInput();e<=i&&(e<i&&(e=i,this.#N.length=0,s=!1),this.#N.push(t),this.#x===t&&(s=!0))}return!s&&0!==this.#N.length&&(this.#A(this.#N[t.nextInt(this.#N.length)]),!0)}size(){return this._neurons.length}}FuzzyGENET.Cluster=t;class e{#vt;#k;#T;_weight;constructor(t,e,s=null){this._weight=t.satisfactionDegree()-1,this.#vt=t,this.#k=e,this.#k.addConnection(this),this.#T=s,null!==this.#T&&this.#T.addConnection(this)}getNeuron(t){return t===this.#k?this.#T:t===this.#T?this.#k:null}refreshWeight(){this.#k._isActive&&(null===this.#T||this.#T._isActive)&&(1===this.#vt.size()?this._weight+=this.#vt.fuzzyRelation().satisfactionDegree(this.#k._value)-1:this._weight+=this.#vt.fuzzyRelation().satisfactionDegree(this.#k._value,this.#T._value)-1)}}FuzzyGENET.Connection=e;class s{#R=[];#L;_value;_isActive=!1;constructor(t){this._value=t}addConnection(t){this.#R.push(t)}lockConnections(){this.#L=[...this.#R],this.#R=null}getInput(){let t=0;for(const e of this.#L){const s=e.getNeuron(this);t+=e._weight*(null===s||s._isActive?1:0)}return t}}FuzzyGENET.Neuron=s}class FlexibleLocalChanges extends Solver{static#M(t,e){const s=new Set(t);for(const t of e)s.add(t);return s}static#F(t,e){const s=new Set(t);for(const t of e)s.delete(t);return s}static#I(t,e){const s=new Set(t);return s.add(e),s}static#O(t,e){const s=new Set(t);return s.delete(e),s}#wt;#Ct;#u;#f;#W;constructor(t){super(t),this.#Dt()}name(){return"Flexible Local Changes"}#zt(t,e){const s=new Map;for(const t of e)if(t.isDefined())for(let e=0;e<t.size();++e){const i=t.at(e);s.has(i)?s.set(i,s.get(i)+1):s.set(i,1)}const i=[...t];i.sort(((t,e)=>{let i=0,n=0;return s.has(t)&&(i=s.get(t)),s.has(e)&&(n=s.get(e)),i<n?1:i>n?-1:0}));const n=new Set;for(const t of i){let s=!1;for(const t of e)if(t.isDefined()){s=!0;break}if(!s)break;t.clear(),n.add(t)}return n}#Dt(){let t=1,e=0;for(const s of this._pro.variables())for(let i=0;i<s.size();++i){const n=s.at(i),o=n.lowestConsistencyDegree(),r=n.highestConsistencyDegree();o<t&&(t=o),r>e&&(e=r)}this.#Ct=t,this.#wt=e}#St(t,e,s,i,n,o,r){const a=this.#zt(e,o),l=FlexibleLocalChanges.#I(t,s),h=FlexibleLocalChanges.#F(e,a);return this.#Lt(l,h,a,i,Math.min(n,i),r)}#Et(t,e,s,i,n,o){let r=this.#Ct;if(0===s.domain().size())return r;let a=AssignmentList.fromVariables(e),l=s.domain().at(0);const h=AssignmentList.fromVariables(e);for(let c=0;c<s.domain().size()&&r<n;++c){const u=s.domain().at(c);s.assign(u);const f=Math.min(i,this.#Vt(t,s,r,o));if(f>Math.max(r,o)){const i=new Set,c=Math.min(Math.min(f,n),this.#yt(t,e,s,f,n,i));if(c>r&&(r=c,l=u,a=AssignmentList.fromVariables(e)),i.size){const c=this.#St(t,e,s,f,n,i,Math.max(o,r));if(-1!==this.#W)return r;c>r&&(r=c,l=u,a=AssignmentList.fromVariables(e)),h.apply()}}}return a.apply(),s.assign(l),r}#Lt(t,e,s,i,n,o){if(this._debug&&console.log(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),null!==this._targetDeg&&this._targetDeg<=this._pro.worstSatisfactionDegree())return this._debug&&console.log("stop: current degree is above the target"),this.#W=1,n;if(this._iterLimit&&this._iterLimit<this.#u++)return this._debug&&console.log("stop: number of iterations has reached the limit"),this.#W=0,n;if(this.#f<Date.now())return this._debug&&console.log("stop: time limit has been reached"),this.#W=0,n;if(0===s.size)return n;const r=s.values().next().value,a=this.#Et(t,e,r,i,n,o);return-1!==this.#W?n:a<o?this.#Ct:(e=FlexibleLocalChanges.#I(e,r),s=FlexibleLocalChanges.#O(s,r),this.#Lt(t,e,s,i,a,o))}#xt(t,e){const s=new Set;for(const e of t)for(let t=0;t<e.size();++t)s.add(e.at(t));let i=1;for(const t of s){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&(e<i&&(i=e))}for(const t of this._pro.constraints()){t.lowestConsistencyDegree()<this.#wt&&e.add(t)}return i}#Vt(t,e,s,i){let n=1;const o=new Set,r=[];for(const s of t){this._pro.constraintsBetween(s,e,r);for(const t of r)o.add(t)}for(const t of o){const e=t.satisfactionDegree();if(e!==Constraint.UNDEFINED&&(e<n&&(n=e),n<=s||n<=i))return n}return n}#yt(t,e,s,i,n,o){let r=1;const a=new Set,l=[];for(const e of t){this._pro.constraintsBetween(e,s,l);for(const t of l)a.add(t)}for(const t of e){this._pro.constraintsBetween(t,s,l);for(const t of l)a.add(t)}for(const t of a){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&(e<r&&(r=e))}for(const t of a){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&((e<i||e<n)&&o.add(t))}return r}exec(){this.#f=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#u=0,this.#W=-1;const t=this._pro.worstSatisfactionDegree();0===this._pro.emptyVariableSize()&&this._pro.clearAllVariables();const e=new Set,s=new Set,i=new Set;for(const t of this._pro.variables())(t.isEmpty()?i:s).add(t);const n=new Set,o=this.#xt(s,n);let r,a=null;0===i.size?(r=o,a=AssignmentList.fromVariables(s)):r=this.#Ct;const l=FlexibleLocalChanges.#M(this.#zt(s,n),i),h=FlexibleLocalChanges.#F(s,l);let c=this.#Lt(e,h,l,this.#wt,this.#wt,r);return c<r&&null!==a&&a.apply(),c=this._pro.worstSatisfactionDegree(),c>t&&c>0&&(0!==this.#W||null===this._targetDeg)}}class FlexibleLocalChangesEx extends Solver{static#M(t,e){const s=new Set(t);for(const t of e)s.add(t);return s}static#F(t,e){const s=new Set(t);for(const t of e)s.delete(t);return s}static#I(t,e){const s=new Set(t);return s.add(e),s}#wt;#Ct;#u;#f;#W;constructor(t){super(t),this.#Dt()}name(){return"Flexible Local Changes Ex"}#zt(t,e){const s=new Map;for(const t of e)if(t.isDefined())for(let e=0;e<t.size();++e){const i=t.at(e);s.has(i)?s.set(i,s.get(i)+1):s.set(i,1)}const i=[...t];i.sort(((t,e)=>{let i=0,n=0;return s.has(t)&&(i=s.get(t)),s.has(e)&&(n=s.get(e)),i<n?1:i>n?-1:0}));const n=new Set;for(const t of i){let s=!1;for(const t of e)if(t.isDefined()){s=!0;break}if(!s)break;t.clear(),n.add(t)}return n}#Dt(){let t=1,e=0;for(const s of this._pro.variables())for(let i=0;i<s.size();++i){const n=s.at(i),o=n.lowestConsistencyDegree(),r=n.highestConsistencyDegree();o<t&&(t=o),r>e&&(e=r)}this.#Ct=t,this.#wt=e}#St(t,e,s,i,n,o,r){const a=this.#zt(e,o),l=FlexibleLocalChangesEx.#I(t,s),h=FlexibleLocalChangesEx.#F(e,a);return this.#Lt(l,h,a,i,Math.min(n,i),r)}#Et(t,e,s,i,n,o){let r=this.#Ct;if(0===s.domain().size())return r;let a=AssignmentList.fromVariables(e),l=s.domain().at(0);const h=AssignmentList.fromVariables(e);for(let c=0;c<s.domain().size()&&r<n;++c){const u=s.domain().at(c);s.assign(u);const f=Math.min(i,this.#Vt(t,s,r,o));if(f>Math.max(r,o)){const i=new Set,c=Math.min(Math.min(f,n),this.#yt(t,e,s,f,n,i));if(c>r&&(r=c,l=u,a=AssignmentList.fromVariables(e)),i.size){const c=this.#St(t,e,s,f,n,i,Math.max(o,r));if(-1!==this.#W)return r;c>r&&(r=c,l=u,a=AssignmentList.fromVariables(e)),h.apply()}}}return a.apply(),s.assign(l),r}#Lt(t,e,s,i,n,o){for(e=new Set(e),s=new Set(s);;){if(this._debug&&console.log(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),null!==this._targetDeg&&this._targetDeg<=this._pro.worstSatisfactionDegree())return this._debug&&console.log("stop: current degree is above the target"),this.#W=1,n;if(this._iterLimit&&this._iterLimit<this.#u++)return this._debug&&console.log("stop: number of iterations has reached the limit"),this.#W=0,n;if(this.#f<Date.now())return this._debug&&console.log("stop: time limit has been reached"),this.#W=0,n;if(0===s.size)return n;const r=s.values().next().value,a=this.#Et(t,e,r,i,n,o);if(-1!==this.#W)return n;if(a<o)return this.#Ct;e.add(r),s.delete(r),n=a}}#xt(t,e){const s=new Set;for(const e of t)for(let t=0;t<e.size();++t)s.add(e.at(t));let i=1;for(const t of s){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&(e<i&&(i=e))}for(const t of this._pro.constraints()){t.lowestConsistencyDegree()<this.#wt&&e.add(t)}return i}#Vt(t,e,s,i){let n=1;const o=new Set,r=[];for(const s of t){this._pro.constraintsBetween(s,e,r);for(const t of r)o.add(t)}for(const t of o){const e=t.satisfactionDegree();if(e!==Constraint.UNDEFINED&&(e<n&&(n=e),n<=s||n<=i))return n}return n}#yt(t,e,s,i,n,o){let r=1;const a=new Set,l=[];for(const e of t){this._pro.constraintsBetween(e,s,l);for(const t of l)a.add(t)}for(const t of e){this._pro.constraintsBetween(t,s,l);for(const t of l)a.add(t)}for(const t of a){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&(e<r&&(r=e))}for(const t of a){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&((e<i||e<n)&&o.add(t))}return r}exec(){this.#f=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#u=0,this.#W=-1;const t=this._pro.worstSatisfactionDegree();0===this._pro.emptyVariableSize()&&this._pro.clearAllVariables();const e=new Set,s=new Set,i=new Set;for(const t of this._pro.variables())(t.isEmpty()?i:s).add(t);const n=new Set,o=this.#xt(s,n);let r,a=null;0===i.size?(r=o,a=AssignmentList.fromVariables(s)):r=this.#Ct;const l=FlexibleLocalChangesEx.#M(this.#zt(s,n),i),h=FlexibleLocalChangesEx.#F(s,l);let c=this.#Lt(e,h,l,this.#wt,this.#wt,r);return c<r&&null!==a&&a.apply(),c=this._pro.worstSatisfactionDegree(),c>t&&c>0&&(0!==this.#W||null===this._targetDeg)}}class SRS3 extends Solver{static REPAIR_THRESHOLD=0;#X=new Set;#$=new Set;#G=[];#q=[];#Nt=new Set;#u;#f;#Y=!0;constructor(t){super(t);for(const t of this._pro.constraints())this.#G.push(new CrispSRS3.TreeNode(t)),this.#q.push(null)}name(){return"SRS 3"}foundSolution(t,e){return!1}#J(t){const e=t.index();return null===this.#q[e]&&(this.#q[e]=t.neighbors([])),this.#q[e]}#K(t){this._debug&&console.log("repair");const e=new AssignmentList,s=t.satisfactionDegree(),i=this._pro.worstSatisfactionDegree();let n=t.satisfactionDegree();for(let o=0;o<t.size();++o){const r=t.at(o),a=r.value(),l=r.constraints(),h=r.domain();t:for(let o=0;o<h.size();++o){const c=h.at(o);if(a===c)continue;r.assign(c);const u=t.satisfactionDegree();if(!(s>u||n-u>SRS3.REPAIR_THRESHOLD)){for(const e of l){if(e===t)continue;const s=e.satisfactionDegree();if(s!==Constraint.UNDEFINED&&s<i)continue t}u>n&&(n=u,e.clear()),e.addVariable(r,c)}}r.assign(a)}if(e.size()>0){const t=this.#Y?e.arbitraryAssignment():e.get(0);return console.log(t),t.apply(),this._debug&&console.log("\t"+t),!0}return!1}#Q(t){this._debug&&console.log("shrink");let e=!1;for(;;){if(t=t.parent(),this.#Nt.delete(t)){e=!0;break}if(!this.#K(t.parent().getObject()))break}const s=[];t.getDescendants(s);for(const t of s)t.clear(),this.#$.delete(t),this.#X.delete(t);e||this.#$.add(t)}#Z(t){this._debug&&console.log("spread"),this.#X.add(t);for(const e of this.#J(t.getObject())){const s=this.#G[e.index()];this.#X.has(s)||this.#$.has(s)||(t.add(s),this.#$.add(s))}}#tt(){this._debug&&console.log("srs");const t=[];this._pro.constraintsWithWorstSatisfactionDegree(t);for(const e of t){const t=this.#G[e.index()];t.setParent(null),this.#Nt.add(t)}this.#X.clear(),this.#$.clear();for(const t of this.#Nt)this.#$.add(t);for(;this.#Nt.size&&this.#$.size;){if(this._iterLimit&&this._iterLimit<iterCount++)return this._debug&&console.log("stop: number of iterations has reached the limit"),!1;if(this.#f<Date.now())return this._debug&&console.log("stop: time limit has been reached"),!1;const t=this.#$.values().next().value;if(this.#$.delete(t),this.#K(t.getObject())){if(this.#Nt.delete(t))continue;if(this.#K(t.parent().getObject())){this.#Q(t);continue}}this.#Z(t)}return!0}exec(){if(this.#f=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#u=0,this._targetDeg&&this._targetDeg<=this._pro.worstSatisfactionDegree())return!0;const t=new AssignmentList;let e=!1;for(;;){if(!this.#tt()||this.#Nt.size)break;const s=this._pro.worstSatisfactionDegree();if(this._debug&&console.log(`\tfound a solution: ${s}\t${this._targetDeg}`),t.setProblem(this._pro),this.foundSolution(t,s)){e=!0;break}if(null===this._targetDeg)e=!0;else if(this._targetDeg<=s){this._debug&&console.log("stop: current degree is above the target"),e=!0;break}}return e}setRandomness(t){this.#Y=t}}{class t{#et=[];#st;#it;constructor(t){this.#it=t}add(t){t.#st=this,this.#et.push(t)}clear(){for(const t of this.#et)t.#st=null;this.#et.length=0}getDescendants(t){t.push(this);for(const e of this.#et)e.getDescendants(t)}getObject(){return this.#it}parent(){return this.#st}setParent(t){this.#st=t}}CrispSRS3.TreeNode=t}class SRS3_PF extends SRS3{constructor(t){super(t)}name(){return"SRS 3 + PF"}exec(){let t=0,e=0;this._debug&&(t=this._pro.worstSatisfactionDegree(),e=this._pro.emptyVariableSize());const s=new AssignmentList;s.setProblem(this._pro);const i=super.exec();return i&&PostStabilization.apply(this._pro,s),this._debug&&(console.log("result: "+(i?"success":"failure")),console.log(`satisfaction degree: ${t} -> ${this._pro.worstSatisfactionDegree()}`),console.log(`uUnassigned size: ${e} -> ${this._pro.emptyVariableSize()}`)),i}}class AC3{static#At(t,e){const s=e.domain();for(let i=0;i<s.size();++i)if(e.assign(s.at(i)),1===t.isSatisfied())return!0;return!1}static#kt(t,e,s){const i=e.value(),n=s.value(),o=e.domain(),r=[],a=[];t.constraintsBetween(e,s,a);t:for(let t=0;t<o.size();++t){e.assign(o.at(t));for(let t=0;t<a.size();++t){const e=a.get(t);if(2===e.size()&&!AC3.#At(e,s))continue t}r.push(o.at(t))}if(e.assign(i),s.assign(n),r.length!==o.size()){const s=t.createDomain({values:r});return e.setDomain(s),console.log(o.size()+" -> "+s.size()),!0}return!1}static apply(t){const e=[];for(const s of t.constraints())2===s.size()&&e.add(s);for(;!e.isEmpty();){const s=e.remove(e.size()-1),i=s.at(0),n=s.at(1);if(AC3.#kt(t,i,n))for(const s of t.constraints())2===s.size()&&s.at(1)===i&&s.at(0)!==n&&e.add(0,s)}}}class NodeConsistency{static apply(t,e){for(const s of t.variables()){const i=s.domain(),n=s.value(),o=[];for(let n=0;n<s.size();++n){const r=s.at(n);if(1===r.size()){for(let t=0;t<i.size();++t)s.assign(i.at(t)),r.satisfactionDegree()>=e&&o.add(val);t.removeConstraint(r)}}if(s.assign(n),o.isEmpty())return!1;s.setDomain(t.createDomain({values:o}))}return!0}static apply(t){for(const e of t.variables()){const s=e.domain(),i=e.value(),n=[];for(let i=0;i<e.size();++i){const o=e.at(i);if(1===o.size()){for(let t=0;t<s.size();++t)e.assign(s.at(t)),1===o.isSatisfied()&&n.add(val);t.removeConstraint(o)}}if(e.assign(i),n.isEmpty())return!1;e.setDomain(t.createDomain({values:n}))}return!0}}class PostStabilization{static apply(t,e){let s;console.log("start post-stabilization");let i=0;do{console.log("post-stabilization: count "+i++),s=!1;let n=t.worstSatisfactionDegree();for(let i=0;i<t.variableSize();++i){const o=t.variableAt(i),r=o.value(),a=e.get(i);r!==a.value()&&(a.apply(),t.worstSatisfactionDegree()>=n?s=!0:o.assign(r))}}while(s);return console.log("finish post-stabilization"),!0}}
//# sourceMappingURL=solver.min.js.map