class Solver{_debug=!0;_pro;_iterLimit=null;_timeLimit=null;_targetDeg=.8;#t=[];constructor(t){this._pro=t}name(){return""}exec(){return!1}setIterationLimit(t=null){this._iterLimit=t}setTimeLimit(t=null){this._timeLimit=t}setTargetRate(t=null){this._targetDeg=t}solve(){return this.exec()}addListener(t){this.#t.add(t)}removeListener(t){this.#t.splice(this.#t.indexOf(t),1)}foundSolution(t,e){let s=!1;for(const i of this.#t)i.foundSolution(t,e)&&(s=!0);return s}}class DomainPruner{static#e=-1;#s;#i=0;constructor(t){this.#s=new Array(t),this.#s.fill(DomainPruner.#e)}hiddenSize(){return this.#i}hide(t,e){this.#s[t]===DomainPruner.#e&&++this.#i,this.#s[t]=e}isEmpty(){return this.#s.length===this.#i}isValueHidden(t){return this.#s[t]!==DomainPruner.#e}reveal(t){for(let e=0;e<this.#s.length;e++)this.#s[e]===t&&(this.#s[e]=DomainPruner.#e,--this.#i)}revealAll(){this.#s.fill(DomainPruner.#e),this.#i=0}}class Breakout extends Solver{#n;#o=!0;constructor(t){super(t),this.#n=new Array(this._pro.constraintSize()),this.#n.fill(1)}name(){return"Breakout"}#r(t,e){let s=0;for(const i of t){const t=i.value();let n=0;for(const t of i)n+=(1-t.isSatisfied())*this.#n[t.index()];t:for(const o of i.domain()){if(t===o)continue;i.assign(o);let r=n;for(const t of i)if(r-=(1-t.isSatisfied())*this.#n[t.index()],r<s)continue t;r>s?(s=r,e.clear(),e.addVariable(i,o)):0!==s&&e.addVariable(i,o)}i.assign(t)}}#a(t){const e=new Set;for(const s of t)for(const t of s)e.add(t);return Array.from(e)}exec(){const t=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;for(const t of this._pro.variables())t.isEmpty()&&t.assign(t.domain().at(0));const s=new AssignmentList;for(;;){const i=this._pro.violatingConstraints();if((this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debug&&console.log("stop: current degree is above the target"),!0;if(this._iterLimit&&this._iterLimit<e++)return this._debug&&console.log("stop: number of iterations has reached the limit"),!1;if(t<Date.now())return this._debug&&console.log("stop: time limit has been reached"),!1;if(this._debug&&console.log(i.length+" violations"),this.#r(this.#a(i),s),0<s.size()){const t=this.#o?s.arbitraryAssignment():s.get(0);t.apply(),s.clear(),this._debug&&console.log("\t"+t)}else{for(let t=0;t<i.length;++t)this.#n[i[t].index()]++;this._debug&&console.log("breakout")}}}setRandomness(t){this.#o=t}}class ForwardChecking extends Solver{#l;#h=new AssignmentList;#c;#u=!1;#f;#g;constructor(t){super(t),this.#l=[...this._pro.variables()];for(const t of this.#l)t.solverObject=new DomainPruner(t.domain().size());this.#d()}name(){return"Forward Checking"}#d(){this.#c=[];for(let t=0;t<this.#l.length;++t){this.#c.push(new Array(this.#l.length));for(let e=0;e<this.#l.length;++e)e<t&&(this.#c[t][e]=this._pro.constraintsBetween(this.#l[e],this.#l[t]))}}#m(t,e){return t<e?this.#c[e][t]:this.#c[t][e]}#b(t,e){for(const s of this.#l){if(!s.isEmpty())continue;const i=s.domain(),n=s.solverObject,o=this.#m(e,s.index());for(const e of o)if(1===e.emptyVariableSize()){for(let o=0,r=i.size();o<r;++o)n.isValueHidden(o)||(s.assign(i.at(o)),0===e.isSatisfied()&&n.hide(o,t));if(s.clear(),n.isEmpty())return!1}}return!0}#p(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<this.#l.length;++s){const i=this.#l[s];if(!i.isEmpty())continue;const n=i.domain().size()-i.solverObject.hiddenSize();n<e&&(e=n,t=s)}return t}#_(t){if(this._iterLimit&&this._iterLimit<this.#f++)return this._debug&&console.log("stop: number of iterations has reached the limit"),!1;if(this.#g<Date.now())return this._debug&&console.log("stop: time limit has been reached"),!1;if(t===this._pro.variableSize())return this.#h.setProblem(this._pro),!0;const e=this.#u?this.#p():t,s=this.#l[e],i=s.domain(),n=s.solverObject;for(let o=0,r=i.size();o<r;++o)if(!n.isValueHidden(o)){if(s.assign(i.at(o)),this.#b(t,e)&&this.#_(t+1))return!0;for(const e of this.#l)e.solverObject.reveal(t)}return s.clear(),!1}exec(){this.#g=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#f=0,this._pro.clearAllVariables();const t=this.#_(0);for(let t=0;t<this.#h.size();++t){const e=this.#h.get(t);e.apply(),e.variable().solverObject.revealAll()}return t}setTargetRate(){}setUsingMinimumRemainingValuesHeuristics(t){this.#u=t}}class MaxForwardChecking extends Solver{#l;#h=new AssignmentList;#v;#w;#C=new Set;#D=[];#f;#g;constructor(t){super(t),this.#l=[...this._pro.variables()];for(const t of this.#l)t.solverObject=new DomainPruner(t.domain().size());this.#v=this._pro.constraintSize()}name(){return"Forward Checking for Max CSPs"}#_(t,e){if(this._iterLimit&&this._iterLimit<this.#f++)return!1;if(this.#g<Date.now())return!1;if(t===this._pro.variableSize()){const t=this._pro.violatingConstraintSize();return t<this.#v&&(this.#v=t,this.#h.setProblem(this._pro),this._debug&&console.log(`   refreshed ${this.#v}`),(this._targetDeg??1)<=this._pro.satisfiedConstraintRate())}const s=this.#l[t],i=s.domain(),n=s.solverObject;for(let o=0;o<i.size();++o)if(!(n.isValueHidden(o)||(s.assign(i.at(o)),this.#w=e+this.#S(t,s),this.#w>this.#v))){if(this.#b(t)&&this.#_(t+1,this.#w))return!0;for(const e of this.#l)e.solverObject.reveal(t)}return s.clear(),!1}#b(t){const e=this.#l[t];for(let s=t+1;s<this.#l.length;++s){const i=this.#l[s];this.#D=this._pro.constraintsBetween(e,i);for(const e of this.#D)if(1===e.emptyVariableSize()&&this.#L(i,e,t)&&i.solverObject.isEmpty())return!1}return!0}#S(t,e){let s=0;this.#C.clear();for(let i=0;i<t;++i){this.#D=this._pro.constraintsBetween(e,this.#l[i]);for(const t of this.#D)this.#C.has(t)||(0===t.isSatisfied()&&++s,this.#C.add(t))}return s}#L(t,e,s){let i=!1;const n=t.domain(),o=t.solverObject;for(let r=0;r<n.size();++r)o.isValueHidden(r)||(t.assign(n.at(r)),0===e.isSatisfied()&&this.#w+1>this.#v&&(o.hide(r,s),i=!0));return i}exec(){this.#g=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#f=0,this._pro.clearAllVariables();const t=this.#_(0,0);this._debug&&(t?console.log("stop: current degree is above the target"):(this._iterLimit&&this._iterLimit<this.#f&&console.log("stop: number of iterations has reached the limit"),this.#g<Date.now()&&console.log("stop: time limit has been reached")));for(let t=0;t<this.#h.size();++t){const e=this.#h.get(t);e.apply(),e.variable().solverObject.revealAll()}return t}}class GENET extends Solver{static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}#z=[];#E;constructor(t){if(super(t),!this.#V())throw new Exception}name(){return"GENET"}#V(){this._debug&&console.log("network creation start");const t=[];for(const t of this._pro.variables()){if(0===t.domain().size())return!1;this.#z.push(new GENET.Cluster(t))}for(const e of this._pro.constraints())if(1===e.size()){const s=e.at(0),i=this.#z[e.at(0).index()];for(let n=0;n<i.size();++n){const o=s.value();s.assign(i.get(n)._value),0===e.isSatisfied()&&t.push(new GENET.Connection(i.get(n))),s.assign(o)}}else{const s=e.at(0),i=e.at(1),n=this.#z[e.at(0).index()],o=this.#z[e.at(1).index()];for(let r=0;r<n.size();++r){const a=s.value();s.assign(n.get(r)._value);for(let s=0;s<o.size();++s){const a=i.value();i.assign(o.get(s)._value),0===e.isSatisfied()&&t.push(new GENET.Connection(n.get(r),o.get(s))),i.assign(a)}s.assign(a)}}for(const t of this.#z)for(const e of t._neurons)e.lockConnections();return this.#E=t,this._debug&&console.log("network creation complete"),!0}#y(t){for(let e=t.length;e>1;--e){const s=GENET.nextInt(e),i=t[e-1];t[e-1]=t[s],t[s]=i}return t}exec(){const t=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;const s=new AssignmentList,i=[];for(let t=0;t<this.#z.length;t++)i.push(t);let n=this._pro.satisfiedConstraintRate();for(;;){if(this._iterLimit&&this._iterLimit<e++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(t<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}let o=!1;for(const t of this.#y(i))this.#z[t].setActivityMaximumInput()&&(o=!0);if(o){for(const t of this.#z)t.applyToVariable();const t=this._pro.satisfiedConstraintRate();if(n<t&&(n=t,this._debug&&console.log(`satisfied constraint rate: ${t}`),s.setProblem(this._pro),this._targetDeg??1<=n))return this._debug&&console.log("stop: current degree is above the target"),s.apply(),!0}else for(const t of this.#E)t.refreshWeight()}return s.apply(),!1}}{class t{static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}#x;#N;#A=[];_neurons=[];constructor(e){this.#x=e;for(const t of e.domain())this._neurons.push(new s(t));this.#k(t.nextInt(this._neurons.length))}#k(t){for(const t of this._neurons)t._isActive=!1;this._neurons[t]._isActive=!0,this.#N=t}applyToVariable(){this.#x.assign(this._neurons[this.#N]._value)}get(t){return this._neurons[t]}neurons(){return this._neurons}setActivityMaximumInput(){this.#A.length=0;let e=Number.NEGATIVE_INFINITY,s=!1;for(let t=0;t<this._neurons.length;++t){const i=this._neurons[t].getInput();e<=i&&(e<i&&(e=i,this.#A.length=0,s=!1),this.#A.push(t),this.#N===t&&(s=!0))}return!s&&0!==this.#A.length&&(this.#k(this.#A[t.nextInt(this.#A.length)]),!0)}size(){return this._neurons.length}}GENET.Cluster=t;class e{#R;#T;_weight;constructor(t,e=null){this._weight=-1,this.#R=t,this.#R.addConnection(this),this.#T=e,null!==this.#T&&this.#T.addConnection(this)}getNeuron(t){return t===this.#R?this.#T:t===this.#T?this.#R:null}refreshWeight(){this.#R._isActive&&(null===this.#T||this.#T._isActive)&&(this._weight+=-1)}}GENET.Connection=e;class s{#M=[];#E;_value;_isActive=!1;constructor(t){this._value=t}addConnection(t){this.#M.push(t)}lockConnections(){this.#E=[...this.#M],this.#M=null}getInput(){let t=0;for(const e of this.#E){const s=e.getNeuron(this);t+=e._weight*(null===s||s._isActive?1:0)}return t}}GENET.Neuron=s}class LocalChanges extends Solver{static#F(t,e){const s=new Set(t);for(const t of e)s.add(t);return s}static#I(t,e){const s=new Set(t);for(const t of e)s.delete(t);return s}static#O(t,e){const s=new Set(t);return s.add(e),s}static#W(t,e){const s=new Set(t);return s.delete(e),s}#f;#g;#j;constructor(t,e=!1){super(t),e&&this._pro.clearAllVariables()}name(){return"Local Changes"}#P(t,e,s){const i=new Set,n=new Set;for(const s of t){const t=this._pro.constraintsBetween(e,s);for(const e of t)n.add(e)}const o=e.value();e.assign(s);for(const t of n)if(0===t.isSatisfied())for(const e of t)i.add(e);return e.assign(o),i.delete(e),i}#U(t,e,s){const i=new Set;for(const s of t){const t=this._pro.constraintsBetween(e,s);for(const e of t)i.add(e)}const n=e.value();e.assign(s);for(const t of i)if(0===t.isSatisfied())return e.assign(n),!1;return e.assign(n),!0}#B(t,e,s,i){if(!this.#U(t,s,i))return!1;const n=LocalChanges.#F(t,e);if(this.#U(n,s,i))return!0;const o=this.#P(n,s,i),r=LocalChanges.#I(n,o);this.#U(r,s,i)||this._debug&&console.log("bug");for(const t of o)t.clear();return t=LocalChanges.#O(t,s),e=LocalChanges.#I(e,o),this.#H(t,e,o)}#X(t,e,s,i){if(0===i.size)return!1;const n=i.values().next().value,o=AssignmentList.fromVariables(e);s.assign(n);const r=this.#B(t,e,s,n);return r||this.#j?r:(s.clear(),o.apply(),this.#X(t,e,s,LocalChanges.#W(i,n)))}#H(t,e,s){if(this._debug&&console.log(`V1 ${t.size}, V2' ${e.size}, V3' ${s.size}`),(this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debug&&console.log("stop: current degree is above the target"),this.#j=!0,!0;if(this._iterLimit&&this._iterLimit<this.#f++)return this._debug&&console.log("stop: number of iterations has reached the limit"),this.#j=!0,!1;if(this.#g<Date.now())return this._debug&&console.log("stop: time limit has been reached"),this.#j=!0,!1;if(0===s.size)return!0;const i=s.values().next().value,n=new Set;for(const t of i.domain())n.add(t);const o=this.#X(t,e,i,n);return!o||this.#j?o:(e=LocalChanges.#O(e,i),s=LocalChanges.#W(s,i),this.#H(t,e,s))}exec(){this.#g=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#f=0,this.#j=!1,0===this._pro.emptyVariableSize()&&this._pro.clearAllVariables();const t=new Set,e=new Set;for(const s of this._pro.variables())(s.isEmpty()?e:t).add(s);return this.#H(new Set,t,e)}}class LocalChangesEx extends Solver{static#F(t,e){const s=new Set(t);for(const t of e)s.add(t);return s}static#I(t,e){const s=new Set(t);for(const t of e)s.delete(t);return s}static#O(t,e){const s=new Set(t);return s.add(e),s}static#W(t,e){const s=new Set(t);return s.delete(e),s}#f;#g;#j;constructor(t,e=!1){super(t),e&&this._pro.clearAllVariables()}name(){return"Local Changes Ex"}#P(t,e,s){const i=new Set,n=new Set;for(const s of t){const t=this._pro.constraintsBetween(e,s);for(const e of t)n.add(e)}const o=e.value();e.assign(s);for(const t of n)if(0===t.isSatisfied())for(const e of t)i.add(e);return e.assign(o),i.delete(e),i}#U(t,e,s){const i=new Set;for(const s of t){const t=this._pro.constraintsBetween(e,s);for(const e of t)i.add(e)}const n=e.value();e.assign(s);for(const t of i)if(0===t.isSatisfied())return e.assign(n),!1;return e.assign(n),!0}#B(t,e,s){if(!this.#U(t,s,s.value()))return!1;const i=LocalChangesEx.#F(t,e);if(this.#U(i,s,s.value()))return!0;const n=this.#P(i,s,s.value());return e=LocalChangesEx.#I(e,n),t=LocalChangesEx.#O(t,s),this.#H(t,e,n)}#X(t,e,s){for(const i of s.domain()){const n=AssignmentList.fromVariables(e);s.assign(i);const o=this.#B(t,e,s);if(o||this.#j)return o;s.clear(),n.apply()}return!1}#H(t,e,s){for(e=new Set(e),s=new Set(s);;){if(this._debug&&console.log(`V1 ${t.size}, V2' ${e.size}, V3' ${s.size}`),(this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debug&&console.log("stop: current degree is above the target"),this.#j=!0,!0;if(this._iterLimit&&this._iterLimit<this.#f++)return this._debug&&console.log("stop: number of iterations has reached the limit"),this.#j=!0,!1;if(this.#g<Date.now())return this._debug&&console.log("stop: time limit has been reached"),this.#j=!0,!1;if(0===s.size)return!0;const i=s.values().next().value,n=this.#X(t,e,i);if(!n||this.#j)return n;e.add(i),s.delete(i)}}exec(){this.#g=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#f=0,this.#j=!1,0===this._pro.emptyVariableSize()&&this._pro.clearAllVariables();const t=new Set,e=new Set;for(const s of this._pro.variables())(s.isEmpty()?e:t).add(s);return this.#H(new Set,t,e)}}class CrispSRS3 extends Solver{#$=new Set;#G=new Set;#q=[];#Y=[];#o=!0;constructor(t){super(t);for(const t of this._pro.constraints())this.#q.push(new CrispSRS3.TreeNode(t)),this.#Y.push(null)}name(){return"SRS 3 for Crisp CSPs"}#J(t){const e=t.index();return null===this.#Y[e]&&(this.#Y[e]=t.neighbors()),this.#Y[e]}#K(t){this._debug&&console.log("repair");const e=new AssignmentList;let s=0;for(const i of t){const n=i.value();let o=0;for(const t of i)o+=1-t.isSatisfied();t:for(const r of i.domain()){if(n===r)continue;if(i.assign(r),1!==t.isSatisfied())continue;let a=o;for(const t of i)if(a-=1-t.isSatisfied(),a<s)continue t;a>s?(s=a,e.clear(),e.addVariable(i,r)):0!==s&&e.addVariable(i,r)}i.assign(n)}if(e.size()>0){const t=this.#o?e.arbitraryAssignment():e.get(0);return t.apply(),this._debug&&console.log("\t"+t),!0}return!1}#Q(t,e){const s=[];let i=t;for(;;){i=i.parent(),s.length=0,i.getDescendants(s),i.clear();for(const t of e)this.#G.delete(t),this.#$.delete(t);if(e.delete(i))break;if(this.#G.add(i),null!==i.parent()&&!this.#K(i.parent().getObject()))break}}#Z(t){this._debug&&console.log("spread"),this.#$.add(t);for(const e of this.#J(t.getObject())){const s=this.#q[e.index()];this.#$.has(s)||this.#G.has(s)||(s.clear(),t.add(s),this.#G.add(s))}}#tt(t){this._debug&&console.log("srs");const e=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let s=0;this.#$.clear(),this.#G.clear();for(const e of t)this.#G.add(e);for(;t.size&&this.#G.size;){if((this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debug&&console.log("stop: current degree is above the target"),!0;if(this._iterLimit&&this._iterLimit<s++)return this._debug&&console.log("stop: number of iterations has reached the limit"),!1;if(e<Date.now())return this._debug&&console.log("stop: time limit has been reached"),!1;const i=this.#G.values().next().value;this.#G.delete(i),this.#K(i.getObject())?t.delete(i)||(null!==i.parent()&&this.#K(i.parent().getObject())?this.#Q(i,t):this.#Z(i)):this.#Z(i)}return!1}exec(){const t=this._pro.violatingConstraints(),e=new Set;for(const s of t){const t=this.#q[s.index()];e.add(t)}return!!this.#tt(e)||0===e.length}setRandomness(t){this.#o=t}}{class t{#et=[];#st;#it;constructor(t){this.#it=t}add(t){t.#st=this,this.#et.push(t)}clear(){for(const t of this.#et)t.#st=null;this.#et.length=0}getDescendants(t){t.push(this);for(const e of this.#et)e.getDescendants(t)}getObject(){return this.#it}parent(){return this.#st}}CrispSRS3.TreeNode=t}class FuzzyBreakout extends Solver{#n;#nt;#o=!0;constructor(t){super(t),this.#n=new Array(this._pro.constraintSize()),this.#n.fill(1)}name(){return"Fuzzy Breakout"}foundSolution(){return!1}#r(t,e){let s=0;for(const i of t){const t=i.value();let n=0;for(const t of i)n+=(1-t.satisfactionDegree())*this.#n[t.index()];t:for(const o of i.domain()){if(t===o)continue;i.assign(o);let r=n;for(const t of i)if(r-=(1-t.satisfactionDegree())*this.#n[t.index()],r<s)continue t;r>s?(s=r,e.clear(),e.addVariable(i,o)):0!==s&&e.addVariable(i,o)}i.assign(t)}}#ot(t){const e=new Set;for(const s of t)for(const t of s)e.add(t);return Array.from(e)}exec(){const t=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;for(const t of this._pro.variables())t.isEmpty()&&t.assign(t.domain().at(0));const s=this._pro.worstSatisfactionDegree(),i=new AssignmentList,n=new AssignmentList;for(;;){const[s,o]=this._pro.constraintsWithWorstSatisfactionDegree();if(null!==this._targetDeg&&this._targetDeg<=o)return this._debug&&console.log("stop: current degree is above the target"),!0;if(this._iterLimit&&this._iterLimit<e++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(t<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}if(this._debug&&console.log("worst satisfaction degree: "+o),this.#nt<o&&(n.setProblem(this._pro),this.#nt=o,foundSolution(n,this.#nt)))return!0;if(this.#r(this.#ot(s),i),0<i.size()){const t=this.#o?i.arbitraryAssignment():i.get(0);t.apply(),i.clear(),this._debug&&console.log("\t"+t)}else{for(let t=0;t<s.length;++t)this.#n[s[t].index()]++;this._debug&&console.log("breakout")}}return null===this._targetDeg&&s<this._pro.worstSatisfactionDegree()}setRandomness(t){this.#o=t}}class FuzzyForwardChecking extends Solver{static CONTINUE=0;static TERMINATE=1;#l;#h=new AssignmentList;#c;#rt=0;#f;#g;#u=!1;#at=0;#lt;#ht;#C;#ct=!1;constructor(t,e=null){super(t),this.#l=[...this._pro.variables()],this.#lt=new Array(this._pro.variableSize()),this.#d(),this.#C=new Array(this._pro.constraintSize());const s=[];for(const t of this._pro.constraints())1===t.size()&&s.push(t);this.#ht=[...s],e&&(this.#rt=e)}name(){return"Forward Checking for Fuzzy CSPs"}#d(){this.#c=[];for(let t=0;t<this.#l.length;++t){this.#c.push(new Array(this.#l.length));for(let e=0;e<this.#l.length;e++)e<t&&(this.#c[t][e]=this._pro.constraintsBetween(this.#l[e],this.#l[t]))}}#m(t,e){return t<e?this.#c[e][t]:this.#c[t][e]}#ut(){for(const t of this.#ht){const e=t.at(0),s=e.value(),i=e.domain(),n=e.solverObject;for(let s=0,o=i.size();s<o;++s)e.assign(i.at(s)),t.satisfactionDegree()<=this.#rt&&n.hide(s,-1);if(e.assign(s),n.isEmpty())return!1}return!0}#ft(t,e,s){const i=e.domain(),n=e.solverObject;for(let o=0,r=i.size();o<r;++o)n.isValueHidden(o)||(e.assign(i.at(o)),s.satisfactionDegree()<=this.#rt&&n.hide(o,t));return e.clear(),!n.isEmpty()}#gt(t,e,s){const i=e.domain(),n=e.solverObject,o=null;for(const t of s)if(t.isEmpty()&&t!==e){o=t;break}const r=o.domain(),a=o.solverObject;t:for(let l=0,h=i.size();l<h;++l)if(!n.isValueHidden(l)){e.assign(i.at(l));for(let t=0,e=r.size();t<e;++t){if(a.isValueHidden(t))continue;o.assign(r.at(t));if(s.satisfactionDegree()>this.#rt)continue t}n.hide(l,t)}return o.clear(),e.clear(),!n.isEmpty()}#dt(t,e,s){const i=e.domain(),n=e.solverObject;let o=null,r=null;for(let t=0,i=s.size();t<i;++t){let i=s.at(t);if(i.isEmpty()&&i!==e){if(null!==o){r=i;break}o=i}}const a=o.domain(),l=r.domain(),h=o.solverObject,c=r.solverObject;t:for(let u=0,f=i.size();u<f;++u)if(!n.isValueHidden(u)){e.assign(i.at(u));for(let t=0,e=a.size();t<e;++t)if(!h.isValueHidden(t)){o.assign(a.at(t));for(let t=0,e=l.size();t<e;++t){if(c.isValueHidden(t))continue;r.assign(l.at(t));if(s.satisfactionDegree()>this.#rt)continue t}}n.hide(u,t)}return r.clear(),o.clear(),e.clear(),!n.isEmpty()}#mt(t,e,s,i){const n=e.domain(),o=e.solverObject,r=new Array(i-1);let a=0;for(let t=0,i=s.size();t<i;++t){const i=s.at(t);i.isEmpty()&&i!==e&&(r[a++]=i)}const l=new Array(r.length);t:for(let i=0,a=n.size();i<a;++i)if(!o.isValueHidden(i)){e.assign(n.at(i)),l.fill(0);e:for(;;){let t=!1;for(let e=0;e<r.length;++e){const s=r[e].domain();if(r[e].solverObject.isValueHidden(l[e])){t=!0;break}r[e].assign(s.at(l[e]))}if(!t){if(s.satisfactionDegree()>this.#rt)continue t}for(let t=0;t<r.length&&(l[t]++,!(l[t]<r[t].domain().size()));++t)if(l[t]=0,t===r.length-1)break e}o.hide(i,t)}for(const t of r)t.clear();return e.clear(),!o.isEmpty()}#b(t,e){for(const s of this.#l){if(!s.isEmpty())continue;const i=this.#m(e,s.index());for(const e of i){const i=e.emptyVariableSize();if(1===i){if(!this.#ft(t,s,e))return!1}else if(this.#ct)if(2===i){if(!this.#gt(t,s,e))return!1}else if(3===i){if(!this.#dt(t,s,e))return!1}else if(i>3&&!this.#mt(t,s,e,i))return!1}}return!0}#bt(t){this.#C.fill(!1);for(let e=0;e<this.#l.length;++e){const s=this.#l[e];if(s===t||s.isEmpty())continue;const i=this.#m(t.index(),e);for(const t of i){if(this.#C[t.index()])continue;const e=t.satisfactionDegree();if(e!==Constraint.UNDEFINED&&e<=this.#rt)return!1;this.#C[t.index()]=!0}}return!0}#pt(){for(let t=0;t<this.#lt.length;++t){const e=this.#lt[t].index();for(let s=t+1;s<this.#lt.length;++s){const i=this.#lt[s],n=this.#m(e,i.index());for(const e of n){const s=i.value(),n=i.domain(),o=i.solverObject;for(let s=0,r=n.size();s<r;++s)o.isValueHidden(s)||(i.assign(n.at(s)),e.satisfactionDegree()<=this.#rt&&o.hide(s,t));i.assign(s)}}}}#p(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<this.#l.length;++s){const i=this.#l[s];if(!i.isEmpty())continue;const n=i.domain().size()-i.solverObject.hiddenSize();n<e&&(e=n,t=s)}return t}#_(t){let e=FuzzyForwardChecking.CONTINUE;const s=this.#u?this.#p():t,i=this.#l[s],n=i.domain(),o=i.solverObject;this.#lt[t]=i;for(let r=0,a=n.size();r<a;++r){if(o.isValueHidden(r))continue;if(this._iterLimit&&this._iterLimit<this.#f++||this.#g<Date.now()){e=FuzzyForwardChecking.TERMINATE;break}i.assign(n.at(r));for(const e of this.#l)e.solverObject.reveal(t);if(!this.#bt(i))continue;if(!this.#b(t,s))continue;const a=t+1;if(e=a===this.#l.length-1?this.#_t(a):this.#_(a),e===FuzzyForwardChecking.TERMINATE)break}if(e===FuzzyForwardChecking.CONTINUE)for(const e of this.#l)e.solverObject.reveal(t);return i.clear(),e}#_t(t){let e=FuzzyForwardChecking.CONTINUE;const s=this.#l[this.#u?this.#p():t],i=s.domain(),n=s.solverObject;this.#lt[t]=s;for(let t=0,o=i.size();t<o;++t){if(n.isValueHidden(t))continue;if(this._iterLimit&&this._iterLimit<this.#f++||this.#g<Date.now()){e=FuzzyForwardChecking.TERMINATE;break}s.assign(i.at(t));const o=this._pro.worstSatisfactionDegree();if(o>this.#rt){if(this.#rt=o,this.#h.setProblem(this._pro),e=FuzzyForwardChecking.TERMINATE,null!==this._targetDeg&&this._targetDeg<=this.#rt)break;this.#ut(),this.#pt()}}return s.clear(),e}exec(){this.#g=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#f=0;for(const t of this.#l)t.solverObject=new DomainPruner(t.domain().size());if(this._pro.clearAllVariables(),!this.#ut())return!1;let t=!1;for(;;){if(this.#_(0)===FuzzyForwardChecking.TERMINATE){if(this._iterLimit&&this._iterLimit<this.#f++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(this.#g<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}}if(this.#h.isEmpty())break;if(this._debug&&console.log(`\tfound a solution: ${this.#rt}`),this.foundSolution(this.#h,this.#rt)){t=!0;break}if(null===this._targetDeg)t=!0,this.#rt+=this.#at;else if(this._targetDeg<=this.#rt){this._debug&&console.log("stop: current degree is above the target"),t=!0;break}for(const t of this.#l)t.solverObject.revealAll()}this.#h.apply();for(const t of this.#l)t.solverObject=null;return t}setTargetRate(t=null){if(this._targetDeg=t,null===this._targetDeg)this.#rt=0;else{let t=Number.MIN_VALUE;for(this.#rt=this._targetDeg-t;this.#rt>=this._targetDeg;)t*=10,this.#rt=this._targetDeg-t}}setUsingMinimumRemainingValuesHeuristics(t){this.#u=t}setIncrementStepOfWorstSatisfactionDegree(t){this.#at=t}setIntensivePruning(t){this.#ct=t}}class FuzzyForwardCheckingBc extends Solver{static CONTINUE=0;static TERMINATE=1;#l;#h=new AssignmentList;#c;#rt=0;#f;#g;#u=!1;#at=0;constructor(t,e=null){super(t),this.#l=[...this._pro.variables()],this.#d(),this.#rt=Math.max(0,t.worstSatisfactionDegree()),e&&(this.#rt=e)}name(){return"Forward Checking for Fuzzy CSPs of Binary Constraints"}foundSolution(){return!1}#d(){this.#c=[];for(let t=0;t<this.#l.length;++t){this.#c.push(new Array(this.#l.length));for(let e=0;e<this.#l.length;e++)e<t&&(this.#c[t][e]=this._pro.constraintsBetween(this.#l[e],this.#l[t]))}}#m(t,e){return t<e?this.#c[e][t]:this.#c[t][e]}#ft(t,e,s){const i=e.domain(),n=e.solverObject;for(let o=0,r=i.size();o<r;++o)n.isValueHidden(o)||(e.assign(i.at(o)),s.satisfactionDegree()<=this.#rt&&n.hide(o,t));return e.clear(),!n.isEmpty()}#b(t,e){for(const s of this.#l){if(!s.isEmpty())continue;const i=this.#m(e,s.index());for(const e of i)if(2===e.size()&&!this.#ft(t,s,e))return!1}return!0}#p(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<this.#l.length;++s){const i=this.#l[s];if(!i.isEmpty())continue;const n=i.domain().size()-i.solverObject.hiddenSize();n<e&&(e=n,t=s)}return t}#_(t){let e=FuzzyForwardCheckingBc.CONTINUE;const s=this.#u?this.#p():t,i=this.#l[s],n=i.domain(),o=i.solverObject;for(let r=0,a=n.size();r<a;++r){if(o.isValueHidden(r))continue;if(this._iterLimit&&this._iterLimit<this.#f++||this.#g<Date.now()){e=FuzzyForwardCheckingBc.TERMINATE;break}i.assign(n.at(r));for(const e of this.#l)e.solverObject.reveal(t);if(!this.#b(t,s))continue;const a=t+1;if(e=a===this.#l.length-1?this.#_t(a):this.#_(a),e===FuzzyForwardCheckingBc.TERMINATE)break}if(e===FuzzyForwardCheckingBc.CONTINUE)for(const e of this.#l)e.solverObject.reveal(t);return i.clear(),e}#_t(t){let e=FuzzyForwardCheckingBc.CONTINUE;const s=this.#l[this.#u?this.#p():t],i=s.domain(),n=s.solverObject;for(let t=0,o=i.size();t<o;++t){if(n.isValueHidden(t))continue;if(this._iterLimit&&this._iterLimit<this.#f++||this.#g<Date.now()){e=FuzzyForwardCheckingBc.TERMINATE;break}s.assign(i.at(t));const o=this._pro.worstSatisfactionDegree();if(o>this.#rt&&(this.#rt=o,this.#h.setProblem(this._pro),e=FuzzyForwardCheckingBc.TERMINATE,null!==this._targetDeg&&this._targetDeg<=this.#rt))break}return s.clear(),e}exec(){this.#g=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#f=0;for(const t of this.#l)t.solverObject=new DomainPruner(t.domain().size());this._pro.clearAllVariables();const t=new AssignmentList;let e=!1;for(;;){if(this.#_(0)===FuzzyForwardCheckingBc.TERMINATE){if(this._iterLimit&&this._iterLimit<this.#f++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(this.#g<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}}if(this.#h.isEmpty())break;if(t.setAssignmentList(this.#h),this.#h.clear(),this._debug&&console.log(`\tfound a solution: ${this.#rt}`),this.foundSolution(t,this.#rt)){e=!0;break}if(null===this._targetDeg){if(e=!0,this.#rt+this.#at>1)break;this.#rt+=this.#rt+this.#at>1?0:this.#at}else if(this._targetDeg<=this.#rt){this._debug&&console.log("stop: current degree is above the target"),e=!0;break}for(const t of this.#l)t.solverObject.revealAll()}t.apply();for(const t of this.#l)t.solverObject=null;return e}setTargetRate(t=null){if(this._targetDeg=t,null===this._targetDeg)this.#rt=0;else{let t=Number.MIN_VALUE;for(this.#rt=this._targetDeg-t;this.#rt>=this._targetDeg;)t*=10,this.#rt=this._targetDeg-t}}setUsingMinimumRemainingValuesHeuristics(t){this.#u=t}setIncrementStepOfWorstSatisfactionDegree(t){this.#at=t}}class FuzzyGENET extends Solver{static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}#z=[];#E;constructor(t,e=1){if(super(t),!this.#V(e))throw new Exception}name(){return"Fuzzy GENET"}#V(t){this._debug&&console.log("network creation start");const e=[];for(const t of this._pro.variables()){if(0===t.domain().size())return!1;this.#z.push(new FuzzyGENET.Cluster(t))}for(const s of this._pro.constraints())if(1===s.size()){const i=s.at(0),n=this.#z[s.at(0).index()];for(let o=0;o<n.size();++o){const r=i.value();i.assign(n.get(o)._value),s.satisfactionDegree()<=t&&e.push(new FuzzyGENET.Connection(s,n.get(o))),i.assign(r)}}else{const i=s.at(0),n=s.at(1),o=this.#z[s.at(0).index()],r=this.#z[s.at(1).index()];for(let a=0;a<o.size();++a){const l=i.value();i.assign(o.get(a)._value);for(let i=0;i<r.size();++i){const l=n.value();n.assign(r.get(i)._value),s.satisfactionDegree()<=t&&e.push(new FuzzyGENET.Connection(s,o.get(a),r.get(i))),n.assign(l)}i.assign(l)}}for(const t of this.#z)for(const e of t._neurons)e.lockConnections();return this.#E=e,this._debug&&console.log("network creation complete"),!0}#y(t){for(let e=t.length;e>1;--e){const s=GENET.nextInt(e),i=t[e-1];t[e-1]=t[s],t[s]=i}return t}exec(){const t=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;const s=new AssignmentList,i=[];for(let t=0;t<this.#z.length;t++)i.push(t);let n=this._pro.worstSatisfactionDegree(),o=!1;for(;;){if(this._iterLimit&&this._iterLimit<e++){this._debug&&console.log("stop: number of iterations has reached the limit");break}if(t<Date.now()){this._debug&&console.log("stop: time limit has been reached");break}let r=!1;for(const t of this.#y(i))this.#z[t].setActivityMaximumInput()&&(r=!0);if(r){for(const t of this.#z)t.applyToVariable();const t=this._pro.worstSatisfactionDegree();if(n<t){if(n=t,this._debug&&console.log(`worst satisfaction degree: ${t}`),s.setProblem(this._pro),this.foundSolution(s,t)){o=!0;break}if(null===this._targetDeg)o=!0;else if(this._targetDeg<=n){this._debug&&console.log("stop: current degree is above the target"),o=!0;break}}}else for(const t of this.#E)t.refreshWeight()}return s.apply(),o}}{class t{static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}#x;#N;#A=[];_neurons=[];constructor(e){this.#x=e;for(const t of e.domain())this._neurons.push(new s(t));this.#k(t.nextInt(this._neurons.length))}#k(t){for(const t of this._neurons)t._isActive=!1;this._neurons[t]._isActive=!0,this.#N=t}applyToVariable(){this.#x.assign(this._neurons[this.#N]._value)}get(t){return this._neurons[t]}neurons(){return this._neurons}setActivityMaximumInput(){this.#A.length=0;let e=Number.NEGATIVE_INFINITY,s=!1;for(let t=0;t<this._neurons.length;++t){const i=this._neurons[t].getInput();e<=i&&(e<i&&(e=i,this.#A.length=0,s=!1),this.#A.push(t),this.#N===t&&(s=!0))}return!s&&0!==this.#A.length&&(this.#k(this.#A[t.nextInt(this.#A.length)]),!0)}size(){return this._neurons.length}}FuzzyGENET.Cluster=t;class e{#vt;#R;#T;_weight;constructor(t,e,s=null){this._weight=t.satisfactionDegree()-1,this.#vt=t,this.#R=e,this.#R.addConnection(this),this.#T=s,null!==this.#T&&this.#T.addConnection(this)}getNeuron(t){return t===this.#R?this.#T:t===this.#T?this.#R:null}refreshWeight(){this.#R._isActive&&(null===this.#T||this.#T._isActive)&&(1===this.#vt.size()?this._weight+=this.#vt.fuzzyRelation().satisfactionDegree(this.#R._value)-1:this._weight+=this.#vt.fuzzyRelation().satisfactionDegree(this.#R._value,this.#T._value)-1)}}FuzzyGENET.Connection=e;class s{#M=[];#E;_value;_isActive=!1;constructor(t){this._value=t}addConnection(t){this.#M.push(t)}lockConnections(){this.#E=[...this.#M],this.#M=null}getInput(){let t=0;for(const e of this.#E){const s=e.getNeuron(this);t+=e._weight*(null===s||s._isActive?1:0)}return t}}FuzzyGENET.Neuron=s}class FlexibleLocalChanges extends Solver{static#F(t,e){const s=new Set(t);for(const t of e)s.add(t);return s}static#I(t,e){const s=new Set(t);for(const t of e)s.delete(t);return s}static#O(t,e){const s=new Set(t);return s.add(e),s}static#W(t,e){const s=new Set(t);return s.delete(e),s}#wt;#Ct;#f;#g;#j;constructor(t){super(t),this.#Dt()}name(){return"Flexible Local Changes"}#St(t,e){const s=new Map;for(const t of e)if(t.isDefined())for(const e of t)s.has(e)?s.set(e,s.get(e)+1):s.set(e,1);const i=[...t];i.sort(((t,e)=>{let i=0,n=0;return s.has(t)&&(i=s.get(t)),s.has(e)&&(n=s.get(e)),i<n?1:i>n?-1:0}));const n=new Set;for(const t of i){let s=!1;for(const t of e)if(t.isDefined()){s=!0;break}if(!s)break;t.clear(),n.add(t)}return n}#Dt(){let t=1,e=0;for(const s of this._pro.variables())for(const i of s){const s=i.lowestConsistencyDegree(),n=i.highestConsistencyDegree();s<t&&(t=s),n>e&&(e=n)}this.#Ct=t,this.#wt=e}#Lt(t,e,s,i,n,o,r){const a=this.#St(e,o),l=FlexibleLocalChanges.#O(t,s),h=FlexibleLocalChanges.#I(e,a);return this.#zt(l,h,a,i,Math.min(n,i),r)}#Et(t,e,s,i,n,o){let r=this.#Ct;if(0===s.domain().size())return r;let a=AssignmentList.fromVariables(e),l=s.domain().at(0);const h=AssignmentList.fromVariables(e);for(let c=0;c<s.domain().size()&&r<n;++c){const u=s.domain().at(c);s.assign(u);const f=Math.min(i,this.#Vt(t,s,r,o));if(f>Math.max(r,o)){const i=new Set,c=Math.min(Math.min(f,n),this.#yt(t,e,s,f,n,i));if(c>r&&(r=c,l=u,a=AssignmentList.fromVariables(e)),i.size){const c=this.#Lt(t,e,s,f,n,i,Math.max(o,r));if(-1!==this.#j)return r;c>r&&(r=c,l=u,a=AssignmentList.fromVariables(e)),h.apply()}}}return a.apply(),s.assign(l),r}#zt(t,e,s,i,n,o){if(this._debug&&console.log(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),null!==this._targetDeg&&this._targetDeg<=this._pro.worstSatisfactionDegree())return this._debug&&console.log("stop: current degree is above the target"),this.#j=1,n;if(this._iterLimit&&this._iterLimit<this.#f++)return this._debug&&console.log("stop: number of iterations has reached the limit"),this.#j=0,n;if(this.#g<Date.now())return this._debug&&console.log("stop: time limit has been reached"),this.#j=0,n;if(0===s.size)return n;const r=s.values().next().value,a=this.#Et(t,e,r,i,n,o);return-1!==this.#j?n:a<o?this.#Ct:(e=FlexibleLocalChanges.#O(e,r),s=FlexibleLocalChanges.#W(s,r),this.#zt(t,e,s,i,a,o))}#xt(t,e){const s=new Set;for(const e of t)for(const t of e)s.add(t);let i=1;for(const t of s){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&(e<i&&(i=e))}for(const t of this._pro.constraints()){t.lowestConsistencyDegree()<this.#wt&&e.add(t)}return i}#Vt(t,e,s,i){let n=1;const o=new Set;for(const s of t){const t=this._pro.constraintsBetween(s,e);for(const e of t)o.add(e)}for(const t of o){const e=t.satisfactionDegree();if(e!==Constraint.UNDEFINED&&(e<n&&(n=e),n<=s||n<=i))return n}return n}#yt(t,e,s,i,n,o){let r=1;const a=new Set;for(const e of t){const t=this._pro.constraintsBetween(e,s);for(const e of t)a.add(e)}for(const t of e){const e=this._pro.constraintsBetween(t,s);for(const t of e)a.add(t)}for(const t of a){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&(e<r&&(r=e))}for(const t of a){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&((e<i||e<n)&&o.add(t))}return r}exec(){this.#g=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#f=0,this.#j=-1;const t=this._pro.worstSatisfactionDegree();0===this._pro.emptyVariableSize()&&this._pro.clearAllVariables();const e=new Set,s=new Set,i=new Set;for(const t of this._pro.variables())(t.isEmpty()?i:s).add(t);const n=new Set,o=this.#xt(s,n);let r,a=null;0===i.size?(r=o,a=AssignmentList.fromVariables(s)):r=this.#Ct;const l=FlexibleLocalChanges.#F(this.#St(s,n),i),h=FlexibleLocalChanges.#I(s,l);let c=this.#zt(e,h,l,this.#wt,this.#wt,r);return c<r&&null!==a&&a.apply(),c=this._pro.worstSatisfactionDegree(),c>t&&c>0&&(0!==this.#j||null===this._targetDeg)}}class FlexibleLocalChangesEx extends Solver{static#F(t,e){const s=new Set(t);for(const t of e)s.add(t);return s}static#I(t,e){const s=new Set(t);for(const t of e)s.delete(t);return s}static#O(t,e){const s=new Set(t);return s.add(e),s}#wt;#Ct;#f;#g;#j;constructor(t){super(t),this.#Dt()}name(){return"Flexible Local Changes Ex"}#St(t,e){const s=new Map;for(const t of e)if(t.isDefined())for(const e of t)s.has(e)?s.set(e,s.get(e)+1):s.set(e,1);const i=[...t];i.sort(((t,e)=>{let i=0,n=0;return s.has(t)&&(i=s.get(t)),s.has(e)&&(n=s.get(e)),i<n?1:i>n?-1:0}));const n=new Set;for(const t of i){let s=!1;for(const t of e)if(t.isDefined()){s=!0;break}if(!s)break;t.clear(),n.add(t)}return n}#Dt(){let t=1,e=0;for(const s of this._pro.variables())for(const i of s){const s=i.lowestConsistencyDegree(),n=i.highestConsistencyDegree();s<t&&(t=s),n>e&&(e=n)}this.#Ct=t,this.#wt=e}#Lt(t,e,s,i,n,o,r){const a=this.#St(e,o),l=FlexibleLocalChangesEx.#O(t,s),h=FlexibleLocalChangesEx.#I(e,a);return this.#zt(l,h,a,i,Math.min(n,i),r)}#Et(t,e,s,i,n,o){let r=this.#Ct;if(0===s.domain().size())return r;let a=AssignmentList.fromVariables(e),l=s.domain().at(0);const h=AssignmentList.fromVariables(e);for(let c=0;c<s.domain().size()&&r<n;++c){const u=s.domain().at(c);s.assign(u);const f=Math.min(i,this.#Vt(t,s,r,o));if(f>Math.max(r,o)){const i=new Set,c=Math.min(Math.min(f,n),this.#yt(t,e,s,f,n,i));if(c>r&&(r=c,l=u,a=AssignmentList.fromVariables(e)),i.size){const c=this.#Lt(t,e,s,f,n,i,Math.max(o,r));if(-1!==this.#j)return r;c>r&&(r=c,l=u,a=AssignmentList.fromVariables(e)),h.apply()}}}return a.apply(),s.assign(l),r}#zt(t,e,s,i,n,o){for(e=new Set(e),s=new Set(s);;){if(this._debug&&console.log(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),null!==this._targetDeg&&this._targetDeg<=this._pro.worstSatisfactionDegree())return this._debug&&console.log("stop: current degree is above the target"),this.#j=1,n;if(this._iterLimit&&this._iterLimit<this.#f++)return this._debug&&console.log("stop: number of iterations has reached the limit"),this.#j=0,n;if(this.#g<Date.now())return this._debug&&console.log("stop: time limit has been reached"),this.#j=0,n;if(0===s.size)return n;const r=s.values().next().value,a=this.#Et(t,e,r,i,n,o);if(-1!==this.#j)return n;if(a<o)return this.#Ct;e.add(r),s.delete(r),n=a}}#xt(t,e){const s=new Set;for(const e of t)for(const t of e)s.add(t);let i=1;for(const t of s){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&(e<i&&(i=e))}for(const t of this._pro.constraints()){t.lowestConsistencyDegree()<this.#wt&&e.add(t)}return i}#Vt(t,e,s,i){let n=1;const o=new Set;for(const s of t){const t=this._pro.constraintsBetween(s,e);for(const e of t)o.add(e)}for(const t of o){const e=t.satisfactionDegree();if(e!==Constraint.UNDEFINED&&(e<n&&(n=e),n<=s||n<=i))return n}return n}#yt(t,e,s,i,n,o){let r=1;const a=new Set;for(const e of t){const t=this._pro.constraintsBetween(e,s);for(const e of t)a.add(e)}for(const t of e){const e=this._pro.constraintsBetween(t,s);for(const t of e)a.add(t)}for(const t of a){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&(e<r&&(r=e))}for(const t of a){const e=t.satisfactionDegree();e!==Constraint.UNDEFINED&&((e<i||e<n)&&o.add(t))}return r}exec(){this.#g=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#f=0,this.#j=-1;const t=this._pro.worstSatisfactionDegree();0===this._pro.emptyVariableSize()&&this._pro.clearAllVariables();const e=new Set,s=new Set,i=new Set;for(const t of this._pro.variables())(t.isEmpty()?i:s).add(t);const n=new Set,o=this.#xt(s,n);let r,a=null;0===i.size?(r=o,a=AssignmentList.fromVariables(s)):r=this.#Ct;const l=FlexibleLocalChangesEx.#F(this.#St(s,n),i),h=FlexibleLocalChangesEx.#I(s,l);let c=this.#zt(e,h,l,this.#wt,this.#wt,r);return c<r&&null!==a&&a.apply(),c=this._pro.worstSatisfactionDegree(),c>t&&c>0&&(0!==this.#j||null===this._targetDeg)}}class SRS3 extends Solver{static REPAIR_THRESHOLD=0;#$=new Set;#G=new Set;#q=[];#Y=[];#Nt=new Set;#f;#g;#o=!0;constructor(t){super(t);for(const t of this._pro.constraints())this.#q.push(new CrispSRS3.TreeNode(t)),this.#Y.push(null)}name(){return"SRS 3"}foundSolution(t,e){return!1}#J(t){const e=t.index();return null===this.#Y[e]&&(this.#Y[e]=t.neighbors()),this.#Y[e]}#K(t){this._debug&&console.log("repair");const e=new AssignmentList,s=t.satisfactionDegree(),i=this._pro.worstSatisfactionDegree();let n=t.satisfactionDegree();for(const o of t){const r=o.value();t:for(const a of o.domain()){if(r===a)continue;o.assign(a);const l=t.satisfactionDegree();if(!(s>l||n-l>SRS3.REPAIR_THRESHOLD)){for(const e of o){if(e===t)continue;const s=e.satisfactionDegree();if(s!==Constraint.UNDEFINED&&s<i)continue t}l>n&&(n=l,e.clear()),e.addVariable(o,a)}}o.assign(r)}if(e.size()>0){const t=this.#o?e.arbitraryAssignment():e.get(0);return console.log(t),t.apply(),this._debug&&console.log("\t"+t),!0}return!1}#Q(t){this._debug&&console.log("shrink");let e=!1;for(;;){if(t=t.parent(),this.#Nt.delete(t)){e=!0;break}if(!this.#K(t.parent().getObject()))break}const s=[];t.getDescendants(s);for(const t of s)t.clear(),this.#G.delete(t),this.#$.delete(t);e||this.#G.add(t)}#Z(t){this._debug&&console.log("spread"),this.#$.add(t);for(const e of this.#J(t.getObject())){const s=this.#q[e.index()];this.#$.has(s)||this.#G.has(s)||(t.add(s),this.#G.add(s))}}#tt(){this._debug&&console.log("srs");const[t]=this._pro.constraintsWithWorstSatisfactionDegree();for(const e of t){const t=this.#q[e.index()];t.setParent(null),this.#Nt.add(t)}this.#$.clear(),this.#G.clear();for(const t of this.#Nt)this.#G.add(t);for(;this.#Nt.size&&this.#G.size;){if(this._iterLimit&&this._iterLimit<this.#f++)return this._debug&&console.log("stop: number of iterations has reached the limit"),!1;if(this.#g<Date.now())return this._debug&&console.log("stop: time limit has been reached"),!1;const t=this.#G.values().next().value;if(this.#G.delete(t),this.#K(t.getObject())){if(this.#Nt.delete(t))continue;if(this.#K(t.parent().getObject())){this.#Q(t);continue}}this.#Z(t)}return!0}exec(){if(this.#g=null===this._timeLimit?Number.MAX_VALUE:Date.now()+this._timeLimit,this.#f=0,this._targetDeg&&this._targetDeg<=this._pro.worstSatisfactionDegree())return!0;const t=new AssignmentList;let e=!1;for(;;){if(!this.#tt()||this.#Nt.size)break;const s=this._pro.worstSatisfactionDegree();if(this._debug&&console.log(`\tfound a solution: ${s}\t${this._targetDeg}`),t.setProblem(this._pro),this.foundSolution(t,s)){e=!0;break}if(null===this._targetDeg)e=!0;else if(this._targetDeg<=s){this._debug&&console.log("stop: current degree is above the target"),e=!0;break}}return e}setRandomness(t){this.#o=t}}{class t{#et=[];#st;#it;constructor(t){this.#it=t}add(t){t.#st=this,this.#et.push(t)}clear(){for(const t of this.#et)t.#st=null;this.#et.length=0}getDescendants(t){t.push(this);for(const e of this.#et)e.getDescendants(t)}getObject(){return this.#it}parent(){return this.#st}setParent(t){this.#st=t}}CrispSRS3.TreeNode=t}class SRS3_PF extends SRS3{constructor(t){super(t)}name(){return"SRS 3 + PF"}exec(){let t=0,e=0;this._debug&&(t=this._pro.worstSatisfactionDegree(),e=this._pro.emptyVariableSize());const s=new AssignmentList;s.setProblem(this._pro);const i=super.exec();return i&&PostStabilization.apply(this._pro,s),this._debug&&(console.log("result: "+(i?"success":"failure")),console.log(`satisfaction degree: ${t} -> ${this._pro.worstSatisfactionDegree()}`),console.log(`unassigned size: ${e} -> ${this._pro.emptyVariableSize()}`)),i}}class AC3{static#At(t,e){for(const s of e.domain())if(e.assign(s),1===t.isSatisfied())return!0;return!1}static#kt(t,e,s){const i=e.value(),n=s.value(),o=e.domain(),r=[],a=t.constraintsBetween(e,s);t:for(const t of o){e.assign(t);for(const t of a)if(2===t.size()&&!AC3.#At(t,s))continue t;r.push(t)}if(e.assign(i),s.assign(n),r.length!==o.size()){const s=t.createDomain({values:r});return e.setDomain(s),console.log(o.size()+" -> "+s.size()),!0}return!1}static apply(t){const e=[];for(const s of t.constraints())2===s.size()&&e.add(s);for(;!e.isEmpty();){const s=e.remove(e.size()-1),i=s.at(0),n=s.at(1);if(AC3.#kt(t,i,n))for(const s of t.constraints())2===s.size()&&s.at(1)===i&&s.at(0)!==n&&e.add(0,s)}}}class NodeConsistency{static apply(t,e){for(const s of t.variables()){const i=s.domain(),n=s.value(),o=[];for(const n of s)if(1===n.size()){for(const t of i)s.assign(t),n.satisfactionDegree()>=e&&o.push(t);t.removeConstraint(n)}if(s.assign(n),0===o.length)return!1;s.setDomain(t.createDomain({values:o}))}return!0}static apply(t){for(const e of t.variables()){const s=e.domain(),i=e.value(),n=[];for(const i of e)if(1===i.size()){for(const t of s)e.assign(t),1===i.isSatisfied()&&n.push(t);t.removeConstraint(i)}if(e.assign(i),0===n.length)return!1;e.setDomain(t.createDomain({values:n}))}return!0}}class PostStabilization{static apply(t,e){let s;console.log("start post-stabilization");let i=0;do{console.log("post-stabilization: count "+i++),s=!1;let n=t.worstSatisfactionDegree();for(let i=0;i<t.variableSize();++i){const o=t.variableAt(i),r=o.value(),a=e.get(i);r!==a.value()&&(a.apply(),t.worstSatisfactionDegree()>=n?s=!0:o.assign(r))}}while(s);return console.log("finish post-stabilization"),!0}}
//# sourceMappingURL=solver.min.js.map