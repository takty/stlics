class Problems{static#t(t,s,e,i,a){const r=[];for(const t of s)for(const s of t)e[s.index()]===Number.MAX_VALUE&&(r.push(s),e[s.index()]=i+1);for(const t of r)a.add(t);for(const s of r)Problems.#t(t,s,e,i+1,a)}static averagePathLength(t,s){const e=new Array(t.variableSize());e.fill(Number.MAX_VALUE);const i=new Set;i.add(s),e[s.index()]=0,Problems.#t(t,s,e,0,i);let a=0,r=0;for(let t=0;t<e.length;++t)e[t]!==Number.MAX_VALUE&&t!==s.index()&&(++a,r+=e[t]);return 0===a?0:r/a}static averagePathLengths(t){const s=new Array(t.variableSize());for(const e of t.variables())s[e.index()]=Problems.averagePathLength(t,e);return s}static domains(t){const s=[];for(const e of t.variables())s.push(e.domain());return s}static possibleSatisfactionDegreesOfUnaryConstraints(t,s){for(const e of t.constraints()){if(1!==e.size())continue;const t=e.at(0),i=t.value();for(const i of t.domain())t.assign(i),s.add(e.satisfactionDegree());t.assign(i)}return s}static setDomains(t,s){for(let e=0;e<s.length;++e)t.variableAt(e).setDomain(s[e])}static toViewAsCrispProblem(t,s){const e=new CrispFuzzyProblem;for(const s of t.variables())e.createVariable(s);for(c of t.constraints()){const t=[];for(const s of c)t.push(e.variableAt(s.index()));const i=c.crispRelation();c.isFuzzy()&&(i=new CrispFuzzyRelation(c.fuzzyRelation(),s)),e.createConstraint({relation:i,variables:t})}return e}}class CrispFuzzyProblem extends CrispProblem{createVariable(t){const s=new ImaginaryVariable(t);return this.addVariable(s),t}}class CrispFuzzyRelation extends CrispRelation{#s;#e;constructor(t,s){this.#e=t,this.#s=s}isSatisfied(...t){return this.#e.satisfactionDegree(t)>=this.#s}}class ImaginaryVariable extends Variable{#i;constructor(t){super(t.owner(),t.domain()),this.#i=t,setName(t.name()),assign(t.value())}assign(t){this.#i.assign(t)}domain(){return this.#i.domain()}setDomain(t){this.#i.setDomain(t)}value(){return this.#i.value()}}class ProblemFactory{createProblem(t){}isFuzzy(){}}class Assignment{#a;#r;constructor(t){t.assignment?(this.#a=t.assignment.variable(),this.#r=t.assignment.value()):t.variable&&(this.#a=t.variable,this.#r=t.value??t.variable.value())}apply(){this.#a.assign(this.#r)}toString(){return`v${this.#a.index()} <- ${this.#r}`}value(){return this.#r}variable(){return this.#a}}class AssignmentList{static fromVariables(t){const s=new AssignmentList;return s.setVariables(t),s}#n=[];constructor(){}setProblem(t){this.#n.length=0,this.addProblem(t)}setAssignmentList(t){this.#n.length=0;for(let s=0;s<t.size();++s)this.addAssignment(t.get(s))}setVariables(t){this.#n.length=0;for(const s of t)this.#n.push(new Assignment({variable:s,value:s.value()}))}addProblem(t){for(const s of t.variables())this.#n.push(new Assignment({variable:s,value:s.value()}))}addVariable(t,s=null){this.#n.push(new Assignment({variable:t,value:s}))}addAssignment(t){this.#n.push(new Assignment({variable:t.variable(),value:t.value()}))}apply(){for(const t of this.#n)t.apply()}arbitraryAssignment(){return this.#n[Math.floor(Math.random()*this.#n.length)]}differenceSize(){let t=0;for(const s of this.#n)s.variable().value()!==s.value()&&++t;return t}size(){return this.#n.length}clear(){this.#n.length=0}get(t){return this.#n[t]}add(t){this.#n.push(t)}isEmpty(){return 0===this.#n.length}}class LoopDetector{#o=[];#l=[];#h=null;#c=null;#u=null;constructor(t=30,s=3){this.#c=t,this.#u=s,this.#g()}#v(t,s){this.#o[this.#h]=t,this.#l[this.#h]=s,-1==--this.#h&&(this.#h=this.#o.length-1)}#b(){const t=new Array(this.#c),s=new Array(this.#c);t:for(let e=1;e<=this.#c;++e){let i=this.#h+1;for(let a=0;a<e;++a)a+i===this.#o.length&&(i-=this.#o.length),t[a]=this.#o[a+i],s[a]=this.#l[a+i];let a=e;for(let r=0;r<this.#u-1;++r){i=this.#h+1;for(let r=0;r<e;++r)if(a+r+i>=this.#o.length&&(i-=this.#o.length),this.#o[a+r+i]!==t[r]||this.#l[a+r+i]!==s[r])continue t;a+=e}return e}return 0}#g(){this.#o=new Array(this.#c*this.#u),this.#l=new Array(this.#c*this.#u),this.#o.fill(-1),this.#l.fill(-1),this.#h=this.#o.length-1}checkLoop(t,s){return this.#v(t,s),this.#b()}clear(){this.#o.fill(-1),this.#l.fill(-1)}iterationCount(){return this.#u}loopLength(){return this.#c}values(){return this.#l.clone()}variableIndices(){return this.#o.clone()}}
//# sourceMappingURL=util.min.js.map