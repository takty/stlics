class Problems{static#t(t,e,s,i,a){const r=[];for(let t=0;t<e.size();++t){const a=e.at(t);for(let t=0;t<a.size();++t){const e=a.at(t);s[e.index()]===Number.MAX_VALUE&&(r.push(e),s[e.index()]=i+1)}}for(const t of r)a.add(t);for(const e of r)Problems.#t(t,e,s,i+1,a)}static averagePathLength(t,e){const s=new Array(t.variableSize());s.fill(Number.MAX_VALUE);const i=new Set;i.add(e),s[e.index()]=0,Problems.#t(t,e,s,0,i);let a=0,r=0;for(let t=0;t<s.length;++t)s[t]!==Number.MAX_VALUE&&t!==e.index()&&(++a,r+=s[t]);return 0===a?0:r/a}static averagePathLengths(t){const e=new Array(t.variableSize());for(const s of t.variables())e[s.index()]=Problems.averagePathLength(t,s);return e}static domains(t){const e=[];for(const s of t.variables())e.push(s.domain());return e}static possibleSatisfactionDegreesOfUnaryConstraints(t,e){for(const s of t.constraints()){if(1!==s.size())continue;const t=s.at(0),i=t.value(),a=t.domain();for(let i=0;i<a.size();++i)t.assign(a.at(i)),e.add(s.satisfactionDegree());t.assign(i)}return e}static setDomains(t,e){for(let s=0;s<e.length;++s)t.variableAt(s).setDomain(e[s])}static toViewAsCrispProblem(t,e){const s=new CrispFuzzyProblem;for(const e of t.variables())s.createVariable(e);for(c of t.constraints()){const t=new Array(c.size());for(let e=0;e<t.length;++e)t[e]=s.variableAt(c.at(e).index());const i=c.crispRelation();c.isFuzzy()&&(i=new CrispFuzzyRelation(c.fuzzyRelation(),e)),s.createConstraint({relation:i,variables:t})}return s}}class CrispFuzzyProblem extends CrispProblem{createVariable(t){const e=new ImaginaryVariable(t);return this.addVariable(e),t}}class CrispFuzzyRelation extends CrispRelation{#e;#s;constructor(t,e){this.#s=t,this.#e=e}isSatisfied(...t){return this.#s.satisfactionDegree(t)>=this.#e}}class ImaginaryVariable extends Variable{#i;constructor(t){super(t.owner(),t.domain()),this.#i=t,setName(t.name()),assign(t.value())}assign(t){this.#i.assign(t)}domain(){return this.#i.domain()}setDomain(t){this.#i.setDomain(t)}value(){return this.#i.value()}}class ProblemFactory{createProblem(t){}isFuzzy(){}}class Assignment{#a;#r;constructor(t){t.assignment?(this.#a=t.assignment.variable(),this.#r=t.assignment.value()):t.variable&&(this.#a=t.variable,this.#r=t.value??t.variable.value())}apply(){this.#a.assign(this.#r)}toString(){return`v${this.#a.index()} <- ${this.#r}`}value(){return this.#r}variable(){return this.#a}}class AssignmentList{static fromVariables(t){const e=new AssignmentList;return e.setVariables(t),e}#n=[];constructor(){}setProblem(t){this.#n.length=0,this.addProblem(t)}setAssignmentList(t){this.#n.length=0;for(let e=0;e<t.size();++e)this.addAssignment(t.get(e))}setVariables(t){this.#n.length=0;for(const e of t)this.#n.push(new Assignment({variable:e,value:e.value()}))}addProblem(t){for(const e of t.variables())this.#n.push(new Assignment({variable:e,value:e.value()}))}addVariable(t,e=null){this.#n.push(new Assignment({variable:t,value:e}))}addAssignment(t){this.#n.push(new Assignment({variable:t.variable(),value:t.value()}))}apply(){for(const t of this.#n)t.apply()}arbitraryAssignment(){return this.#n[Math.floor(Math.random()*this.#n.length)]}differenceSize(){let t=0;for(const e of this.#n)e.variable().value()!==e.value()&&++t;return t}size(){return this.#n.length}clear(){this.#n.length=0}get(t){return this.#n[t]}add(t){this.#n.push(t)}isEmpty(){return 0===this.#n.length}}class LoopDetector{#l=[];#o=[];#h=null;#c=null;#u=null;constructor(t=30,e=3){this.#c=t,this.#u=e,this.#g()}#v(t,e){this.#l[this.#h]=t,this.#o[this.#h]=e,-1==--this.#h&&(this.#h=this.#l.length-1)}#b(){const t=new Array(this.#c),e=new Array(this.#c);t:for(let s=1;s<=this.#c;++s){let i=this.#h+1;for(let a=0;a<s;++a)a+i===this.#l.length&&(i-=this.#l.length),t[a]=this.#l[a+i],e[a]=this.#o[a+i];let a=s;for(let r=0;r<this.#u-1;++r){i=this.#h+1;for(let r=0;r<s;++r)if(a+r+i>=this.#l.length&&(i-=this.#l.length),this.#l[a+r+i]!==t[r]||this.#o[a+r+i]!==e[r])continue t;a+=s}return s}return 0}#g(){this.#l=new Array(this.#c*this.#u),this.#o=new Array(this.#c*this.#u),this.#l.fill(-1),this.#o.fill(-1),this.#h=this.#l.length-1}checkLoop(t,e){return this.#v(t,e),this.#b()}clear(){this.#l.fill(-1),this.#o.fill(-1)}iterationCount(){return this.#u}loopLength(){return this.#c}values(){return this.#o.clone()}variableIndices(){return this.#l.clone()}}
//# sourceMappingURL=util.min.js.map