class Element{#t=-1;#s="";userObject=null;solverObject=null;setIndex(t){this.#t=t}setName(t){this.#s=t}index(){return this.#t}name(){return this.#s}}class Relation{}class CrispRelation extends Relation{isSatisfied(...t){throw new Exception}asFuzzyRelation(){return new FuzzyRelationView(this)}}class CrispTabledRelation extends CrispRelation{#i;#e;#n;constructor(t,s){this.#i=[...t],this.#e=[...s],this.#n=new Array(s.length);let i=1;for(let t=this.#n.length-1;t>=0;--t)this.#n[t]=i,i*=s[t].size()}isSatisfied(...t){if(this.#n.length!==t.length)throw new Exception;let s=0;for(let i=0;i<this.#n.length;++i)s+=this.#n[i]*this.#e[i].indexOf(t[i]);return this.#i[s]}}class CrispRelationFunction extends CrispRelation{#r;constructor(t){super(),this.#r=t}isSatisfied(...t){return this.#r(...t)}}class FuzzyRelation extends Relation{satisfactionDegree(...t){throw new Exception}asCrispRelation(){return new CrispRelationView(this)}}class FuzzyTabledRelation extends FuzzyRelation{#i;#e;#n;constructor(t,s){this.#i=[...t],this.#e=[...s],this.#n=new Array(s.length);let i=1;for(let t=this.#n.length-1;t>=0;--t)this.#n[t]=i,i*=s[t].size()}satisfactionDegree(...t){if(this.#n.length!==t.length)throw new Exception;let s=0;for(let i=0;i<this.#n.length;++i)s+=this.#n[i]*this.#e[i].indexOf(t[i]);return this.#i[s]}}class FuzzyRelationFunction extends FuzzyRelation{#r;constructor(t){super(),this.#r=t}satisfactionDegree(...t){return this.#r(...t)}}class CrispRelationView extends CrispRelation{constructor(t){this.that=t}isSatisfied(...t){return 1===this.that.satisfactionDegree(t)}}class FuzzyRelationView extends FuzzyRelation{constructor(t){this.that=t}satisfactionDegree(...t){return this.that.isSatisfied(t)?1:0}}class Constraint extends Element{static UNDEFINED=-1;rel;constructor(t){super(),this.rel=t}crispRelation(){return this.rel}fuzzyRelation(){return this.rel}isFuzzy(){return this.rel instanceof FuzzyRelation}toString(){const t=this.satisfactionDegree();return`c${this.index()}${""===this.name()?"":`(${this.name()})`} = ${t===Constraint.UNDEFINED?"UNDEFINED":t}`}size(){}at(t){}constrains(t){}indexOf(t){}emptyVariableSize(){}isDefined(){}isSatisfied(){}satisfactionDegree(){}neighbors(t){}highestConsistencyDegree(){}lowestConsistencyDegree(){}}class Constraint1 extends Constraint{#a;constructor(t,s){super(t),this.#a=s}size(){return 1}at(t){if(0===t)return this.#a;throw new IndexOutOfBoundsException}constrains(t){return t===this.#a}indexOf(t){return t===this.#a?0:-1}emptyVariableSize(){return this.#a.isEmpty()?1:0}isDefined(){return!this.#a.isEmpty()}isSatisfied(){return this.#a.isEmpty()?Constraint.UNDEFINED:this.crispRelation().isSatisfied(this.#a.value())?1:0}satisfactionDegree(){return this.#a.isEmpty()?Constraint.UNDEFINED:this.fuzzyRelation().satisfactionDegree(this.#a.value())}neighbors(t){for(let s=0,i=this.#a.size();s<i;++s){const i=this.#a.at(s);i!==this&&t.push(i)}return t}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=0;const i=this.#a.domain();for(let t=0,e=i.size();t<e;++t){const e=this.fuzzyRelation().satisfactionDegree(i.at(t));if(e>s&&(s=e),1===s)break}return s}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=1;const i=this.#a.domain();for(let t=0,e=i.size();t<e;++t){const e=this.fuzzyRelation().satisfactionDegree(i.at(t));if(e<s&&(s=e),0===s)break}return s}}class Constraint2 extends Constraint{#o;#h;constructor(t,s,i){super(t),this.#o=s,this.#h=i}size(){return 2}at(t){if(0===t)return this.#o;if(1===t)return this.#h;throw new IndexOutOfBoundsException}constrains(t){return this.#o===t||this.#h===t}indexOf(t){return t===this.#o?0:t===this.#h?1:-1}emptyVariableSize(){let t=0;return this.#o.isEmpty()&&++t,this.#h.isEmpty()&&++t,t}isDefined(){return!this.#o.isEmpty()&&!this.#h.isEmpty()}isSatisfied(){return this.#o.isEmpty()||this.#h.isEmpty()?Constraint.UNDEFINED:this.crispRelation().isSatisfied(this.#o.value(),this.#h.value())?1:0}satisfactionDegree(){return this.#o.isEmpty()||this.#h.isEmpty()?Constraint.UNDEFINED:this.fuzzyRelation().satisfactionDegree(this.#o.value(),this.#h.value())}neighbors(t){for(let s=0,i=this.#o.size();s<i;++s){const i=this.#o.at(s);i!==this&&t.push(i)}for(let s=0,i=this.#h.size();s<i;++s){const i=this.#h.at(s);i!==this&&t.push(i)}return t}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=0;const i=this.#o.value(),e=this.#h.value(),n=this.#o.domain(),r=this.#h.domain(),a=n.size(),o=r.size();if(!this.#o.isEmpty()&&this.#h.isEmpty())for(let t=0;t<o;++t){const e=this.fuzzyRelation().satisfactionDegree(i,r.at(t));if(e>s&&(s=e),1===s)break}else if(this.#o.isEmpty()&&!this.#h.isEmpty())for(let t=0;t<a;++t){const i=this.fuzzyRelation().satisfactionDegree(n.at(t),e);if(i>s&&(s=i),1===s)break}else for(let t=0;t<a;++t)for(let i=0;i<o;++i){const e=this.fuzzyRelation().satisfactionDegree(n.at(t),r.at(i));if(e>s&&(s=e),1===s)break}return s}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=1;const i=this.#o.value(),e=this.#h.value(),n=this.#o.domain(),r=this.#h.domain(),a=n.size(),o=r.size();if(!this.#o.isEmpty()&&this.#h.isEmpty())for(let t=0;t<o;++t){const e=this.fuzzyRelation().satisfactionDegree(i,r.at(t));if(e<s&&(s=e),0===s)break}else if(this.#o.isEmpty()&&!this.#h.isEmpty())for(let t=0;t<a;++t){const i=this.fuzzyRelation().satisfactionDegree(n.at(t),e);if(i<s&&(s=i),0===s)break}else for(let t=0;t<a;++t)for(let i=0;i<o;++i){const e=this.fuzzyRelation().satisfactionDegree(n.at(t),r.at(i));if(e<s&&(s=e),0===s)break}return s}}class Constraint3 extends Constraint{#o;#h;#l;constructor(t,s,i,e){super(t),this.#o=s,this.#h=i,this.#l=e}size(){return 3}at(t){if(0===t)return this.#o;if(1===t)return this.#h;if(2===t)return this.#l;throw new IndexOutOfBoundsException}constrains(t){return this.#o===t||this.#h===t||this.#l===t}indexOf(t){return t===this.#o?0:t===this.#h?1:t===this.#l?2:-1}emptyVariableSize(){let t=0;return this.#o.isEmpty()&&++t,this.#h.isEmpty()&&++t,this.#l.isEmpty()&&++t,t}isDefined(){return!this.#o.isEmpty()&&!this.#h.isEmpty()&&!this.#l.isEmpty()}isSatisfied(){return this.#o.isEmpty()||this.#h.isEmpty()||this.#l.isEmpty()?-1:this.crispRelation().isSatisfied(this.#o.value(),this.#h.value(),this.#l.value())?1:0}satisfactionDegree(){return this.#o.isEmpty()||this.#h.isEmpty()||this.#l.isEmpty()?Constraint.UNDEFINED:this.fuzzyRelation().satisfactionDegree(this.#o.value(),this.#h.value(),this.#l.value())}neighbors(t){for(let s=0,i=this.#o.size();s<i;++s){const i=this.#o.at(s);i!==this&&t.push(i)}for(let s=0,i=this.#h.size();s<i;++s){const i=this.#h.at(s);i!==this&&t.push(i)}for(let s=0,i=this.#l.size();s<i;++s){const i=this.#l.at(s);i!==this&&t.push(i)}return t}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=1;const i=this.#o.value(),e=this.#h.value(),n=this.#l.value(),r=this.#o.domain(),a=this.#h.domain(),o=this.#l.domain(),h=r.size(),l=a.size(),f=o.size();if(!this.#o.isEmpty()||this.#h.isEmpty()||this.#l.isEmpty())if(this.#o.isEmpty()||!this.#h.isEmpty()||this.#l.isEmpty())if(this.#o.isEmpty()||this.#h.isEmpty()||!this.#l.isEmpty())if(this.#o.isEmpty()&&this.#h.isEmpty()&&!this.#l.isEmpty())for(let t=0;t<h;++t)for(let i=0;i<l;++i){const e=this.fuzzyRelation().satisfactionDegree(r.at(t),a.at(i),n);if(e>s&&(s=e),1===s)break}else if(this.#o.isEmpty()&&!this.#h.isEmpty()&&this.#l.isEmpty())for(let t=0;t<h;++t)for(let i=0;i<f;++i){const n=this.fuzzyRelation().satisfactionDegree(r.at(t),e,o.at(i));if(n>s&&(s=n),1===s)break}else if(!this.#o.isEmpty()&&this.#h.isEmpty()&&this.#l.isEmpty())for(let t=0;t<l;++t)for(let e=0;e<f;++e){const n=this.fuzzyRelation().satisfactionDegree(i,a.at(t),o.at(e));if(n>s&&(s=n),1===s)break}else for(let t=0;t<h;++t)for(let i=0;i<l;++i)for(let e=0;e<f;++e){const n=this.fuzzyRelation().satisfactionDegree(r.at(t),a.at(i),o.at(e));if(n>s&&(s=n),1===s)break}else for(let t=0;t<f;++t){const n=this.fuzzyRelation().satisfactionDegree(i,e,o.at(t));if(n>s&&(s=n),1===s)break}else for(let t=0;t<l;++t){const e=this.fuzzyRelation().satisfactionDegree(i,a.at(t),n);if(e>s&&(s=e),1===s)break}else for(let t=0;t<h;++t){const i=this.fuzzyRelation().satisfactionDegree(r.at(t),e,n);if(i>s&&(s=i),1===s)break}return s}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=1;const i=this.#o.value(),e=this.#h.value(),n=this.#l.value(),r=this.#o.domain(),a=this.#h.domain(),o=this.#l.domain(),h=r.size(),l=a.size(),f=o.size();if(!this.#o.isEmpty()||this.#h.isEmpty()||this.#l.isEmpty())if(this.#o.isEmpty()||!this.#h.isEmpty()||this.#l.isEmpty())if(this.#o.isEmpty()||this.#h.isEmpty()||!this.#l.isEmpty())if(this.#o.isEmpty()&&this.#h.isEmpty()&&!this.#l.isEmpty())for(let t=0;t<h;++t)for(let i=0;i<l;++i){const e=this.fuzzyRelation().satisfactionDegree(r.at(t),a.at(i),n);if(e<s&&(s=e),0===s)break}else if(this.#o.isEmpty()&&!this.#h.isEmpty()&&this.#l.isEmpty())for(let t=0;t<h;++t)for(let i=0;i<f;++i){const n=this.fuzzyRelation().satisfactionDegree(r.at(t),e,o.at(i));if(n<s&&(s=n),0===s)break}else if(!this.#o.isEmpty()&&this.#h.isEmpty()&&this.#l.isEmpty())for(let t=0;t<l;++t)for(let e=0;e<f;++e){const n=this.fuzzyRelation().satisfactionDegree(i,a.at(t),o.at(e));if(n<s&&(s=n),0===s)break}else for(let t=0;t<h;++t)for(let i=0;i<l;++i)for(let e=0;e<f;++e){const n=this.fuzzyRelation().satisfactionDegree(r.at(t),a.at(i),o.at(e));if(n<s&&(s=n),0===s)break}else for(let t=0;t<f;++t){const n=this.fuzzyRelation().satisfactionDegree(i,e,o.at(t));if(n<s&&(s=n),0===s)break}else for(let t=0;t<l;++t){const e=this.fuzzyRelation().satisfactionDegree(i,a.at(t),n);if(e<s&&(s=e),0===s)break}else for(let t=0;t<h;++t){const i=this.fuzzyRelation().satisfactionDegree(r.at(t),e,n);if(i<s&&(s=i),0===s)break}return s}}class ConstraintN extends Constraint{#f;#c;constructor(t,...s){super(t),this.#f=[...s],this.#c=new Array(this.#f.length)}size(){return this.#f.length}at(t){return this.#f[t]}constrains(t){return this.#f.includes(t)}indexOf(t){return this.#f.indexOf(t)}emptyVariableSize(){let t=0;for(const s of this.#f)s.isEmpty()&&++t;return t}isDefined(){for(const t of this.#f)if(t.isEmpty())return!1;return!0}isSatisfied(){for(let t=0;t<this.#f.length;++t){if(this.#f[t].isEmpty())return-1;this.#c[t]=this.#f[t].value()}return this.crispRelation().isSatisfied(...this.#c)?1:0}satisfactionDegree(){for(let t=0;t<this.#f.length;++t){const s=this.#f[t];if(s.isEmpty())return Constraint.UNDEFINED;this.#c[t]=s.value()}return this.fuzzyRelation().satisfactionDegree(...this.#c)}neighbors(t){t.length=0;for(const s of this.#f)for(let i=0,e=s.size();i<e;++i){const e=s.at(i);e!==this&&t.push(e)}return t}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;const s=new Array(this.emptyVariableSize());let i=0;for(let t=0;t<this.#f.length;++t)this.#f[t].isEmpty()?s[i++]=t:this.#c[t]=this.#f[t].value();return this.checkHCD(s,0,0)}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;const s=new Array(this.emptyVariableSize());let i=0;for(let t=0;t<this.#f.length;++t)this.#f[t].isEmpty()?s[i++]=t:this.#c[t]=this.#f[t].value();return this.checkLCD(s,0,1)}checkHCD(t,s,i){const e=t[s],n=this.#f[e].domain();if(s===t.length-1)for(let t=0,s=n.size();t<s;++t){this.#c[e]=n.at(t);const s=this.fuzzyRelation().satisfactionDegree(this.#c);if(s>i&&(i=s),1===i)break}else for(let r=0,a=n.size();r<a;++r)this.#c[e]=n.at(r),i=this.checkLCD(t,s+1,i);return i}checkLCD(t,s,i){const e=t[s],n=this.#f[e].domain();if(s===t.length-1)for(let t=0,s=n.size();t<s;++t){this.#c[e]=n.at(t);const s=this.fuzzyRelation().satisfactionDegree(this.#c);if(s<i&&(i=s),0===i)break}else for(let r=0,a=n.size();r<a;++r)this.#c[e]=n.at(r),i=this.checkLCD(t,s+1,i);return i}}class Domain{contains(t){}indexOf(t){}size(){}at(t){}random(){}}class DomainArbitrary extends Domain{#c;constructor(t){super(),this.#c=[...t]}contains(t){return this.#c.includes(t)}indexOf(t){return this.#c.indexOf(t)}size(){return this.#c.length}at(t){return this.#c[t]}random(){return this.#c[Math.floor(Math.random()*this.#c.length)]}}class DomainRanged extends Domain{#u;#v;constructor(t,s){super(),this.#u=t,this.#v=s}contains(t){return this.#u<=t&&t<=this.#v}indexOf(t){return this.#u<=t&&t<=this.#v?t-this.#u:-1}size(){return this.#v-this.#u+1}at(t){return this.#u+t}random(){return Math.floor(Math.random()*(this.#v-this.#u+1)+this.#u)}}class Variable extends Element{static#m=Number.MIN_VALUE;#y;#z=[];#p;#E=Variable.#m;constructor(t,s){super(),this.#y=t,this.#p=s}connect(t){if(this.isConstrainedBy(t))throw new IllegalArgumentException;this.#z.push(t)}deconnect(t){if(!this.isConstrainedBy(t))throw new IllegalArgumentException;this.#z=this.#z.filter((s=>s!==t))}assign(t){this.#E=t}clear(){this.assign(Variable.#m)}isEmpty(){return this.value()===Variable.#m}setDomain(t){this.#p=t,this.clear()}owner(){return this.#y}size(){return this.#z.length}at(t){return this.#z[t]}constraints(){return[...this.#z]}domain(){return this.#p}isConstrainedBy(t){return this.#z.includes(t)}toString(){return`x${this.index()}${""===this.name()?"":`(${this.name()})`} = ${this.isEmpty()?"<empty>":this.value()}`}value(){return this.#E}neighbors(){const t=[];for(const s of this.#z)for(let i=0,e=s.size();i<e;i+=1){const e=s.at(i);e!==this&&t.push(e)}return t}}class Problem{_isFuzzy=!1;_vars=[];_cons=[];addVariable(t){t.setIndex(this._vars.length),this._vars.push(t)}createDomain(t){return t.values?new DomainArbitrary(t.values):"min"in t&&"max"in t?new DomainRanged(t.min,t.max):null}createVariable(t){if(t.value&&!t.domain.contains(t.value))throw new Error;const s=new Variable(this,t.domain);return this.addVariable(s),t.name&&s.setName(t.name),t.value&&s.assign(t.value),s}createConstraint(t){for(const s of t.variables)if(s.owner()!==this)return null;let s;s=1===t.variables.length?new Constraint1(t.relation,...t.variables):2===t.variables.length?new Constraint2(t.relation,...t.variables):3===t.variables.length?new Constraint3(t.relation,...t.variables):new ConstraintN(t.relation,t.variables),s.setIndex(this._cons.length),this._cons.push(s);for(const i of t.variables)i.connect(s);return s.isFuzzy()&&(this._isFuzzy=!0),t.name&&s.setName(t.name),s}removeConstraint(t){const s=this._cons.indexOf(t);this._cons.remove(t);for(let t=s;t<this._cons.length;++t)this._cons[t].setIndex(t);for(let s=0;s<t.size();++s)t.at(s).deconnect(t);this._isFuzzy=!1;for(let t=0,s=this._cons.length;t<s;++t)if(this._cons[t].isFuzzy()){this._isFuzzy=!0;break}}clearAllVariables(){for(const t of this._vars)t.clear()}reverseVariables(){this._vars.reverse();for(let t=0,s=this._vars.length;t<s;++t)this._vars[t].setIndex(t)}sortVariables(t){this._vars.sort(t);for(let t=0,s=this._vars.length;t<s;++t)this._vars[t].setIndex(t)}variableSize(){return this._vars.length}variableAt(t){return this._vars[t]}variableOf(t){for(const s of this._vars)if(s.name()===t)return s;return null}hasVariable(t){return this._vars.includes(t)}variables(){return this._vars}constraintSize(){return this._cons.length}constraintAt(t){return this._cons[t]}constraintOf(t){for(const s of this._cons)if(s.name()===t)return s;return null}hasConstraint(t){return this._cons.includes(t)}constraints(){return this._cons}constraintsBetween(t,s,i){i.length=0;for(let e=0,n=t.size();e<n;++e){const n=t.at(e);n.constrains(s)&&i.push(n)}}constraintsWithWorstSatisfactionDegree(t){t.length=0;let s=1;for(const i of this._cons){const e=i.satisfactionDegree();e<s?(s=e,t.length=0,t.push(i)):e-s<10*Number.MIN_VALUE&&t.push(i)}return s}worstSatisfactionDegree(){let t=1;for(const s of this._cons){const i=s.satisfactionDegree();if(i===Constraint.UNDEFINED)return Constraint.UNDEFINED;i<t&&(t=i)}return t}averageSatisfactionDegree(){let t=0;for(const s of this._cons)t+=s.satisfactionDegree();return t/=this._cons.length,t}emptyVariableSize(){let t=0;for(const s of this._vars)s.isEmpty()&&t++;return t}constraintDensity(){return this.constraintSize()/this.variableSize()}hasEmptyDomain(){for(const t of this._vars)if(0===t.domain().size())return!0;return!1}isFuzzy(){return this._isFuzzy}}class CrispProblem extends Problem{createConstraint(t){if(t.relation instanceof FuzzyRelation)throw new Error;return super.createConstraint(t)}isFuzzy(){return!1}satisfiedConstraintRate(){return this.satisfiedConstraintSize()/this._cons.length}satisfiedConstraintSize(){let t=0;for(let s=0;s<this._cons.length;++s)1===this._cons[s].isSatisfied()&&++t;return t}violatingConstraints(t){t.length=0;for(const s of this._cons)0===s.isSatisfied()&&t.push(s);return t}violatingConstraintSize(){let t=0;for(const s of this._cons)0===s.isSatisfied()&&++t;return t}}
//# sourceMappingURL=problem.min.js.map