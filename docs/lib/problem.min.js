class Element{#t=-1;#s="";userObject=null;solverObject=null;setIndex(t){this.#t=t}setName(t){this.#s=t}index(){return this.#t}name(){return this.#s}}class Relation{}class CrispRelation extends Relation{isSatisfied(...t){throw new Exception}asFuzzyRelation(){return new FuzzyRelationView(this)}}class CrispTabledRelation extends CrispRelation{#i;#e;#n;constructor(t,s){this.#i=[...t],this.#e=[...s],this.#n=new Array(s.length);let i=1;for(let t=this.#n.length-1;t>=0;--t)this.#n[t]=i,i*=s[t].size()}isSatisfied(...t){if(this.#n.length!==t.length)throw new Exception;let s=0;for(let i=0;i<this.#n.length;++i)s+=this.#n[i]*this.#e[i].indexOf(t[i]);return this.#i[s]}}class CrispRelationFunction extends CrispRelation{#r;constructor(t){super(),this.#r=t}isSatisfied(...t){return this.#r(...t)}}class FuzzyRelation extends Relation{satisfactionDegree(...t){throw new Exception}asCrispRelation(){return new CrispRelationView(this)}}class FuzzyTabledRelation extends FuzzyRelation{#i;#e;#n;constructor(t,s){this.#i=[...t],this.#e=[...s],this.#n=new Array(s.length);let i=1;for(let t=this.#n.length-1;t>=0;--t)this.#n[t]=i,i*=s[t].size()}satisfactionDegree(...t){if(this.#n.length!==t.length)throw new Exception;let s=0;for(let i=0;i<this.#n.length;++i)s+=this.#n[i]*this.#e[i].indexOf(t[i]);return this.#i[s]}}class FuzzyRelationFunction extends FuzzyRelation{#r;constructor(t){super(),this.#r=t}satisfactionDegree(...t){return this.#r(...t)}}class CrispRelationView extends CrispRelation{constructor(t){this.that=t}isSatisfied(...t){return 1===this.that.satisfactionDegree(t)}}class FuzzyRelationView extends FuzzyRelation{constructor(t){this.that=t}satisfactionDegree(...t){return this.that.isSatisfied(t)?1:0}}class Constraint extends Element{static UNDEFINED=-1;rel;constructor(t){super(),this.rel=t}crispRelation(){return this.rel}fuzzyRelation(){return this.rel}isFuzzy(){return this.rel instanceof FuzzyRelation}toString(){const t=this.satisfactionDegree();return`c${this.index()}${""===this.name()?"":`(${this.name()})`} = ${t===Constraint.UNDEFINED?"UNDEFINED":t}`}size(){}at(t){}constrains(t){}indexOf(t){}emptyVariableSize(){}isDefined(){}isSatisfied(){}satisfactionDegree(){}neighbors(){}highestConsistencyDegree(){}lowestConsistencyDegree(){}}class Constraint1 extends Constraint{#o;constructor(t,s){super(t),this.#o=s}size(){return 1}at(t){if(0===t)return this.#o;throw new IndexOutOfBoundsException}constrains(t){return t===this.#o}indexOf(t){return t===this.#o?0:-1}emptyVariableSize(){return this.#o.isEmpty()?1:0}isDefined(){return!this.#o.isEmpty()}isSatisfied(){return this.#o.isEmpty()?Constraint.UNDEFINED:this.crispRelation().isSatisfied(this.#o.value())?1:0}satisfactionDegree(){return this.#o.isEmpty()?Constraint.UNDEFINED:this.fuzzyRelation().satisfactionDegree(this.#o.value())}neighbors(){const t=[];for(let s=0,i=this.#o.size();s<i;++s){const i=this.#o.at(s);i!==this&&t.push(i)}return t}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=0;for(const t of this.#o.domain()){const i=this.fuzzyRelation().satisfactionDegree(t);if(i>s&&(s=i),1===s)break}return s}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=1;for(const t of this.#o.domain()){const i=this.fuzzyRelation().satisfactionDegree(t);if(i<s&&(s=i),0===s)break}return s}}class Constraint2 extends Constraint{#a;#h;constructor(t,s,i){super(t),this.#a=s,this.#h=i}size(){return 2}at(t){if(0===t)return this.#a;if(1===t)return this.#h;throw new IndexOutOfBoundsException}constrains(t){return this.#a===t||this.#h===t}indexOf(t){return t===this.#a?0:t===this.#h?1:-1}emptyVariableSize(){let t=0;return this.#a.isEmpty()&&++t,this.#h.isEmpty()&&++t,t}isDefined(){return!this.#a.isEmpty()&&!this.#h.isEmpty()}isSatisfied(){return this.#a.isEmpty()||this.#h.isEmpty()?Constraint.UNDEFINED:this.crispRelation().isSatisfied(this.#a.value(),this.#h.value())?1:0}satisfactionDegree(){return this.#a.isEmpty()||this.#h.isEmpty()?Constraint.UNDEFINED:this.fuzzyRelation().satisfactionDegree(this.#a.value(),this.#h.value())}neighbors(){const t=[];for(let s=0,i=this.#a.size();s<i;++s){const i=this.#a.at(s);i!==this&&t.push(i)}for(let s=0,i=this.#h.size();s<i;++s){const i=this.#h.at(s);i!==this&&t.push(i)}return t}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=0;const i=this.#a.value(),e=this.#h.value(),n=this.#a.domain(),r=this.#h.domain();if(this.#a.isEmpty()&&!this.#h.isEmpty())for(const t of n){const i=this.fuzzyRelation().satisfactionDegree(t,e);if(i>s&&(s=i),1===s)break}else if(!this.#a.isEmpty()&&this.#h.isEmpty())for(const t of r){const e=this.fuzzyRelation().satisfactionDegree(i,t);if(e>s&&(s=e),1===s)break}else for(const t of n)for(const i of r){const e=this.fuzzyRelation().satisfactionDegree(t,i);if(e>s&&(s=e),1===s)break}return s}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=1;const i=this.#a.value(),e=this.#h.value(),n=this.#a.domain(),r=this.#h.domain();if(this.#a.isEmpty()&&!this.#h.isEmpty())for(const t of n){const i=this.fuzzyRelation().satisfactionDegree(t,e);if(i<s&&(s=i),0===s)break}else if(!this.#a.isEmpty()&&this.#h.isEmpty())for(const t of r){const e=this.fuzzyRelation().satisfactionDegree(i,t);if(e<s&&(s=e),0===s)break}else for(const t of n)for(const i of r){const e=this.fuzzyRelation().satisfactionDegree(t,i);if(e<s&&(s=e),0===s)break}return s}}class Constraint3 extends Constraint{#a;#h;#l;constructor(t,s,i,e){super(t),this.#a=s,this.#h=i,this.#l=e}size(){return 3}at(t){if(0===t)return this.#a;if(1===t)return this.#h;if(2===t)return this.#l;throw new IndexOutOfBoundsException}constrains(t){return this.#a===t||this.#h===t||this.#l===t}indexOf(t){return t===this.#a?0:t===this.#h?1:t===this.#l?2:-1}emptyVariableSize(){let t=0;return this.#a.isEmpty()&&++t,this.#h.isEmpty()&&++t,this.#l.isEmpty()&&++t,t}isDefined(){return!this.#a.isEmpty()&&!this.#h.isEmpty()&&!this.#l.isEmpty()}isSatisfied(){return this.#a.isEmpty()||this.#h.isEmpty()||this.#l.isEmpty()?-1:this.crispRelation().isSatisfied(this.#a.value(),this.#h.value(),this.#l.value())?1:0}satisfactionDegree(){return this.#a.isEmpty()||this.#h.isEmpty()||this.#l.isEmpty()?Constraint.UNDEFINED:this.fuzzyRelation().satisfactionDegree(this.#a.value(),this.#h.value(),this.#l.value())}neighbors(){const t=[];for(let s=0,i=this.#a.size();s<i;++s){const i=this.#a.at(s);i!==this&&t.push(i)}for(let s=0,i=this.#h.size();s<i;++s){const i=this.#h.at(s);i!==this&&t.push(i)}for(let s=0,i=this.#l.size();s<i;++s){const i=this.#l.at(s);i!==this&&t.push(i)}return t}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=1;const i=this.#a.value(),e=this.#h.value(),n=this.#l.value(),r=this.#a.domain(),o=this.#h.domain(),a=this.#l.domain();if(!this.#a.isEmpty()||this.#h.isEmpty()||this.#l.isEmpty())if(this.#a.isEmpty()||!this.#h.isEmpty()||this.#l.isEmpty())if(this.#a.isEmpty()||this.#h.isEmpty()||!this.#l.isEmpty())if(this.#a.isEmpty()&&this.#h.isEmpty()&&!this.#l.isEmpty())for(const t of r)for(const i of o){const e=this.fuzzyRelation().satisfactionDegree(t,i,n);if(e>s&&(s=e),1===s)break}else if(this.#a.isEmpty()&&!this.#h.isEmpty()&&this.#l.isEmpty())for(const t of r)for(const i of a){const n=this.fuzzyRelation().satisfactionDegree(t,e,i);if(n>s&&(s=n),1===s)break}else if(!this.#a.isEmpty()&&this.#h.isEmpty()&&this.#l.isEmpty())for(const t of o)for(const e of a){const n=this.fuzzyRelation().satisfactionDegree(i,t,e);if(n>s&&(s=n),1===s)break}else for(const t of r)for(const i of o)for(const e of a){const n=this.fuzzyRelation().satisfactionDegree(t,i,e);if(n>s&&(s=n),1===s)break}else for(const t of a){const n=this.fuzzyRelation().satisfactionDegree(i,e,t);if(n>s&&(s=n),1===s)break}else for(const t of o){const e=this.fuzzyRelation().satisfactionDegree(i,t,n);if(e>s&&(s=e),1===s)break}else for(const t of r){const i=this.fuzzyRelation().satisfactionDegree(t,e,n);if(i>s&&(s=i),1===s)break}return s}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;let s=1;const i=this.#a.value(),e=this.#h.value(),n=this.#l.value(),r=this.#a.domain(),o=this.#h.domain(),a=this.#l.domain();if(!this.#a.isEmpty()||this.#h.isEmpty()||this.#l.isEmpty())if(this.#a.isEmpty()||!this.#h.isEmpty()||this.#l.isEmpty())if(this.#a.isEmpty()||this.#h.isEmpty()||!this.#l.isEmpty())if(this.#a.isEmpty()&&this.#h.isEmpty()&&!this.#l.isEmpty())for(const t of r)for(const i of o){const e=this.fuzzyRelation().satisfactionDegree(t,i,n);if(e<s&&(s=e),0===s)break}else if(this.#a.isEmpty()&&!this.#h.isEmpty()&&this.#l.isEmpty())for(const t of r)for(const i of a){const n=this.fuzzyRelation().satisfactionDegree(t,e,i);if(n<s&&(s=n),0===s)break}else if(!this.#a.isEmpty()&&this.#h.isEmpty()&&this.#l.isEmpty())for(const t of o)for(const e of a){const n=this.fuzzyRelation().satisfactionDegree(i,t,e);if(n<s&&(s=n),0===s)break}else for(const t of r)for(const i of o)for(const e of a){const n=this.fuzzyRelation().satisfactionDegree(t,i,e);if(n<s&&(s=n),0===s)break}else for(const t of a){const n=this.fuzzyRelation().satisfactionDegree(i,e,t);if(n<s&&(s=n),0===s)break}else for(const t of o){const e=this.fuzzyRelation().satisfactionDegree(i,t,n);if(e<s&&(s=e),0===s)break}else for(const t of r){const i=this.fuzzyRelation().satisfactionDegree(t,e,n);if(i<s&&(s=i),0===s)break}return s}}class ConstraintN extends Constraint{#c;#f;constructor(t,...s){super(t),this.#c=[...s],this.#f=new Array(this.#c.length)}size(){return this.#c.length}at(t){return this.#c[t]}constrains(t){return this.#c.includes(t)}indexOf(t){return this.#c.indexOf(t)}emptyVariableSize(){let t=0;for(const s of this.#c)s.isEmpty()&&++t;return t}isDefined(){for(const t of this.#c)if(t.isEmpty())return!1;return!0}isSatisfied(){for(let t=0;t<this.#c.length;++t){if(this.#c[t].isEmpty())return-1;this.#f[t]=this.#c[t].value()}return this.crispRelation().isSatisfied(...this.#f)?1:0}satisfactionDegree(){for(let t=0;t<this.#c.length;++t){const s=this.#c[t];if(s.isEmpty())return Constraint.UNDEFINED;this.#f[t]=s.value()}return this.fuzzyRelation().satisfactionDegree(...this.#f)}neighbors(){const t=[];for(const s of this.#c)for(let i=0,e=s.size();i<e;++i){const e=s.at(i);e!==this&&t.push(e)}return t}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;const s=new Array(this.emptyVariableSize());let i=0;for(let t=0;t<this.#c.length;++t)this.#c[t].isEmpty()?s[i++]=t:this.#f[t]=this.#c[t].value();return this.checkHCD(s,0,0)}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==Constraint.UNDEFINED)return t;const s=new Array(this.emptyVariableSize());let i=0;for(let t=0;t<this.#c.length;++t)this.#c[t].isEmpty()?s[i++]=t:this.#f[t]=this.#c[t].value();return this.checkLCD(s,0,1)}checkHCD(t,s,i){const e=t[s],n=this.#c[e].domain();if(s===t.length-1)for(const t of n){this.#f[e]=t;const s=this.fuzzyRelation().satisfactionDegree(this.#f);if(s>i&&(i=s),1===i)break}else for(const r of n)this.#f[e]=r,i=this.checkLCD(t,s+1,i);return i}checkLCD(t,s,i){const e=t[s],n=this.#c[e].domain();if(s===t.length-1)for(const t of n){this.#f[e]=t;const s=this.fuzzyRelation().satisfactionDegree(this.#f);if(s<i&&(i=s),0===i)break}else for(const r of n)this.#f[e]=r,i=this.checkLCD(t,s+1,i);return i}}class Domain{contains(t){}indexOf(t){}size(){}at(t){}[Symbol.iterator](){}random(){return this.at(Math.floor(Math.random()*this.size()))}}class DomainArbitrary extends Domain{#f;constructor(t){super(),this.#f=[...t]}contains(t){return this.#f.includes(t)}indexOf(t){return this.#f.indexOf(t)}size(){return this.#f.length}at(t){return this.#f[t]}[Symbol.iterator](){return this.#f[Symbol.iterator]()}}class DomainRanged extends Domain{#u;#v;constructor(t,s){super(),this.#u=0|t,this.#v=0|s}contains(t){return this.#u<=t&&t<=this.#v}indexOf(t){return this.#u<=t&&t<=this.#v?t-this.#u:-1}size(){return this.#v-this.#u+1}at(t){return this.#u+t}[Symbol.iterator](){let t=this.#u;return{next:()=>t<=this.#v?{value:t++,done:!1}:{done:!0}}}}class Variable extends Element{static#m=Number.MIN_VALUE;#y;#z=[];#p;#E=Variable.#m;constructor(t,s){super(),this.#y=t,this.#p=s}connect(t){if(this.isConstrainedBy(t))throw new IllegalArgumentException;this.#z.push(t)}deconnect(t){if(!this.isConstrainedBy(t))throw new IllegalArgumentException;this.#z=this.#z.filter((s=>s!==t))}assign(t){this.#E=t}clear(){this.assign(Variable.#m)}isEmpty(){return this.value()===Variable.#m}setDomain(t){this.#p=t,this.clear()}owner(){return this.#y}size(){return this.#z.length}at(t){return this.#z[t]}constraints(){return[...this.#z]}domain(){return this.#p}isConstrainedBy(t){return this.#z.includes(t)}toString(){return`x${this.index()}${""===this.name()?"":`(${this.name()})`} = ${this.isEmpty()?"<empty>":this.value()}`}value(){return this.#E}neighbors(){const t=[];for(const s of this.#z)for(let i=0,e=s.size();i<e;i+=1){const e=s.at(i);e!==this&&t.push(e)}return t}}class Problem{_isFuzzy=!1;_vars=[];_cons=[];addVariable(t){t.setIndex(this._vars.length),this._vars.push(t)}createDomain(t){return t.values?new DomainArbitrary(t.values):"min"in t&&"max"in t?new DomainRanged(t.min,t.max):null}createVariable(t){if(t.value&&!t.domain.contains(t.value))throw new Error;const s=new Variable(this,t.domain);return this.addVariable(s),t.name&&s.setName(t.name),t.value&&s.assign(t.value),s}createConstraint(t){for(const s of t.variables)if(s.owner()!==this)return null;let s;s=1===t.variables.length?new Constraint1(t.relation,...t.variables):2===t.variables.length?new Constraint2(t.relation,...t.variables):3===t.variables.length?new Constraint3(t.relation,...t.variables):new ConstraintN(t.relation,t.variables),s.setIndex(this._cons.length),this._cons.push(s);for(const i of t.variables)i.connect(s);return s.isFuzzy()&&(this._isFuzzy=!0),t.name&&s.setName(t.name),s}removeConstraint(t){const s=this._cons.indexOf(t);this._cons.remove(t);for(let t=s;t<this._cons.length;++t)this._cons[t].setIndex(t);for(let s=0;s<t.size();++s)t.at(s).deconnect(t);this._isFuzzy=!1;for(let t=0,s=this._cons.length;t<s;++t)if(this._cons[t].isFuzzy()){this._isFuzzy=!0;break}}clearAllVariables(){for(const t of this._vars)t.clear()}reverseVariables(){this._vars.reverse();for(let t=0,s=this._vars.length;t<s;++t)this._vars[t].setIndex(t)}sortVariables(t){this._vars.sort(t);for(let t=0,s=this._vars.length;t<s;++t)this._vars[t].setIndex(t)}variableSize(){return this._vars.length}variableAt(t){return this._vars[t]}variableOf(t){for(const s of this._vars)if(s.name()===t)return s;return null}hasVariable(t){return this._vars.includes(t)}variables(){return this._vars}constraintSize(){return this._cons.length}constraintAt(t){return this._cons[t]}constraintOf(t){for(const s of this._cons)if(s.name()===t)return s;return null}hasConstraint(t){return this._cons.includes(t)}constraints(){return this._cons}constraintsBetween(t,s){const i=[];for(let e=0,n=t.size();e<n;++e){const n=t.at(e);n.constrains(s)&&i.push(n)}}constraintsWithWorstSatisfactionDegree(){const t=[];let s=1;for(const i of this._cons){const e=i.satisfactionDegree();e<s?(s=e,t.length=0,t.push(i)):e-s<10*Number.MIN_VALUE&&t.push(i)}return[t,s]}worstSatisfactionDegree(){let t=1;for(const s of this._cons){const i=s.satisfactionDegree();if(i===Constraint.UNDEFINED)return Constraint.UNDEFINED;i<t&&(t=i)}return t}averageSatisfactionDegree(){let t=0;for(const s of this._cons)t+=s.satisfactionDegree();return t/=this._cons.length,t}emptyVariableSize(){let t=0;for(const s of this._vars)s.isEmpty()&&t++;return t}constraintDensity(){return this.constraintSize()/this.variableSize()}hasEmptyDomain(){for(const t of this._vars)if(0===t.domain().size())return!0;return!1}isFuzzy(){return this._isFuzzy}}class CrispProblem extends Problem{createConstraint(t){if(t.relation instanceof FuzzyRelation)throw new Error;return super.createConstraint(t)}isFuzzy(){return!1}satisfiedConstraintRate(){return this.satisfiedConstraintSize()/this._cons.length}satisfiedConstraintSize(){let t=0;for(let s=0;s<this._cons.length;++s)1===this._cons[s].isSatisfied()&&++t;return t}violatingConstraints(){const t=[];for(const s of this._cons)0===s.isSatisfied()&&t.push(s);return t}violatingConstraintSize(){let t=0;for(const s of this._cons)0===s.isSatisfied()&&++t;return t}}
//# sourceMappingURL=problem.min.js.map