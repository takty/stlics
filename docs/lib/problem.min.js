class Element{#s=-1;#t="";userObject=null;solverObject=null;setIndex(s){this.#s=s}setName(s){this.#t=s}index(){return this.#s}name(){return this.#t}}class Relation{}class CrispRelation extends Relation{isSatisfied(...s){throw new Exception}asFuzzyRelation(){return new FuzzyRelationView(this)}}class CrispTabledRelation extends CrispRelation{#i;#e;#r;constructor(s,t){this.#i=[...s],this.#e=[...t],this.#r=new Array(t.length);let i=1;for(let s=this.#r.length-1;s>=0;--s)this.#r[s]=i,i*=t[s].size()}isSatisfied(...s){if(this.#r.length!==s.length)throw new Exception;let t=0;for(let i=0;i<this.#r.length;++i)t+=this.#r[i]*this.#e[i].indexOf(s[i]);return this.#i[t]}}class CrispRelationFunction extends CrispRelation{#n;constructor(s){super(),this.#n=s}isSatisfied(...s){return this.#n(...s)}}class FuzzyRelation extends Relation{satisfactionDegree(...s){throw new Exception}asCrispRelation(){return new CrispRelationView(this)}}class FuzzyTabledRelation extends FuzzyRelation{#i;#e;#r;constructor(s,t){this.#i=[...s],this.#e=[...t],this.#r=new Array(t.length);let i=1;for(let s=this.#r.length-1;s>=0;--s)this.#r[s]=i,i*=t[s].size()}satisfactionDegree(...s){if(this.#r.length!==s.length)throw new Exception;let t=0;for(let i=0;i<this.#r.length;++i)t+=this.#r[i]*this.#e[i].indexOf(s[i]);return this.#i[t]}}class FuzzyRelationFunction extends FuzzyRelation{#n;constructor(s){super(),this.#n=s}satisfactionDegree(...s){return this.#n(...s)}}class CrispRelationView extends CrispRelation{constructor(s){this.that=s}isSatisfied(...s){return 1===this.that.satisfactionDegree(s)}}class FuzzyRelationView extends FuzzyRelation{constructor(s){this.that=s}satisfactionDegree(...s){return this.that.isSatisfied(s)?1:0}}class Constraint extends Element{static UNDEFINED=-1;rel;constructor(s){super(),this.rel=s}crispRelation(){return this.rel}fuzzyRelation(){return this.rel}isFuzzy(){return this.rel instanceof FuzzyRelation}toString(){const s=this.satisfactionDegree();return`c${this.index()}${""===this.name()?"":`(${this.name()})`} = ${s===Constraint.UNDEFINED?"UNDEFINED":s}`}size(){}at(s){}[Symbol.iterator](){}has(s){}indexOf(s){}emptyVariableSize(){}isDefined(){}isSatisfied(){}satisfactionDegree(){}neighbors(){}highestConsistencyDegree(){}lowestConsistencyDegree(){}}class Constraint1 extends Constraint{#a=[null];constructor(s,t){super(s),this.#a[0]=t}size(){return 1}at(s){if(0===s)return this.#a[0];throw new IndexOutOfBoundsException}[Symbol.iterator](){return this.#a[Symbol.iterator]()}has(s){return s===this.#a[0]}indexOf(s){return s===this.#a[0]?0:-1}emptyVariableSize(){return this.#a[0].isEmpty()?1:0}isDefined(){return!this.#a[0].isEmpty()}isSatisfied(){return this.#a[0].isEmpty()?Constraint.UNDEFINED:this.crispRelation().isSatisfied(this.#a[0].value())?1:0}satisfactionDegree(){return this.#a[0].isEmpty()?Constraint.UNDEFINED:this.fuzzyRelation().satisfactionDegree(this.#a[0].value())}neighbors(){const s=[];for(const t of this.#a[0])t!==this&&s.push(t);return s}highestConsistencyDegree(){const s=this.satisfactionDegree();if(s!==Constraint.UNDEFINED)return s;let t=0;for(const s of this.#a[0].domain()){const i=this.fuzzyRelation().satisfactionDegree(s);if(i>t&&(t=i),1===t)break}return t}lowestConsistencyDegree(){const s=this.satisfactionDegree();if(s!==Constraint.UNDEFINED)return s;let t=1;for(const s of this.#a[0].domain()){const i=this.fuzzyRelation().satisfactionDegree(s);if(i<t&&(t=i),0===t)break}return t}}class Constraint2 extends Constraint{#a=[null,null];constructor(s,t,i){super(s),this.#a[0]=t,this.#a[1]=i}size(){return 2}at(s){if(0===s)return this.#a[0];if(1===s)return this.#a[1];throw new IndexOutOfBoundsException}[Symbol.iterator](){return this.#a[Symbol.iterator]()}has(s){return this.#a[0]===s||this.#a[1]===s}indexOf(s){return s===this.#a[0]?0:s===this.#a[1]?1:-1}emptyVariableSize(){let s=0;return this.#a[0].isEmpty()&&++s,this.#a[1].isEmpty()&&++s,s}isDefined(){return!this.#a[0].isEmpty()&&!this.#a[1].isEmpty()}isSatisfied(){return this.#a[0].isEmpty()||this.#a[1].isEmpty()?Constraint.UNDEFINED:this.crispRelation().isSatisfied(this.#a[0].value(),this.#a[1].value())?1:0}satisfactionDegree(){return this.#a[0].isEmpty()||this.#a[1].isEmpty()?Constraint.UNDEFINED:this.fuzzyRelation().satisfactionDegree(this.#a[0].value(),this.#a[1].value())}neighbors(){const s=[];for(const t of this.#a[0])t!==this&&s.push(t);for(const t of this.#a[1])t!==this&&s.push(t);return s}highestConsistencyDegree(){const s=this.satisfactionDegree();if(s!==Constraint.UNDEFINED)return s;let t=0;const i=this.#a[0].value(),e=this.#a[1].value(),r=this.#a[0].domain(),n=this.#a[1].domain();if(this.#a[0].isEmpty()&&!this.#a[1].isEmpty())for(const s of r){const i=this.fuzzyRelation().satisfactionDegree(s,e);if(i>t&&(t=i),1===t)break}else if(!this.#a[0].isEmpty()&&this.#a[1].isEmpty())for(const s of n){const e=this.fuzzyRelation().satisfactionDegree(i,s);if(e>t&&(t=e),1===t)break}else for(const s of r)for(const i of n){const e=this.fuzzyRelation().satisfactionDegree(s,i);if(e>t&&(t=e),1===t)break}return t}lowestConsistencyDegree(){const s=this.satisfactionDegree();if(s!==Constraint.UNDEFINED)return s;let t=1;const i=this.#a[0].value(),e=this.#a[1].value(),r=this.#a[0].domain(),n=this.#a[1].domain();if(this.#a[0].isEmpty()&&!this.#a[1].isEmpty())for(const s of r){const i=this.fuzzyRelation().satisfactionDegree(s,e);if(i<t&&(t=i),0===t)break}else if(!this.#a[0].isEmpty()&&this.#a[1].isEmpty())for(const s of n){const e=this.fuzzyRelation().satisfactionDegree(i,s);if(e<t&&(t=e),0===t)break}else for(const s of r)for(const i of n){const e=this.fuzzyRelation().satisfactionDegree(s,i);if(e<t&&(t=e),0===t)break}return t}}class Constraint3 extends Constraint{#a=[null,null,null];constructor(s,t,i,e){super(s),this.#a[0]=t,this.#a[1]=i,this.#a[2]=e}size(){return 3}at(s){if(0===s)return this.#a[0];if(1===s)return this.#a[1];if(2===s)return this.#a[2];throw new IndexOutOfBoundsException}[Symbol.iterator](){return this.#a[Symbol.iterator]()}has(s){return this.#a[0]===s||this.#a[1]===s||this.#a[2]===s}indexOf(s){return s===this.#a[0]?0:s===this.#a[1]?1:s===this.#a[2]?2:-1}emptyVariableSize(){let s=0;return this.#a[0].isEmpty()&&++s,this.#a[1].isEmpty()&&++s,this.#a[2].isEmpty()&&++s,s}isDefined(){return!this.#a[0].isEmpty()&&!this.#a[1].isEmpty()&&!this.#a[2].isEmpty()}isSatisfied(){return this.#a[0].isEmpty()||this.#a[1].isEmpty()||this.#a[2].isEmpty()?-1:this.crispRelation().isSatisfied(this.#a[0].value(),this.#a[1].value(),this.#a[2].value())?1:0}satisfactionDegree(){return this.#a[0].isEmpty()||this.#a[1].isEmpty()||this.#a[2].isEmpty()?Constraint.UNDEFINED:this.fuzzyRelation().satisfactionDegree(this.#a[0].value(),this.#a[1].value(),this.#a[2].value())}neighbors(){const s=[];for(const t of this.#a[0])t!==this&&s.push(t);for(const t of this.#a[1])t!==this&&s.push(t);for(const t of this.#a[2])t!==this&&s.push(t);return s}highestConsistencyDegree(){const s=this.satisfactionDegree();if(s!==Constraint.UNDEFINED)return s;let t=1;const i=this.#a[0].value(),e=this.#a[1].value(),r=this.#a[2].value(),n=this.#a[0].domain(),a=this.#a[1].domain(),o=this.#a[2].domain();if(!this.#a[0].isEmpty()||this.#a[1].isEmpty()||this.#a[2].isEmpty())if(this.#a[0].isEmpty()||!this.#a[1].isEmpty()||this.#a[2].isEmpty())if(this.#a[0].isEmpty()||this.#a[1].isEmpty()||!this.#a[2].isEmpty())if(this.#a[0].isEmpty()&&this.#a[1].isEmpty()&&!this.#a[2].isEmpty())for(const s of n)for(const i of a){const e=this.fuzzyRelation().satisfactionDegree(s,i,r);if(e>t&&(t=e),1===t)break}else if(this.#a[0].isEmpty()&&!this.#a[1].isEmpty()&&this.#a[2].isEmpty())for(const s of n)for(const i of o){const r=this.fuzzyRelation().satisfactionDegree(s,e,i);if(r>t&&(t=r),1===t)break}else if(!this.#a[0].isEmpty()&&this.#a[1].isEmpty()&&this.#a[2].isEmpty())for(const s of a)for(const e of o){const r=this.fuzzyRelation().satisfactionDegree(i,s,e);if(r>t&&(t=r),1===t)break}else for(const s of n)for(const i of a)for(const e of o){const r=this.fuzzyRelation().satisfactionDegree(s,i,e);if(r>t&&(t=r),1===t)break}else for(const s of o){const r=this.fuzzyRelation().satisfactionDegree(i,e,s);if(r>t&&(t=r),1===t)break}else for(const s of a){const e=this.fuzzyRelation().satisfactionDegree(i,s,r);if(e>t&&(t=e),1===t)break}else for(const s of n){const i=this.fuzzyRelation().satisfactionDegree(s,e,r);if(i>t&&(t=i),1===t)break}return t}lowestConsistencyDegree(){const s=this.satisfactionDegree();if(s!==Constraint.UNDEFINED)return s;let t=1;const i=this.#a[0].value(),e=this.#a[1].value(),r=this.#a[2].value(),n=this.#a[0].domain(),a=this.#a[1].domain(),o=this.#a[2].domain();if(!this.#a[0].isEmpty()||this.#a[1].isEmpty()||this.#a[2].isEmpty())if(this.#a[0].isEmpty()||!this.#a[1].isEmpty()||this.#a[2].isEmpty())if(this.#a[0].isEmpty()||this.#a[1].isEmpty()||!this.#a[2].isEmpty())if(this.#a[0].isEmpty()&&this.#a[1].isEmpty()&&!this.#a[2].isEmpty())for(const s of n)for(const i of a){const e=this.fuzzyRelation().satisfactionDegree(s,i,r);if(e<t&&(t=e),0===t)break}else if(this.#a[0].isEmpty()&&!this.#a[1].isEmpty()&&this.#a[2].isEmpty())for(const s of n)for(const i of o){const r=this.fuzzyRelation().satisfactionDegree(s,e,i);if(r<t&&(t=r),0===t)break}else if(!this.#a[0].isEmpty()&&this.#a[1].isEmpty()&&this.#a[2].isEmpty())for(const s of a)for(const e of o){const r=this.fuzzyRelation().satisfactionDegree(i,s,e);if(r<t&&(t=r),0===t)break}else for(const s of n)for(const i of a)for(const e of o){const r=this.fuzzyRelation().satisfactionDegree(s,i,e);if(r<t&&(t=r),0===t)break}else for(const s of o){const r=this.fuzzyRelation().satisfactionDegree(i,e,s);if(r<t&&(t=r),0===t)break}else for(const s of a){const e=this.fuzzyRelation().satisfactionDegree(i,s,r);if(e<t&&(t=e),0===t)break}else for(const s of n){const i=this.fuzzyRelation().satisfactionDegree(s,e,r);if(i<t&&(t=i),0===t)break}return t}}class ConstraintN extends Constraint{#a;#o;constructor(s,...t){super(s),this.#a=[...t],this.#o=new Array(this.#a.length)}size(){return this.#a.length}at(s){return this.#a[s]}[Symbol.iterator](){return this.#a[Symbol.iterator]()}has(s){return this.#a.includes(s)}indexOf(s){return this.#a.indexOf(s)}emptyVariableSize(){let s=0;for(const t of this.#a)t.isEmpty()&&++s;return s}isDefined(){for(const s of this.#a)if(s.isEmpty())return!1;return!0}isSatisfied(){for(let s=0;s<this.#a.length;++s){if(this.#a[s].isEmpty())return-1;this.#o[s]=this.#a[s].value()}return this.crispRelation().isSatisfied(...this.#o)?1:0}satisfactionDegree(){for(let s=0;s<this.#a.length;++s){const t=this.#a[s];if(t.isEmpty())return Constraint.UNDEFINED;this.#o[s]=t.value()}return this.fuzzyRelation().satisfactionDegree(...this.#o)}neighbors(){const s=[];for(const t of this.#a)for(const i of t)i!==this&&s.push(i);return s}highestConsistencyDegree(){const s=this.satisfactionDegree();if(s!==Constraint.UNDEFINED)return s;const t=new Array(this.emptyVariableSize());let i=0;for(let s=0;s<this.#a.length;++s)this.#a[s].isEmpty()?t[i++]=s:this.#o[s]=this.#a[s].value();return this.checkHCD(t,0,0)}lowestConsistencyDegree(){const s=this.satisfactionDegree();if(s!==Constraint.UNDEFINED)return s;const t=new Array(this.emptyVariableSize());let i=0;for(let s=0;s<this.#a.length;++s)this.#a[s].isEmpty()?t[i++]=s:this.#o[s]=this.#a[s].value();return this.checkLCD(t,0,1)}checkHCD(s,t,i){const e=s[t],r=this.#a[e].domain();if(t===s.length-1)for(const s of r){this.#o[e]=s;const t=this.fuzzyRelation().satisfactionDegree(this.#o);if(t>i&&(i=t),1===i)break}else for(const n of r)this.#o[e]=n,i=this.checkLCD(s,t+1,i);return i}checkLCD(s,t,i){const e=s[t],r=this.#a[e].domain();if(t===s.length-1)for(const s of r){this.#o[e]=s;const t=this.fuzzyRelation().satisfactionDegree(this.#o);if(t<i&&(i=t),0===i)break}else for(const n of r)this.#o[e]=n,i=this.checkLCD(s,t+1,i);return i}}class Domain{contains(s){}indexOf(s){}size(){}at(s){}[Symbol.iterator](){}random(){return this.at(Math.floor(Math.random()*this.size()))}}class DomainArbitrary extends Domain{#o;constructor(s){super(),this.#o=[...s]}contains(s){return this.#o.includes(s)}indexOf(s){return this.#o.indexOf(s)}size(){return this.#o.length}at(s){return this.#o[s]}[Symbol.iterator](){return this.#o[Symbol.iterator]()}}class DomainRanged extends Domain{#h;#l;constructor(s,t){super(),this.#h=0|s,this.#l=0|t}contains(s){return this.#h<=s&&s<=this.#l}indexOf(s){return this.#h<=s&&s<=this.#l?s-this.#h:-1}size(){return this.#l-this.#h+1}at(s){return this.#h+s}[Symbol.iterator](){let s=this.#h;return{next:()=>s<=this.#l?{value:s++,done:!1}:{done:!0}}}}class Variable extends Element{static#f=Number.MIN_VALUE;#c;#u;#v=Variable.#f;#m=[];constructor(s,t){super(),this.#c=s,this.#u=t}connect(s){if(this.has(s))throw new IllegalArgumentException;this.#m.push(s)}disconnect(s){if(!this.has(s))throw new IllegalArgumentException;this.#m=this.#m.filter((t=>t!==s))}assign(s){this.#v=s}clear(){this.assign(Variable.#f)}isEmpty(){return this.value()===Variable.#f}setDomain(s){this.#u=s,this.clear()}owner(){return this.#c}size(){return this.#m.length}at(s){return this.#m[s]}[Symbol.iterator](){return this.#m[Symbol.iterator]()}domain(){return this.#u}has(s){return this.#m.includes(s)}toString(){return`x${this.index()}${""===this.name()?"":`(${this.name()})`} = ${this.isEmpty()?"<empty>":this.value()}`}value(){return this.#v}neighbors(){const s=[];for(const t of this.#m)for(let i=0,e=t.size();i<e;i+=1){const e=t.at(i);e!==this&&s.push(e)}return s}}class Problem{_isFuzzy=!1;_vars=[];_cons=[];addVariable(s){s.setIndex(this._vars.length),this._vars.push(s)}createDomain(s){return s.values?new DomainArbitrary(s.values):"min"in s&&"max"in s?new DomainRanged(s.min,s.max):null}createVariable(s){if(s.value&&!s.domain.contains(s.value))throw new Error;const t=new Variable(this,s.domain);return this.addVariable(t),s.name&&t.setName(s.name),s.value&&t.assign(s.value),t}createConstraint(s){for(const t of s.variables)if(t.owner()!==this)return null;let t;t=1===s.variables.length?new Constraint1(s.relation,...s.variables):2===s.variables.length?new Constraint2(s.relation,...s.variables):3===s.variables.length?new Constraint3(s.relation,...s.variables):new ConstraintN(s.relation,s.variables),t.setIndex(this._cons.length),this._cons.push(t);for(const i of s.variables)i.connect(t);return t.isFuzzy()&&(this._isFuzzy=!0),s.name&&t.setName(s.name),t}removeConstraint(s){const t=this._cons.indexOf(s);this._cons.remove(s);for(let s=t;s<this._cons.length;++s)this._cons[s].setIndex(s);for(let t=0;t<s.size();++t)s.at(t).disconnect(s);this._isFuzzy=!1;for(let s=0,t=this._cons.length;s<t;++s)if(this._cons[s].isFuzzy()){this._isFuzzy=!0;break}}clearAllVariables(){for(const s of this._vars)s.clear()}reverseVariables(){this._vars.reverse();for(let s=0,t=this._vars.length;s<t;++s)this._vars[s].setIndex(s)}sortVariables(s){this._vars.sort(s);for(let s=0,t=this._vars.length;s<t;++s)this._vars[s].setIndex(s)}variableSize(){return this._vars.length}variableAt(s){return this._vars[s]}variableOf(s){for(const t of this._vars)if(t.name()===s)return t;return null}hasVariable(s){return this._vars.includes(s)}variables(){return this._vars}constraintSize(){return this._cons.length}constraintAt(s){return this._cons[s]}constraintOf(s){for(const t of this._cons)if(t.name()===s)return t;return null}hasConstraint(s){return this._cons.includes(s)}constraints(){return this._cons}constraintsBetween(s,t){const i=[];for(const e of s)e.has(t)&&i.push(e);return i}constraintsWithWorstSatisfactionDegree(){const s=[];let t=1;for(const i of this._cons){const e=i.satisfactionDegree();e<t?(t=e,s.length=0,s.push(i)):e-t<10*Number.MIN_VALUE&&s.push(i)}return[s,t]}worstSatisfactionDegree(){let s=1;for(const t of this._cons){const i=t.satisfactionDegree();if(i===Constraint.UNDEFINED)return Constraint.UNDEFINED;i<s&&(s=i)}return s}averageSatisfactionDegree(){let s=0;for(const t of this._cons)s+=t.satisfactionDegree();return s/=this._cons.length,s}emptyVariableSize(){let s=0;for(const t of this._vars)t.isEmpty()&&s++;return s}constraintDensity(){return this.constraintSize()/this.variableSize()}hasEmptyDomain(){for(const s of this._vars)if(0===s.domain().size())return!0;return!1}isFuzzy(){return this._isFuzzy}}class CrispProblem extends Problem{createConstraint(s){if(s.relation instanceof FuzzyRelation)throw new Error;return super.createConstraint(s)}isFuzzy(){return!1}satisfiedConstraintRate(){return this.satisfiedConstraintSize()/this._cons.length}satisfiedConstraintSize(){let s=0;for(let t=0;t<this._cons.length;++t)1===this._cons[t].isSatisfied()&&++s;return s}violatingConstraints(){const s=[];for(const t of this._cons)0===t.isSatisfied()&&s.push(t);return s}violatingConstraintSize(){let s=0;for(const t of this._cons)0===t.isSatisfied()&&++s;return s}}
//# sourceMappingURL=problem.min.js.map