{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,gB,W,O,A,E,S,a,A,G,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,E,E,E,O,C,U,W,O,C,GEKC,IAAA,EAAA,EAAA,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,QAaM,OAAM,EAEZ,CAAA,CAAG,CAAwC,CAAC,EAAY,IAAwB,IAAI,EAAA,QAAO,CAAE,EAAG,EAAG,AACnG,EAAA,CAAG,CAAgD,CAAC,EAAa,IAChE,AAAI,AAAc,IAAd,EAAG,MAAM,CACL,IAAI,EAAA,WAAU,CAAE,EAAG,CAAE,CAAC,EAAE,EAE5B,AAAc,IAAd,EAAG,MAAM,CACL,IAAI,EAAA,WAAU,CAAE,EAAG,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,EAEnC,AAAc,IAAd,EAAG,MAAM,CACL,IAAI,EAAA,WAAU,CAAE,EAAG,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,CAAE,CAAE,CAAC,EAAE,EAEvC,IAAI,EAAA,WAAU,CAAE,KAAM,EAC5B,AAEF,EAAA,CAAQ,CAAY,CAAA,CAAM,AAC1B,EAAA,CAAG,CAAe,EAAE,AAAC,AACrB,EAAA,CAAG,CAAiB,EAAE,AAAC,AAOvB,CAAA,mBAAmB,CAAuC,CAAQ,CACjE,IAAI,CAAC,CAAA,CAAG,CAAG,CACZ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","sources":["<anon>","stlics.ts","src/problem/problem.ts","src/problem/variable.ts","src/problem/element.ts","src/problem/domain-ranged.ts","src/problem/domain.ts","src/problem/domain-arbitrary.ts","src/problem/constraint.ts","src/problem/constraint-1.ts","src/problem/constraint-2.ts","src/problem/constraint-3.ts","src/problem/constraint-n.ts","src/problem/problem-crisp.ts","src/problem/variables.ts","src/problem/relation.ts","src/solver/solver.ts","src/solver/solver-factory-static.ts","src/solver/crisp/forward-checking.ts","src/util/assignment-list.ts","src/util/assignment.ts","src/util/domain-pruner.ts","src/solver/crisp/max-forward-checking.ts","src/solver/crisp/local-changes.ts","src/solver/crisp/local-changes-ex.ts","src/solver/crisp/breakout.ts","src/solver/crisp/genet.ts","src/solver/crisp/crisp-srs3.ts","src/solver/fuzzy/fuzzy-forward-checking.ts","src/solver/fuzzy/fuzzy-forward-checking-bc.ts","src/solver/fuzzy/flexible-local-changes.ts","src/solver/fuzzy/flexible-local-changes-ex.ts","src/solver/fuzzy/fuzzy-breakout.ts","src/solver/fuzzy/fuzzy-genet.ts","src/solver/fuzzy/srs3.ts","src/solver/fuzzy/srs3-pf.ts","src/solver/filter/post-stabilization.ts","src/solver/filter/ac3.ts","src/solver/filter/node-consistency.ts","src/util/problems.ts","src/util/loop-detector.ts","src/_docs/util.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire95bc\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire95bc\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"4NRei\", function(module, exports) {\n$parcel$export(module.exports, \"SolverFactory\", function () { return (parcelRequire(\"c3uSL\")).SolverFactory; });\nparcelRequire(\"4qG0Z\");\nparcelRequire(\"e7Kt8\");\nparcelRequire(\"66bm1\");\nparcelRequire(\"pU1Sy\");\nparcelRequire(\"jQeFi\");\nparcelRequire(\"b2Gif\");\nparcelRequire(\"3sJHX\");\nparcelRequire(\"kjEaa\");\nparcelRequire(\"dldqc\");\nparcelRequire(\"ebW8a\");\nparcelRequire(\"94CnG\");\nparcelRequire(\"AQJiv\");\nparcelRequire(\"dVggH\");\nparcelRequire(\"irBK2\");\nparcelRequire(\"jWYxK\");\nparcelRequire(\"c3uSL\");\nparcelRequire(\"2TCdz\");\nparcelRequire(\"kpsHE\");\nparcelRequire(\"ksORy\");\nparcelRequire(\"9NLdx\");\nparcelRequire(\"kYz6B\");\nparcelRequire(\"8e260\");\nparcelRequire(\"dfK30\");\nparcelRequire(\"9wYtf\");\nparcelRequire(\"5pbCs\");\nparcelRequire(\"9BMnn\");\nparcelRequire(\"dqtH5\");\nparcelRequire(\"2AvJP\");\nparcelRequire(\"aDEbX\");\nparcelRequire(\"b9ZRJ\");\nparcelRequire(\"envE3\");\nparcelRequire(\"gXtgR\");\nparcelRequire(\"gIE9K\");\nparcelRequire(\"6E6oA\");\nparcelRequire(\"SSONT\");\nparcelRequire(\"blH6y\");\nparcelRequire(\"6nrDu\");\nparcelRequire(\"5V057\");\nparcelRequire(\"8B8kR\");\n\n});\nparcelRegister(\"4qG0Z\", function(module, exports) {\n\n$parcel$export(module.exports, \"Problem\", function () { return $0f6ea66e9ef4e4cf$export$559d26475d35ac1e; });\n/**\n * The class represents a constraint satisfaction problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $pU1Sy = parcelRequire(\"pU1Sy\");\n\nvar $kjEaa = parcelRequire(\"kjEaa\");\n\nvar $3sJHX = parcelRequire(\"3sJHX\");\n\nvar $dldqc = parcelRequire(\"dldqc\");\n\nvar $ebW8a = parcelRequire(\"ebW8a\");\n\nvar $94CnG = parcelRequire(\"94CnG\");\n\nvar $AQJiv = parcelRequire(\"AQJiv\");\n\nvar $dVggH = parcelRequire(\"dVggH\");\nclass $0f6ea66e9ef4e4cf$export$559d26475d35ac1e {\n    #fv = (o, d)=>new (0, $pU1Sy.Variable)(o, d);\n    #fc = (r, xs)=>{\n        if (xs.length === 1) return new (0, $ebW8a.Constraint1)(r, xs[0]);\n        if (xs.length === 2) return new (0, $94CnG.Constraint2)(r, xs[0], xs[1]);\n        if (xs.length === 3) return new (0, $AQJiv.Constraint3)(r, xs[0], xs[1], xs[2]);\n        return new (0, $dVggH.ConstraintN)(r, ...xs);\n    };\n    #isFuzzy = false;\n    #xs = [];\n    #cs = [];\n    // Methods for Modifying Factories --------\n    /**\n\t * Sets a variable factory.\n\t */ setVariableFactory(fn) {\n        this.#fv = fn;\n    }\n    /**\n\t * Sets a variable factory.\n\t */ setConstraintFactory(fn) {\n        this.#fc = fn;\n    }\n    // Generation Methods --------\n    /**\n\t * Adds a variable to this problem.\n\t * @param Variable v A variable.\n\t */ addVariable(x) {\n        x.setIndex(this.#xs.length);\n        this.#xs.push(x);\n    }\n    /**\n\t * Generates a domain.\n\t * @param args {\n\t *   @type Array 'values' Multiple values.\n\t *\n\t *   @type Number 'min' Minimum value.\n\t *   @type Number 'max' Maximum value.\n\t * }\n\t * @return A domain.\n\t */ createDomain(args) {\n        if (\"values\" in args) return new (0, $3sJHX.DomainArbitrary)(args.values);\n        else if (\"min\" in args && \"max\" in args) return new (0, $kjEaa.DomainRanged)(args.min, args.max);\n        return null;\n    }\n    /**\n\t * Generates a variable.\n\t * @param Array args {\n\t *   @type string 'name'   Display name.\n\t *   @type Domain 'domain' A domain.\n\t *   @type *      'value'  A value.\n\t * }\n\t * @return A variable.\n\t */ createVariable(args) {\n        if (\"variable\" in args) {\n            const x = this.#fv(this, args.variable.domain());\n            this.addVariable(x);\n            x.setName(x.name());\n            x.assign(x.value());\n            return x;\n        } else {\n            if (args.value !== undefined && !args.domain.contains(args.value)) throw new Error();\n            const x = this.#fv(this, args.domain);\n            this.addVariable(x);\n            if (args.name) x.setName(args.name);\n            if (args.value) x.assign(args.value);\n            return x;\n        }\n    }\n    /**\n\t * Generates a constraint.\n\t * @param Array args {\n\t *   @type string   'name'      Display name.\n\t *   @type Array    'variables' Variables.\n\t *   @type Relation 'relation'  A relation.\n\t * }\n\t * @return A constraint.\n\t */ createConstraint(args) {\n        for (const x of args.variables){\n            if (x.owner() !== this) return null;\n        }\n        const c = this.#fc(args.relation, args.variables);\n        c.setIndex(this.#cs.length);\n        this.#cs.push(c);\n        for (const x of args.variables)x.connect(c);\n        if (c.isFuzzy()) this.#isFuzzy = true;\n        if (\"name\" in args) c.setName(args.name);\n        return c;\n    }\n    //  Modification Methods --------\n    /**\n\t * Remove the constraint.\n\t * @param c Constraints to be removed.\n\t */ removeConstraint(c) {\n        const index = this.#cs.indexOf(c);\n        this.#cs.splice(index, 1);\n        for(let i = index; i < this.#cs.length; ++i)this.#cs[i].setIndex(i);\n        for (const x of c)x.disconnect(c);\n        this.#isFuzzy = false;\n        for (const c of this.#cs)if (c.isFuzzy()) {\n            this.#isFuzzy = true;\n            break;\n        }\n    }\n    /**\n\t * Changes the status of all variables to unassigned.\n\t */ clearAllVariables() {\n        for (const x of this.#xs)x.clear();\n    }\n    /**\n\t * Reverse the order of variables.\n\t * The index of each variable is reassigned.\n\t */ reverseVariables() {\n        this.#xs.reverse();\n        for(let i = 0; i < this.#xs.length; ++i)this.#xs[i].setIndex(i);\n    }\n    /**\n\t * Sorts variables using a specified comparator.\n\t * The index of each variable is reassigned.\n\t * @param comparator A comparator.\n\t */ sortVariables(comparator) {\n        this.#xs.sort(comparator);\n        for(let i = 0; i < this.#xs.length; ++i)this.#xs[i].setIndex(i);\n    }\n    // Methods for Variables --------\n    /**\n\t * Returns the number of variables in the problem.\n\t * @return Number of variables\n\t */ variableSize() {\n        return this.#xs.length;\n    }\n    /**\n\t * Returns a variable by index.\n\t * @param index Index (0 <= index < getVariableSize()).\n\t * @return A variable\n\t */ variableAt(index) {\n        return this.#xs[index];\n    }\n    /**\n\t * Returns a variable by name.\n\t * @param name Name.\n\t * @return A variable.\n\t */ variableOf(name) {\n        for (const x of this.#xs){\n            if (x.name() === name) return x;\n        }\n        return null;\n    }\n    /**\n\t * Returns whether the variable is contained or not.\n\t * @param x A variable.\n\t * @return True if contained.\n\t */ hasVariable(x) {\n        return this.#xs.includes(x);\n    }\n    /**\n\t * Returns the list of variables.\n\t * The returned list is not allowed to be modified.\n\t * @return The variable list.\n\t */ variables() {\n        return this.#xs;\n    }\n    // Methods for Constraints --------\n    /**\n\t * Gets the number of constraints in the problem.\n\t * @return Number of constraints\n\t */ constraintSize() {\n        return this.#cs.length;\n    }\n    /**\n\t * Returns a constraint with an index.\n\t * @param index Index (0 <= index < constraintSize()).\n\t * @return A constraint.\n\t */ constraintAt(index) {\n        return this.#cs[index];\n    }\n    /**\n\t * Returns a constraint by name.\n\t * @param name Name.\n\t * @return A constraint.\n\t */ constraintOf(name) {\n        for (const c of this.#cs){\n            if (c.name() === name) return c;\n        }\n        return null;\n    }\n    /**\n\t * Returns whether the constraint is contained or not.\n\t * @param c A constraint\n\t * @return True if contained.\n\t */ hasConstraint(c) {\n        return this.#cs.includes(c);\n    }\n    /**\n\t * Returns the list of constraint.\n\t * The returned list is not allowed to be modified.\n\t * @return The constraint list.\n\t */ constraints() {\n        return this.#cs;\n    }\n    /**\n\t * Gets the constraints that exist between the specified variables.\n\t * Returns an empty array if no constraints exist.\n\t * If there are multiple constraints between two variables (including the case of n-ary constraints (2 < n)), they will be included in the return array.\n\t * @param v1 Variable 1\n\t * @param v2 Variable 2\n\t * @return Constraints.\n\t */ constraintsBetween(v1, v2) {\n        const cs = [];\n        for (const c of v1)if (c.has(v2)) cs.push(c);\n        return cs;\n    }\n    /**\n\t * Finds the set of worst satisfiable constraints in a fuzzy constraint satisfaction problem.\n\t * @return Array of constraints and worst satisfaction degree.\n\t */ constraintsWithWorstSatisfactionDegree() {\n        const cs = [];\n        let cur = 1;\n        for (const c of this.#cs){\n            const s = c.satisfactionDegree();\n            if (s < cur) {\n                cur = s;\n                cs.length = 0;\n                cs.push(c);\n            } else if (s - cur < Number.MIN_VALUE * 10) cs.push(c);\n        }\n        return [\n            cs,\n            cur\n        ];\n    }\n    // State acquisition methods --------\n    /**\n\t * Returns the worst satisfaction degree for the constraints contained in the fuzzy constraint satisfaction problem.\n\t * If the degree cannot be determined because the variable has not yet been assigned a value or for some other reason, -1 is returned.\n\t * @return Worst satisfaction degree.\n\t */ worstSatisfactionDegree() {\n        let cs = 1;\n        for (const c of this.#cs){\n            const s = c.satisfactionDegree();\n            if (s === (0, $dldqc.Constraint).UNDEFINED) return (0, $dldqc.Constraint).UNDEFINED;\n            if (s < cs) cs = s;\n        }\n        return cs;\n    }\n    /**\n\t * Gets the average of satisfaction degrees of the fuzzy constraints.\n\t * @return Average of satisfaction degrees.\n\t */ averageSatisfactionDegree() {\n        let ave = 0;\n        for (const c of this.#cs)ave += c.satisfactionDegree();\n        ave = ave / this.#cs.length;\n        return ave;\n    }\n    /**\n\t * Returns the number of variables in the problem that have not been assigned a value.\n\t * @return Number of variables with no value assigned.\n\t */ emptyVariableSize() {\n        let n = 0;\n        for (const x of this.#xs)if (x.isEmpty()) n++;\n        return n;\n    }\n    /**\n\t * Gets the constraint density (number of constraints/number of variables).\n\t * @return Constraint density.\n\t */ constraintDensity() {\n        return this.constraintSize() / this.variableSize();\n    }\n    /**\n\t * Returns whether the constraint satisfaction problem has any variables with empty domain.\n\t * @return True if it exists.\n\t */ hasEmptyDomain() {\n        for (const x of this.#xs){\n            if (x.domain().size() === 0) return true;\n        }\n        return false;\n    }\n    /**\n\t * Returns whether the problem is a fuzzy constraint satisfaction problem, i.e., whether it contains fuzzy constraints.\n\t * @return True if it is a fuzzy constraint satisfaction problem.\n\t */ isFuzzy() {\n        return this.#isFuzzy;\n    }\n}\n\n});\nparcelRegister(\"pU1Sy\", function(module, exports) {\n\n$parcel$export(module.exports, \"Variable\", function () { return $b3d2f9877ff61ecb$export$c867a5c9595a1350; });\n/**\n * Class that represents a variable.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $66bm1 = parcelRequire(\"66bm1\");\nclass $b3d2f9877ff61ecb$export$c867a5c9595a1350 extends (0, $66bm1.Element) {\n    static #INVALID = Number.MIN_VALUE;\n    #owner;\n    #d;\n    #v = $b3d2f9877ff61ecb$export$c867a5c9595a1350.#INVALID;\n    #cs = [];\n    // Called only from Problem.\n    constructor(owner, d){\n        super();\n        this.#owner = owner;\n        this.#d = d;\n    }\n    /**\n\t * Gets a string representation.\n\t * @return A string representation.\n\t */ toString() {\n        const n = this.name();\n        const np = n ? `(${n})` : \"\";\n        const v = this.isEmpty() ? \"<empty>\" : \"\" + this.value();\n        return `x${this.index()}${np} = ${v}`;\n    }\n    /**\n\t * Gets the number of associated constraints.\n\t * @return Number of constraints.\n\t */ size() {\n        return this.#cs.length;\n    }\n    /**\n\t * Gets the associated constraints by specifying their indices.\n\t * @param index Index.\n\t * @return A constraint.\n\t */ at(index) {\n        return this.#cs.at(index);\n    }\n    /**\n\t * Checks whether or not the variable is associated with the specified constraint.\n\t * @param c A constraint.\n\t * @return True if associated.\n\t */ has(c) {\n        return this.#cs.includes(c);\n    }\n    /**\n\t * Gets the index of a specified constraint.\n\t * If not found, returns -1.\n\t * @param c A constraint.\n\t * @return Index.\n\t */ indexOf(c) {\n        return this.#cs.indexOf(c);\n    }\n    /**\n\t * Collects the variables connected via the associated constraints.\n\t * @return An array of variables\n\t */ neighbors() {\n        const xs = [];\n        for (const c of this.#cs){\n            for (const x of c)if (x !== this) xs.push(x);\n        }\n        return xs;\n    }\n    /**\n\t * Gets the iterator of the associated constraints.\n\t */ [Symbol.iterator]() {\n        return this.#cs[Symbol.iterator]();\n    }\n    // -------------------------------------------------------------------------\n    /**\n\t * Gets the problem that owns this variable.\n\t * @return Owner.\n\t */ owner() {\n        return this.#owner;\n    }\n    // Called only from Problem.\n    connect(c) {\n        if (this.#cs.includes(c)) throw new RangeError();\n        this.#cs.push(c);\n    }\n    // Called only from Problem.\n    disconnect(c) {\n        if (!this.#cs.includes(c)) throw new RangeError();\n        this.#cs = this.#cs.filter((i)=>i !== c);\n    }\n    domain(d) {\n        if (d === undefined) return this.#d;\n        else {\n            this.#d = d;\n            this.clear();\n        }\n    }\n    /**\n\t * Assign a value.\n\t * @param value Value.\n\t */ assign(value) {\n        this.#v = value; // Do not change #val except here.\n    }\n    /**\n\t * Sets the state of the variable to unassigned.\n\t */ clear() {\n        // Do not use the invalid value except here and below (isEmpty).\n        this.assign($b3d2f9877ff61ecb$export$c867a5c9595a1350.#INVALID);\n    }\n    /**\n\t * Gets the value of the variable.\n\t * @returnThe value of the variable.\n\t */ value() {\n        return this.#v;\n    }\n    /**\n\t * Checks whether the value is unassigned or not.\n\t * @return True if unassigned.\n\t */ isEmpty() {\n        return this.value() === $b3d2f9877ff61ecb$export$c867a5c9595a1350.#INVALID;\n    }\n}\n\n});\nparcelRegister(\"66bm1\", function(module, exports) {\n\n$parcel$export(module.exports, \"Element\", function () { return $aebac6d707aea03e$export$db77ccec0bb4ccac; });\n/**\n * The common class of variables and constraints.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ class $aebac6d707aea03e$export$db77ccec0bb4ccac {\n    #index = -1;\n    #name = \"\";\n    /**\n\t * It is used when the user wishes to associate an arbitrary object with each element.\n\t */ userObject = null;\n    /**\n\t * Used when the solver wants to associate an arbitrary object with each element.\n\t */ solverObject = null;\n    // Called only from Problem.\n    setIndex(index) {\n        this.#index = index;\n    }\n    /**\n\t * Sets the name.\n\t *\n\t * @param name string representing the name.\n\t */ setName(name) {\n        this.#name = name;\n    }\n    /**\n\t * Get the index on the owned problem.\n\t * Each variable and constraint is assigned a serial number as an index, which is used to access it through the problem.\n\t *\n\t * @return Integer value representing the index.\n\t */ index() {\n        return this.#index;\n    }\n    /**\n\t * Gets the name.\n\t *\n\t * @return String representing the name.\n\t */ name() {\n        return this.#name;\n    }\n}\n\n});\n\n\nparcelRegister(\"kjEaa\", function(module, exports) {\n\n$parcel$export(module.exports, \"DomainRanged\", function () { return $2e94c734a2d838e3$export$681548042801f21c; });\n/**\n * A variable domain with contiguous integer elements.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $b2Gif = parcelRequire(\"b2Gif\");\nclass $2e94c734a2d838e3$export$681548042801f21c extends (0, $b2Gif.Domain) {\n    #min;\n    #max;\n    constructor(min, max){\n        super();\n        this.#min = min | 0;\n        this.#max = max | 0;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ contains(v) {\n        return this.#min <= v && v <= this.#max;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ indexOf(v) {\n        return this.#min <= v && v <= this.#max ? v - this.#min : -1;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ size() {\n        return this.#max - this.#min + 1;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ at(index) {\n        return this.#min + index;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ [Symbol.iterator]() {\n        let v = this.#min;\n        const max = this.#max;\n        return {\n            next () {\n                if (v <= max) return {\n                    value: v++,\n                    done: false\n                };\n                else return {\n                    value: null,\n                    done: true\n                };\n            }\n        };\n    }\n}\n\n});\nparcelRegister(\"b2Gif\", function(module, exports) {\n\n$parcel$export(module.exports, \"Domain\", function () { return $9d0e5c82a11742ce$export$f102e87ccfb079d0; });\n/**\n * An abstract class that represents a variable domain.\n * The domain is immutable.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ class $9d0e5c82a11742ce$export$f102e87ccfb079d0 {\n    /**\n\t * Gets an arbitrary value, regardless of whether it has been pruned or not.\n\t *\n\t * @return A value.\n\t */ random() {\n        return this.at(Math.floor(Math.random() * this.size()));\n    }\n}\n\n});\n\n\nparcelRegister(\"3sJHX\", function(module, exports) {\n\n$parcel$export(module.exports, \"DomainArbitrary\", function () { return $b4146d5df7ad9b79$export$62fe53be9d2bcdd3; });\n/**\n * A variable domain with arbitrary elements.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $b2Gif = parcelRequire(\"b2Gif\");\nclass $b4146d5df7ad9b79$export$62fe53be9d2bcdd3 extends (0, $b2Gif.Domain) {\n    #vs;\n    constructor(vs){\n        super();\n        this.#vs = [\n            ...vs\n        ];\n    }\n    /**\n\t * {@inheritDoc}\n\t */ contains(v) {\n        return this.#vs.includes(v);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ indexOf(v) {\n        return this.#vs.indexOf(v);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ size() {\n        return this.#vs.length;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ at(index) {\n        return this.#vs[index];\n    }\n    /**\n\t * {@inheritDoc}\n\t */ [Symbol.iterator]() {\n        return this.#vs[Symbol.iterator]();\n    }\n}\n\n});\n\nparcelRegister(\"dldqc\", function(module, exports) {\n\n$parcel$export(module.exports, \"Constraint\", function () { return $b269187258a654e0$export$aec1359a0a40a615; });\n/**\n * The class represents a constraint.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $66bm1 = parcelRequire(\"66bm1\");\nclass $b269187258a654e0$export$aec1359a0a40a615 extends (0, $66bm1.Element) {\n    /**\n\t * The constant indicating that the satisfaction degree is not defined.\n\t */ static UNDEFINED = -1;\n    rel;\n    // Called only from Problem.\n    constructor(r){\n        super();\n        this.rel = r;\n    }\n    /**\n\t * Returns the crisp relation between variables.\n\t * @return Relation.\n\t */ crispRelation() {\n        return this.rel;\n    }\n    /**\n\t * Returns the fuzzy relation between variables.\n\t * @return Relation.\n\t */ fuzzyRelation() {\n        return this.rel;\n    }\n    /**\n\t * Returns whether this is a fuzzy constraint.\n\t * @return True if it is fuzzy constraint.\n\t */ isFuzzy() {\n        return \"satisfactionDegree\" in this.rel;\n    }\n    /**\n\t * Returns a string representation.\n\t * @return A string representation.\n\t */ toString() {\n        const n = this.name();\n        const np = n ? `(${n})` : \"\";\n        const s = this.satisfactionDegree();\n        const sn = s === $b269187258a654e0$export$aec1359a0a40a615.UNDEFINED ? \"UNDEFINED\" : \"\" + s;\n        return `c${this.index()}${np} = ${sn}`;\n    }\n}\n\n});\n\nparcelRegister(\"ebW8a\", function(module, exports) {\n\n$parcel$export(module.exports, \"Constraint1\", function () { return $6a0029ef3a1fce85$export$42d7bbd8a43e587d; });\n/**\n * The class represents an unary constraint.\n * The constructor is not called directly, since it is created by the Problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $dldqc = parcelRequire(\"dldqc\");\nclass $6a0029ef3a1fce85$export$42d7bbd8a43e587d extends (0, $dldqc.Constraint) {\n    #xs = [];\n    // Called only from Problem.\n    constructor(r, x){\n        super(r);\n        this.#xs = [\n            x\n        ];\n    }\n    /**\n\t * {@inheritDoc}\n\t */ size() {\n        return 1;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ at(index) {\n        return this.#xs.at(index);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ has(x) {\n        return x === this.#xs[0];\n    }\n    /**\n\t * {@inheritDoc}\n\t */ indexOf(x) {\n        return x === this.#xs[0] ? 0 : -1;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ neighbors() {\n        const cs = [];\n        for (const c of this.#xs[0])if (c !== this) cs.push(c);\n        return cs;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ [Symbol.iterator]() {\n        return this.#xs[Symbol.iterator]();\n    }\n    // -------------------------------------------------------------------------\n    /**\n\t * {@inheritDoc}\n\t */ emptyVariableSize() {\n        return this.#xs[0].isEmpty() ? 1 : 0;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ isDefined() {\n        return !this.#xs[0].isEmpty();\n    }\n    /**\n\t * {@inheritDoc}\n\t */ isSatisfied() {\n        if (this.#xs[0].isEmpty()) return (0, $dldqc.Constraint).UNDEFINED;\n        return this.crispRelation().isSatisfied(this.#xs[0].value()) ? 1 : 0;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ satisfactionDegree() {\n        if (this.#xs[0].isEmpty()) return (0, $dldqc.Constraint).UNDEFINED;\n        return this.fuzzyRelation().satisfactionDegree(this.#xs[0].value());\n    }\n    /**\n\t * {@inheritDoc}\n\t */ highestConsistencyDegree() {\n        const sd = this.satisfactionDegree();\n        if (sd !== (0, $dldqc.Constraint).UNDEFINED) return sd;\n        let cd = 0;\n        for (const v of this.#xs[0].domain()){\n            const s = this.fuzzyRelation().satisfactionDegree(v);\n            if (s > cd) cd = s;\n            if (cd === 1) break;\n        }\n        return cd;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ lowestConsistencyDegree() {\n        const sd = this.satisfactionDegree();\n        if (sd !== (0, $dldqc.Constraint).UNDEFINED) return sd;\n        let cd = 1;\n        for (const v of this.#xs[0].domain()){\n            const s = this.fuzzyRelation().satisfactionDegree(v);\n            if (s < cd) cd = s;\n            if (cd === 0) break;\n        }\n        return cd;\n    }\n}\n\n});\n\nparcelRegister(\"94CnG\", function(module, exports) {\n\n$parcel$export(module.exports, \"Constraint2\", function () { return $28d738507c9375bb$export$18305a9eb79647d6; });\n/**\n * The class represents an binary constraint.\n * The constructor is not called directly, since it is created by the Problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $dldqc = parcelRequire(\"dldqc\");\nclass $28d738507c9375bb$export$18305a9eb79647d6 extends (0, $dldqc.Constraint) {\n    #xs = [];\n    // Called only from Problem.\n    constructor(r, x1, x2){\n        super(r);\n        this.#xs = [\n            x1,\n            x2\n        ];\n    }\n    /**\n\t * {@inheritDoc}\n\t */ size() {\n        return 2;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ at(index) {\n        return this.#xs.at(index);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ has(x) {\n        return this.#xs[0] === x || this.#xs[1] === x;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ indexOf(x) {\n        if (x === this.#xs[0]) return 0;\n        if (x === this.#xs[1]) return 1;\n        return -1;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ neighbors() {\n        const cs = [];\n        for (const c of this.#xs[0])if (c !== this) cs.push(c);\n        for (const c of this.#xs[1])if (c !== this) cs.push(c);\n        return cs;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ [Symbol.iterator]() {\n        return this.#xs[Symbol.iterator]();\n    }\n    // -------------------------------------------------------------------------\n    /**\n\t * {@inheritDoc}\n\t */ emptyVariableSize() {\n        let n = 0;\n        if (this.#xs[0].isEmpty()) ++n;\n        if (this.#xs[1].isEmpty()) ++n;\n        return n;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ isDefined() {\n        return !this.#xs[0].isEmpty() && !this.#xs[1].isEmpty();\n    }\n    /**\n\t * {@inheritDoc}\n\t */ isSatisfied() {\n        if (this.#xs[0].isEmpty() || this.#xs[1].isEmpty()) return (0, $dldqc.Constraint).UNDEFINED;\n        return this.crispRelation().isSatisfied(this.#xs[0].value(), this.#xs[1].value()) ? 1 : 0;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ satisfactionDegree() {\n        if (this.#xs[0].isEmpty() || this.#xs[1].isEmpty()) return (0, $dldqc.Constraint).UNDEFINED;\n        return this.fuzzyRelation().satisfactionDegree(this.#xs[0].value(), this.#xs[1].value());\n    }\n    /**\n\t * {@inheritDoc}\n\t */ highestConsistencyDegree() {\n        const sd = this.satisfactionDegree();\n        if (sd !== (0, $dldqc.Constraint).UNDEFINED) return sd;\n        let cd = 0;\n        const v1 = this.#xs[0].value();\n        const v2 = this.#xs[1].value();\n        const d1 = this.#xs[0].domain();\n        const d2 = this.#xs[1].domain();\n        if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty()) for (const v1 of d1){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2);\n            if (s > cd) cd = s;\n            if (cd === 1) break;\n        }\n        else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty()) for (const v2 of d2){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2);\n            if (s > cd) cd = s;\n            if (cd === 1) break;\n        }\n        else {\n            for (const v1 of d1)for (const v2 of d2){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2);\n                if (s > cd) cd = s;\n                if (cd === 1) break;\n            }\n        }\n        return cd;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ lowestConsistencyDegree() {\n        const sd = this.satisfactionDegree();\n        if (sd !== (0, $dldqc.Constraint).UNDEFINED) return sd;\n        let cd = 1;\n        const v1 = this.#xs[0].value();\n        const v2 = this.#xs[1].value();\n        const d1 = this.#xs[0].domain();\n        const d2 = this.#xs[1].domain();\n        if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty()) for (const v1 of d1){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2);\n            if (s < cd) cd = s;\n            if (cd === 0) break;\n        }\n        else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty()) for (const v2 of d2){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2);\n            if (s < cd) cd = s;\n            if (cd === 0) break;\n        }\n        else {\n            for (const v1 of d1)for (const v2 of d2){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2);\n                if (s < cd) cd = s;\n                if (cd === 0) break;\n            }\n        }\n        return cd;\n    }\n}\n\n});\n\nparcelRegister(\"AQJiv\", function(module, exports) {\n\n$parcel$export(module.exports, \"Constraint3\", function () { return $dd27aab0852e9c64$export$7dc34a7e74bc57bb; });\n/**\n * The class represents an 3-ary constraint.\n * The constructor is not called directly, since it is created by the Problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $dldqc = parcelRequire(\"dldqc\");\nclass $dd27aab0852e9c64$export$7dc34a7e74bc57bb extends (0, $dldqc.Constraint) {\n    #xs = [];\n    // Called only from Problem.\n    constructor(r, x1, x2, x3){\n        super(r);\n        this.#xs = [\n            x1,\n            x2,\n            x3\n        ];\n    }\n    /**\n\t * {@inheritDoc}\n\t */ size() {\n        return 3;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ at(index) {\n        return this.#xs.at(index);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ has(x) {\n        return this.#xs[0] === x || this.#xs[1] === x || this.#xs[2] === x;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ indexOf(x) {\n        if (x === this.#xs[0]) return 0;\n        if (x === this.#xs[1]) return 1;\n        if (x === this.#xs[2]) return 2;\n        return -1;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ neighbors() {\n        const cs = [];\n        for (const c of this.#xs[0])if (c !== this) cs.push(c);\n        for (const c of this.#xs[1])if (c !== this) cs.push(c);\n        for (const c of this.#xs[2])if (c !== this) cs.push(c);\n        return cs;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ [Symbol.iterator]() {\n        return this.#xs[Symbol.iterator]();\n    }\n    // -------------------------------------------------------------------------\n    /**\n\t * {@inheritDoc}\n\t */ emptyVariableSize() {\n        let n = 0;\n        if (this.#xs[0].isEmpty()) ++n;\n        if (this.#xs[1].isEmpty()) ++n;\n        if (this.#xs[2].isEmpty()) ++n;\n        return n;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ isDefined() {\n        return !this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && !this.#xs[2].isEmpty();\n    }\n    /**\n\t * {@inheritDoc}\n\t */ isSatisfied() {\n        if (this.#xs[0].isEmpty() || this.#xs[1].isEmpty() || this.#xs[2].isEmpty()) return (0, $dldqc.Constraint).UNDEFINED;\n        return this.crispRelation().isSatisfied(this.#xs[0].value(), this.#xs[1].value(), this.#xs[2].value()) ? 1 : 0;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ satisfactionDegree() {\n        if (this.#xs[0].isEmpty() || this.#xs[1].isEmpty() || this.#xs[2].isEmpty()) return (0, $dldqc.Constraint).UNDEFINED;\n        return this.fuzzyRelation().satisfactionDegree(this.#xs[0].value(), this.#xs[1].value(), this.#xs[2].value());\n    }\n    /**\n\t * {@inheritDoc}\n\t */ highestConsistencyDegree() {\n        const sd = this.satisfactionDegree();\n        if (sd !== (0, $dldqc.Constraint).UNDEFINED) return sd;\n        let cd = 1;\n        const v1 = this.#xs[0].value();\n        const v2 = this.#xs[1].value();\n        const v3 = this.#xs[2].value();\n        const d1 = this.#xs[0].domain();\n        const d2 = this.#xs[1].domain();\n        const d3 = this.#xs[2].domain();\n        if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) for (const v1 of d1){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n            if (s > cd) cd = s;\n            if (cd === 1) break;\n        }\n        else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) for (const v2 of d2){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n            if (s > cd) cd = s;\n            if (cd === 1) break;\n        }\n        else if (!this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) for (const v3 of d3){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n            if (s > cd) cd = s;\n            if (cd === 1) break;\n        }\n        else if (this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\n            for (const v1 of d1)for (const v2 of d2){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n                if (s > cd) cd = s;\n                if (cd === 1) break;\n            }\n        } else if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n            for (const v1 of d1)for (const v3 of d3){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n                if (s > cd) cd = s;\n                if (cd === 1) break;\n            }\n        } else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n            for (const v2 of d2)for (const v3 of d3){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n                if (s > cd) cd = s;\n                if (cd === 1) break;\n            }\n        } else for (const v1 of d1){\n            for (const v2 of d2)for (const v3 of d3){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n                if (s > cd) cd = s;\n                if (cd === 1) break;\n            }\n        }\n        return cd;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ lowestConsistencyDegree() {\n        const sd = this.satisfactionDegree();\n        if (sd !== (0, $dldqc.Constraint).UNDEFINED) return sd;\n        let cd = 1;\n        const v1 = this.#xs[0].value();\n        const v2 = this.#xs[1].value();\n        const v3 = this.#xs[2].value();\n        const d1 = this.#xs[0].domain();\n        const d2 = this.#xs[1].domain();\n        const d3 = this.#xs[2].domain();\n        if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) for (const v1 of d1){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n            if (s < cd) cd = s;\n            if (cd === 0) break;\n        }\n        else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) for (const v2 of d2){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n            if (s < cd) cd = s;\n            if (cd === 0) break;\n        }\n        else if (!this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) for (const v3 of d3){\n            const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n            if (s < cd) cd = s;\n            if (cd === 0) break;\n        }\n        else if (this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\n            for (const v1 of d1)for (const v2 of d2){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n                if (s < cd) cd = s;\n                if (cd === 0) break;\n            }\n        } else if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n            for (const v1 of d1)for (const v3 of d3){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n                if (s < cd) cd = s;\n                if (cd === 0) break;\n            }\n        } else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n            for (const v2 of d2)for (const v3 of d3){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n                if (s < cd) cd = s;\n                if (cd === 0) break;\n            }\n        } else for (const v1 of d1){\n            for (const v2 of d2)for (const v3 of d3){\n                const s = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n                if (s < cd) cd = s;\n                if (cd === 0) break;\n            }\n        }\n        return cd;\n    }\n}\n\n});\n\nparcelRegister(\"dVggH\", function(module, exports) {\n\n$parcel$export(module.exports, \"ConstraintN\", function () { return $cac261f9549e7972$export$fd9d2e5591a15c9a; });\n/**\n * The class represents an n-ary constraint.\n * The constructor is not called directly, since it is created by the Problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $dldqc = parcelRequire(\"dldqc\");\nclass $cac261f9549e7972$export$fd9d2e5591a15c9a extends (0, $dldqc.Constraint) {\n    #xs;\n    #vs;\n    // Called only from Problem.\n    constructor(r, ...xs){\n        super(r);\n        this.#xs = [\n            ...xs\n        ];\n        this.#vs = new Array(this.#xs.length);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ size() {\n        return this.#xs.length;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ at(index) {\n        return this.#xs.at(index);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ has(x) {\n        return this.#xs.includes(x);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ indexOf(x) {\n        return this.#xs.indexOf(x);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ neighbors() {\n        const cs = [];\n        for (const x of this.#xs){\n            for (const c of x)if (c !== this) cs.push(c);\n        }\n        return cs;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ [Symbol.iterator]() {\n        return this.#xs[Symbol.iterator]();\n    }\n    // -------------------------------------------------------------------------\n    /**\n\t * {@inheritDoc}\n\t */ emptyVariableSize() {\n        let n = 0;\n        for (const x of this.#xs)if (x.isEmpty()) ++n;\n        return n;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ isDefined() {\n        for (const x of this.#xs){\n            if (x.isEmpty()) return false;\n        }\n        return true;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ isSatisfied() {\n        for(let i = 0; i < this.#xs.length; ++i){\n            const x = this.#xs[i];\n            if (x.isEmpty()) return -1;\n            this.#vs[i] = x.value();\n        }\n        return this.crispRelation().isSatisfied(...this.#vs) ? 1 : 0;\n    }\n    /**\n\t * {@inheritDoc}\n\t */ satisfactionDegree() {\n        for(let i = 0; i < this.#xs.length; ++i){\n            const x = this.#xs[i];\n            if (x.isEmpty()) return (0, $dldqc.Constraint).UNDEFINED;\n            this.#vs[i] = x.value();\n        }\n        return this.fuzzyRelation().satisfactionDegree(...this.#vs);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ highestConsistencyDegree() {\n        const sd = this.satisfactionDegree();\n        if (sd !== (0, $dldqc.Constraint).UNDEFINED) return sd;\n        const emptyIndices = new Array(this.emptyVariableSize());\n        let c = 0;\n        for(let i = 0; i < this.#xs.length; ++i){\n            const x = this.#xs[i];\n            if (x.isEmpty()) emptyIndices[c++] = i;\n            else this.#vs[i] = x.value();\n        }\n        return this.checkHCD(emptyIndices, 0, 0);\n    }\n    /**\n\t * {@inheritDoc}\n\t */ lowestConsistencyDegree() {\n        const sd = this.satisfactionDegree();\n        if (sd !== (0, $dldqc.Constraint).UNDEFINED) return sd;\n        const emptyIndices = new Array(this.emptyVariableSize());\n        let c = 0;\n        for(let i = 0; i < this.#xs.length; ++i){\n            const x = this.#xs[i];\n            if (x.isEmpty()) emptyIndices[c++] = i;\n            else this.#vs[i] = x.value();\n        }\n        return this.checkLCD(emptyIndices, 0, 1);\n    }\n    checkHCD(emptyIndices, currentStep, cd) {\n        const index = emptyIndices[currentStep];\n        const d = this.#xs[index].domain();\n        if (currentStep === emptyIndices.length - 1) for (const v of d){\n            this.#vs[index] = v;\n            const s = this.fuzzyRelation().satisfactionDegree(...this.#vs);\n            if (s > cd) cd = s;\n            if (cd === 1) break;\n        }\n        else for (const v of d){\n            this.#vs[index] = v;\n            cd = this.checkLCD(emptyIndices, currentStep + 1, cd);\n        }\n        return cd;\n    }\n    checkLCD(emptyIndices, currentStep, cd) {\n        const index = emptyIndices[currentStep];\n        const d = this.#xs[index].domain();\n        if (currentStep === emptyIndices.length - 1) for (const v of d){\n            this.#vs[index] = v;\n            const s = this.fuzzyRelation().satisfactionDegree(...this.#vs);\n            if (s < cd) cd = s;\n            if (cd === 0) break;\n        }\n        else for (const v of d){\n            this.#vs[index] = v;\n            cd = this.checkLCD(emptyIndices, currentStep + 1, cd);\n        }\n        return cd;\n    }\n}\n\n});\n\n\nparcelRegister(\"e7Kt8\", function(module, exports) {\n\n$parcel$export(module.exports, \"CrispProblem\", function () { return $b0fa7efcc20c7cf9$export$2d7b2a6964dca148; });\n/**\n * The class represents a crisp constraint satisfaction problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $4qG0Z = parcelRequire(\"4qG0Z\");\nclass $b0fa7efcc20c7cf9$export$2d7b2a6964dca148 extends (0, $4qG0Z.Problem) {\n    /**\n\t * Generates a crisp constraint.\n\t * @param Array args {\n\t *   @type string   'name'      Display name.\n\t *   @type Array    'variables' Variables.\n\t *   @type Relation 'relation'  A relation.\n\t * }\n\t * @return A constraint.\n\t */ createConstraint(args) {\n        if (\"satisfactionDegree\" in args.relation) throw new Error();\n        return super.createConstraint(args);\n    }\n    /**\n\t * Returns whether the problem is a fuzzy constraint satisfaction problem, i.e., whether it contains fuzzy constraints.\n\t * @return Always returns false.\n\t */ isFuzzy() {\n        return false;\n    }\n    /**\n\t * Returns the rate of constraints that are satisfied out of all constraints.\n\t * @return Rate of satisfied constraints.\n\t */ satisfiedConstraintRate() {\n        return this.satisfiedConstraintSize() / this.constraintSize();\n    }\n    /**\n\t * Returns the number of satisfied constraints.\n\t * Undefined constraints are ignored.\n\t * @return Number of satisfied constraints.\n\t */ satisfiedConstraintSize() {\n        let count = 0;\n        for (const c of this.constraints())if (c.isSatisfied() === 1) ++count;\n        return count;\n    }\n    /**\n\t * Returns a list of violating constraints.\n\t * Undefined constraints are ignored.\n\t * @return Array of constraints.\n\t */ violatingConstraints() {\n        const cs = [];\n        for (const c of this.constraints())if (c.isSatisfied() === 0) cs.push(c);\n        return cs;\n    }\n    /**\n\t * Returns the number of violating constraints.\n\t * Undefined constraints are ignored.\n\t * @return Number of violating constraints.\n\t */ violatingConstraintSize() {\n        let size = 0;\n        for (const c of this.constraints())if (c.isSatisfied() === 0) ++size;\n        return size;\n    }\n}\n\n});\n\nparcelRegister(\"jQeFi\", function(module, exports) {\n\n$parcel$export(module.exports, \"ImaginaryVariable\", function () { return $8916545b3fe6be61$export$ebe658c66b5c45ae; });\n/**\n * Classes of utility variables.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ \nvar $pU1Sy = parcelRequire(\"pU1Sy\");\nclass $8916545b3fe6be61$export$a14c1bd8f74377e extends (0, $pU1Sy.Variable) {\n    #observer;\n    // Called only from Problem.\n    constructor(owner, d, observer){\n        super(owner, d);\n        this.#observer = observer;\n    }\n    /**\n\t * Assign a value.\n\t * @param v Value.\n\t */ assign(v) {\n        super.assign(v);\n        if (this.#observer) this.#observer(this, v);\n    }\n}\nclass $8916545b3fe6be61$export$ebe658c66b5c45ae extends (0, $pU1Sy.Variable) {\n    #orig;\n    constructor(x){\n        super(x.owner(), x.domain());\n        this.#orig = x;\n        this.setName(x.name());\n        this.assign(x.value());\n    }\n    assign(v) {\n        this.#orig.assign(v);\n    }\n    domain(d) {\n        if (d === undefined) return this.#orig.domain();\n        else this.#orig.domain(d);\n    }\n    value() {\n        return this.#orig.value();\n    }\n}\n\n});\n\nparcelRegister(\"irBK2\", function(module, exports) {\n/**\n * Interfaces that represents the relationship between variables.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ /**\n * An interface that represents the relationship between variables.\n */ \n});\n\nparcelRegister(\"jWYxK\", function(module, exports) {\n\n$parcel$export(module.exports, \"Solver\", function () { return $e5aa64fdd85bb56e$export$cca492cadf45c096; });\n/**\n * The class for solvers for finding solutions to constraint satisfaction problems.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ class $e5aa64fdd85bb56e$export$cca492cadf45c096 {\n    _debug = true;\n    #debugOutput = (e)=>console.log(e);\n    /**\n\t * The crisp/fuzzy constraint satisfaction problem solved by the solver.\n\t */ _pro;\n    /**\n\t *  Limit number of iterations.\n\t */ _iterLimit = null;\n    /**\n\t * Time limit.\n\t */ _timeLimit = null;\n    /**\n\t * Target 'satisfied constraint rate' or 'constraint satisfaction degree'.\n\t */ _targetDeg = 0.8;\n    /**\n\t * Listeners of this solver.\n\t */ #listener = [];\n    /**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param pro A constraint satisfaction problem.\n\t */ constructor(pro){\n        this._pro = pro;\n    }\n    /**\n\t * Returns the name of the solver.\n\t * @return The name.\n\t */ name() {\n        return \"\";\n    }\n    /**\n\t * Placeholder for implementing an algorithm.\n\t * The solve method calls this method and returns the return value of this method.\n\t * @return True if the algorithm succeeds,\n\t */ exec() {\n        return false;\n    }\n    /**\n\t * Sets and limits the maximum number of iterations for the solver's behavior.\n\t * After the specified number of iterations, the solver stops as a failure. The specific behavior depends on the solver.\n\t * @param count Maximum value; null means not set.\n\t */ setIterationLimit(count = null) {\n        this._iterLimit = count;\n    }\n    /**\n\t * Sets a time limit on the solver's behavior.\n\t * If the specified time is exceeded, the solver stops as a failure. The specific behavior depends on the solver.\n\t * @param msec Time limit. null means not set.\n\t */ setTimeLimit(msec = null) {\n        this._timeLimit = msec;\n    }\n    /**\n\t * The goal to be achieved, which is the condition for stopping the solver, is set as the constraint satisfaction degree (fuzzy) or the percentage of constraints satisfied (crisp).\n\t * The solver stops as success if the specified percentage is reached or exceeded. The specific behavior depends on the solver.\n\t * @param rate Degree or rate. null indicates not set.\n\t */ setTargetRate(rate = null) {\n        this._targetDeg = rate;\n    }\n    /**\n\t * Computes the solution to a constraint satisfaction problem.\n\t * The specific meaning of the return value depends on the implementation of the algorithm.\n\t * @return True if the algorithm succeeds\n\t */ solve() {\n        return this.exec();\n    }\n    addListener(l) {\n        this.#listener.push(l);\n    }\n    removeListener(l) {\n        this.#listener.splice(this.#listener.indexOf(l), 1);\n    }\n    foundSolution(solution, worstDegree) {\n        let finish = false;\n        for (const l of this.#listener)if (l.foundSolution(solution, worstDegree)) finish = true;\n        return finish;\n    }\n    // -------------------------------------------------------------------------\n    /**\n\t * Sets whether to output debug strings.\n\t * @param boolean flag Do output if true.\n\t */ setDebugMode(flag) {\n        this._debug = flag;\n    }\n    /**\n\t * Sets a function that used for outputting debug strings.\n\t * @param function fn Function called when debug output.\n\t */ setDebugOutput(fn) {\n        this.#debugOutput = fn;\n    }\n    _debugOutput(str) {\n        if (this._debug) this.#debugOutput(str);\n    }\n}\n\n});\n\nparcelRegister(\"c3uSL\", function(module, exports) {\n\n$parcel$export(module.exports, \"SolverFactory\", function () { return $642a6c3604d92e8d$export$4e442516b8f577ee; });\n/**\n * Solver factory class.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $dqtH5 = parcelRequire(\"dqtH5\");\n\nvar $envE3 = parcelRequire(\"envE3\");\n\nvar $aDEbX = parcelRequire(\"aDEbX\");\n\nvar $b9ZRJ = parcelRequire(\"b9ZRJ\");\n\nvar $5pbCs = parcelRequire(\"5pbCs\");\n\nvar $2AvJP = parcelRequire(\"2AvJP\");\n\nvar $9BMnn = parcelRequire(\"9BMnn\");\n\nvar $9NLdx = parcelRequire(\"9NLdx\");\n\nvar $kYz6B = parcelRequire(\"kYz6B\");\n\nvar $2TCdz = parcelRequire(\"2TCdz\");\n\nvar $kpsHE = parcelRequire(\"kpsHE\");\n\nvar $ksORy = parcelRequire(\"ksORy\");\n\nvar $8e260 = parcelRequire(\"8e260\");\n\nvar $dfK30 = parcelRequire(\"dfK30\");\n\nvar $9wYtf = parcelRequire(\"9wYtf\");\nclass $642a6c3604d92e8d$export$4e442516b8f577ee {\n    static crispSolverNames() {\n        return [\n            /* 0 */ \"Forward Checking\",\n            /* 1 */ \"Max Forward Checking\",\n            /* 2 */ \"Local Changes\",\n            /* 3 */ \"Local Changes Ex\",\n            /* 4 */ \"Breakout\",\n            /* 5 */ \"GENET\",\n            /* 6 */ \"Crisp SRS 3\"\n        ];\n    }\n    static fuzzySolverNames() {\n        return [\n            /* 0 */ \"Fuzzy Forward Checking\",\n            /* 1 */ \"Fuzzy Forward Checking Bc\",\n            /* 2 */ \"Flexible Local Changes\",\n            /* 3 */ \"Flexible Local Changes Ex\",\n            /* 4 */ \"Fuzzy Breakout\",\n            /* 5 */ \"Fuzzy GENET\",\n            /* 6 */ \"SRS 3\",\n            /* 7 */ \"SRS 3 PF\"\n        ];\n    }\n    static async createSolver(type, p) {\n        const cs = await $642a6c3604d92e8d$export$4e442516b8f577ee.createCrispSolver(type, p);\n        if (cs) return cs;\n        const fs = await $642a6c3604d92e8d$export$4e442516b8f577ee.createFuzzySolver(type, p);\n        if (fs) return fs;\n        return null;\n    }\n    static async createCrispSolver(type, p) {\n        switch(type.replaceAll(\" \", \"\")){\n            case \"ForwardChecking\":\n            case \"forward-checking\":\n                return new (0, $dqtH5.ForwardChecking)(p);\n            case \"MaxForwardChecking\":\n            case \"max-forward-checking\":\n                return new (0, $envE3.MaxForwardChecking)(p);\n            case \"LocalChanges\":\n            case \"local-changes\":\n                return new (0, $aDEbX.LocalChanges)(p);\n            case \"LocalChangesEx\":\n            case \"local-changes-ex\":\n                return new (0, $b9ZRJ.LocalChangesEx)(p);\n            case \"Breakout\":\n            case \"breakout\":\n                return new (0, $5pbCs.Breakout)(p);\n            case \"GENET\":\n            case \"genet\":\n                return new (0, $2AvJP.GENET)(p);\n            case \"CrispSRS3\":\n            case \"crisp-srs3\":\n                return new (0, $9BMnn.CrispSRS3)(p);\n        }\n        return null;\n    }\n    static async createFuzzySolver(type, p) {\n        switch(type.replaceAll(\" \", \"\")){\n            case \"FuzzyForwardChecking\":\n            case \"fuzzy-forward-checking\":\n                return new (0, $9NLdx.FuzzyForwardChecking)(p);\n            case \"FuzzyForwardCheckingBc\":\n            case \"fuzzy-forward-checking-bc\":\n                return new (0, $kYz6B.FuzzyForwardCheckingBc)(p);\n            case \"FlexibleLocalChanges\":\n            case \"flexible-local-changes\":\n                return new (0, $2TCdz.FlexibleLocalChanges)(p);\n            case \"FlexibleLocalChangesEx\":\n            case \"flexible-local-changes-ex\":\n                return new (0, $kpsHE.FlexibleLocalChangesEx)(p);\n            case \"FuzzyBreakout\":\n            case \"fuzzy-breakout\":\n                return new (0, $ksORy.FuzzyBreakout)(p);\n            case \"FuzzyGENET\":\n            case \"fuzzy-genet\":\n                return new (0, $8e260.FuzzyGENET)(p);\n            case \"SRS3\":\n            case \"srs3\":\n                return new (0, $dfK30.SRS3)(p);\n            case \"SRS3PF\":\n            case \"SRS3_PF\":\n            case \"srs3-pf\":\n                return new (0, $9wYtf.SRS3_PF)(p);\n        }\n        return null;\n    }\n}\n\n});\nparcelRegister(\"dqtH5\", function(module, exports) {\n\n$parcel$export(module.exports, \"ForwardChecking\", function () { return $5b597c0c8a6f9738$export$8570b7b487498488; });\n/**\n * This class that implements the forward checking method.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n * Searches for variable assignments that satisfy all constraints and fails if none are found.\n * Each variable must have its own domain because it hides domain elements as branch pruning.\n * Forward checking is also performed for problems with polynomial constraints.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $5V057 = parcelRequire(\"5V057\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $5b597c0c8a6f9738$export$8570b7b487498488 extends (0, $jWYxK.Solver) {\n    #xs;\n    #sol = new (0, $6nrDu.AssignmentList)();\n    #relCs = [];\n    #useMRV = false;\n    #iterCount = 0;\n    #endTime = 0;\n    /**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */ constructor(p){\n        super(p);\n        this.#xs = [\n            ...this._pro.variables()\n        ];\n        for (const x of this.#xs)x.solverObject = new (0, $5V057.DomainPruner)(x.domain().size());\n        this.#initializeRelatedConstraintTable();\n    }\n    name() {\n        return \"Forward Checking\";\n    }\n    /**\n\t * The settings made by this method are invalid.\n\t */ setTargetRate() {\n    // Do nothing.\n    }\n    /**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */ setUsingMinimumRemainingValuesHeuristics(flag) {\n        this.#useMRV = flag;\n    }\n    // Initializes a table that caches constraints between two variables.\n    #initializeRelatedConstraintTable() {\n        this.#relCs = [];\n        for(let j = 0; j < this.#xs.length; ++j){\n            this.#relCs.push(new Array(this.#xs.length));\n            for(let i = 0; i < this.#xs.length; ++i)if (i < j) this.#relCs[j][i] = this._pro.constraintsBetween(this.#xs[i], this.#xs[j]);\n        }\n    }\n    // Retrieves an array of constraints from a table that caches constraints between two variables.\n    #getConstraintsBetween(i, j) {\n        if (i < j) return this.#relCs[j][i];\n        return this.#relCs[i][j];\n    }\n    // Checks for possible assignment to a future variable from the current variable assignment.\n    #checkForward(level, currentIndex) {\n        for (const x_i of this.#xs){\n            if (!x_i.isEmpty()) continue; // If it is a past or present variable.\n            const d_i = x_i.domain();\n            const dp_i = x_i.solverObject;\n            const cs = this.#getConstraintsBetween(currentIndex, x_i.index());\n            for (const c of cs){\n                if (c.emptyVariableSize() !== 1) continue;\n                for(let k = 0, n = d_i.size(); k < n; ++k){\n                    if (dp_i.isValueHidden(k)) continue;\n                    x_i.assign(d_i.at(k));\n                    if (c.isSatisfied() === 0) dp_i.hide(k, level);\n                }\n                x_i.clear();\n                if (dp_i.isEmpty()) return false; // Failure if the domain of one of the future variables is empty.\n            }\n        }\n        return true;\n    }\n    // Returns the index of the smallest domain variable.\n    #indexOfVariableWithMRV() {\n        let index = 0;\n        let size = Number.MAX_VALUE;\n        for(let i = 0; i < this.#xs.length; ++i){\n            const x = this.#xs[i];\n            if (!x.isEmpty()) continue;\n            const d = x.domain();\n            const s = d.size() - x.solverObject.hiddenSize();\n            if (s < size) {\n                size = s;\n                index = i;\n            }\n        }\n        return index;\n    }\n    // Searches for one variable at a time.\n    #branch(level) {\n        // Failure if repeated a specified number.\n        if (this._iterLimit && this._iterLimit < this.#iterCount++) return false;\n        // Failure if time limit is exceeded.\n        if (this.#endTime < Date.now()) return false;\n        if (level === this._pro.variableSize()) {\n            this.#sol.setProblem(this._pro);\n            return true;\n        }\n        const xc_index = this.#useMRV ? this.#indexOfVariableWithMRV() : level;\n        const xc = this.#xs[xc_index];\n        const d = xc.domain();\n        const dp = xc.solverObject;\n        for(let i = 0, n = d.size(); i < n; ++i){\n            if (dp.isValueHidden(i)) continue;\n            xc.assign(d.at(i));\n            if (this.#checkForward(level, xc_index) && this.#branch(level + 1)) return true;\n            for (const x of this.#xs)x.solverObject.reveal(level);\n        }\n        xc.clear();\n        return false;\n    }\n    // Do search.\n    exec() {\n        this.#endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        this.#iterCount = 0;\n        this._pro.clearAllVariables();\n        const r = this.#branch(0);\n        if (r) ;\n        else {\n            if (this._iterLimit && this._iterLimit < this.#iterCount) this._debugOutput(\"stop: number of iterations has reached the limit\");\n            if (this.#endTime < Date.now()) this._debugOutput(\"stop: time limit has been reached\");\n        }\n        for (const a of this.#sol){\n            a.apply();\n            a.variable().solverObject.revealAll();\n        }\n        return r;\n    }\n}\n\n});\nparcelRegister(\"6nrDu\", function(module, exports) {\n\n$parcel$export(module.exports, \"AssignmentList\", function () { return $f354097057fedc87$export$1d4e454bcd46f18f; });\n/**\n * The class represents multiple variables and their assignments.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $blH6y = parcelRequire(\"blH6y\");\nclass $f354097057fedc87$export$1d4e454bcd46f18f {\n    static fromVariables(xs) {\n        const al = new $f354097057fedc87$export$1d4e454bcd46f18f();\n        al.setVariables(xs);\n        return al;\n    }\n    #as = [];\n    constructor(){}\n    setProblem(p) {\n        this.#as.length = 0;\n        for (const x of p.variables())this.#as.push(new (0, $blH6y.Assignment)({\n            variable: x,\n            value: x.value()\n        }));\n    }\n    setAssignmentList(al) {\n        this.#as.length = 0;\n        for (const a of al)this.#as.push(new (0, $blH6y.Assignment)({\n            variable: a.variable(),\n            value: a.value()\n        }));\n    }\n    setVariables(xs) {\n        this.#as.length = 0;\n        for (const x of xs)this.#as.push(new (0, $blH6y.Assignment)({\n            variable: x,\n            value: x.value()\n        }));\n    }\n    addVariable(variable, value = null) {\n        this.#as.push(new (0, $blH6y.Assignment)({\n            variable: variable,\n            value: value\n        }));\n    }\n    apply() {\n        for (const a of this.#as)a.apply();\n    }\n    /**\n\t * Remove all assignments.\n\t */ clear() {\n        this.#as.length = 0;\n    }\n    /**\n\t * Checks whether the list is empty or not.\n\t * @return True if empty.\n\t */ isEmpty() {\n        return this.#as.length === 0;\n    }\n    /**\n\t * Gets the number of assignments.\n\t * @return Number of assignments.\n\t */ size() {\n        return this.#as.length;\n    }\n    differenceSize() {\n        let diff = 0;\n        for (const a of this.#as)if (a.variable().value() !== a.value()) ++diff;\n        return diff;\n    }\n    /**\n\t * Gets the assignments by specifying their indices.\n\t * @param index Index.\n\t * @return An assignment.\n\t */ at(index) {\n        return this.#as[index];\n    }\n    /**\n\t * Gets the iterator of the assignments.\n\t */ [Symbol.iterator]() {\n        return this.#as[Symbol.iterator]();\n    }\n    /**\n\t * Gets an arbitrary assignment.\n\t *\n\t * @return An assignment.\n\t */ random() {\n        return this.#as[Math.floor(Math.random() * this.#as.length)];\n    }\n}\n\n});\nparcelRegister(\"blH6y\", function(module, exports) {\n\n$parcel$export(module.exports, \"Assignment\", function () { return $0a6def75b7f0de22$export$e6b39d88cc0d636; });\n/**\n * The class represents a pair of variables and the values to be assigned to them.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ class $0a6def75b7f0de22$export$e6b39d88cc0d636 {\n    #x;\n    #v;\n    constructor(args){\n        if (\"assignment\" in args) {\n            this.#x = args.assignment.variable();\n            this.#v = args.assignment.value();\n        } else if (\"variable\" in args) {\n            this.#x = args.variable;\n            this.#v = args.value ?? args.variable.value();\n        } else throw new RangeError();\n    }\n    /**\n\t * Assigns a value to a stored variable.\n\t */ apply() {\n        this.#x.assign(this.#v);\n    }\n    /**\n\t * Returns a string representation.\n\t * @return A string representation.\n\t */ toString() {\n        return `v${this.#x.index()} <- ${this.#v}`;\n    }\n    /**\n\t * Gets the value.\n\t * @return Value.\n\t */ value() {\n        return this.#v;\n    }\n    /**\n\t * Gets the variable.\n\t * @return Variable.\n\t */ variable() {\n        return this.#x;\n    }\n}\n\n});\n\n\nparcelRegister(\"5V057\", function(module, exports) {\n\n$parcel$export(module.exports, \"DomainPruner\", function () { return $d44a9b1f10b78424$export$f307752a90139b0e; });\n/**\n * This class holds the branch pruning states for a domain.\n *\n * @author Takuto Yanagida\n * @version 2023-03-25\n */ class $d44a9b1f10b78424$export$f307752a90139b0e {\n    static #UNHIDDEN = -1;\n    #hiddenLevels;\n    #hiddenSize = 0;\n    /**\n\t * Generates a class that holds branch pruning states for a domain.\n\t * @param size Size of the corresponding domain\n\t */ constructor(size){\n        this.#hiddenLevels = new Array(size);\n        this.#hiddenLevels.fill($d44a9b1f10b78424$export$f307752a90139b0e.#UNHIDDEN);\n    }\n    /**\n\t * Returns the size of the erased element.\n\t * @return Size of the erased element.\n\t */ hiddenSize() {\n        return this.#hiddenSize;\n    }\n    /**\n\t * Erases the element at the specified index.\n\t * @param index Index.\n\t * @param level Level.\n\t */ hide(index, level) {\n        if (this.#hiddenLevels[index] === $d44a9b1f10b78424$export$f307752a90139b0e.#UNHIDDEN) ++this.#hiddenSize;\n        this.#hiddenLevels[index] = level;\n    }\n    /**\n\t * Returns whether the element is empty or not.\n\t * Returns true if all elements have been erased.\n\t * @return True if empty.\n\t */ isEmpty() {\n        return this.#hiddenLevels.length === this.#hiddenSize;\n    }\n    /**\n\t * Returns whether or not the element at the specified index has been erased.\n\t * @param index Index.\n\t * @return True if erased.\n\t */ isValueHidden(index) {\n        return this.#hiddenLevels[index] !== $d44a9b1f10b78424$export$f307752a90139b0e.#UNHIDDEN;\n    }\n    /**\n\t * Restores the value that had been erased, by specifying a level.\n\t * @param level Level\n\t */ reveal(level) {\n        for(let i = 0; i < this.#hiddenLevels.length; ++i)if (this.#hiddenLevels[i] === level) {\n            this.#hiddenLevels[i] = $d44a9b1f10b78424$export$f307752a90139b0e.#UNHIDDEN;\n            --this.#hiddenSize;\n        }\n    }\n    /**\n\t * Restores all erased values.\n\t */ revealAll() {\n        this.#hiddenLevels.fill($d44a9b1f10b78424$export$f307752a90139b0e.#UNHIDDEN);\n        this.#hiddenSize = 0;\n    }\n}\n\n});\n\n\nparcelRegister(\"envE3\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaxForwardChecking\", function () { return $695b212fabdeccbc$export$2a32484f7cb0d846; });\n/**\n * This class that implements the forward checking method.\n * Find the solution to the problem as the maximum CSP.\n * Each variable must have its own domain because it hides domain elements as branch pruning.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $5V057 = parcelRequire(\"5V057\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $695b212fabdeccbc$export$2a32484f7cb0d846 extends (0, $jWYxK.Solver) {\n    #xs;\n    #sol = new (0, $6nrDu.AssignmentList)();\n    #maxVioCount;\n    #vioCount = 0;\n    #checkedCs = new Set();\n    #cs = [];\n    #iterCount = 0;\n    #endTime = 0;\n    /**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */ constructor(p){\n        super(p);\n        this.#xs = [\n            ...this._pro.variables()\n        ];\n        for (const x of this.#xs)x.solverObject = new (0, $5V057.DomainPruner)(x.domain().size());\n        this.#maxVioCount = this._pro.constraintSize();\n    }\n    name() {\n        return \"Forward Checking for Max CSPs\";\n    }\n    #branch(level, vioCount) {\n        // Failure if repeated a specified number.\n        if (this._iterLimit && this._iterLimit < this.#iterCount++) return false;\n        // Failure if time limit is exceeded.\n        if (this.#endTime < Date.now()) return false;\n        const p = this._pro;\n        if (level === p.variableSize()) {\n            const vcs = p.violatingConstraintSize();\n            if (vcs < this.#maxVioCount) {\n                this.#maxVioCount = vcs;\n                this.#sol.setProblem(this._pro);\n                this._debugOutput(`   refreshed ${this.#maxVioCount}`);\n                if ((this._targetDeg ?? 1) <= p.satisfiedConstraintRate()) return true;\n            }\n            return false;\n        }\n        const xc = this.#xs[level];\n        const d = xc.domain();\n        const dp = xc.solverObject;\n        for(let i = 0, n = d.size(); i < n; ++i){\n            if (dp.isValueHidden(i)) continue;\n            xc.assign(d.at(i));\n            this.#vioCount = vioCount + this.#getAdditionalViolationCount(level, xc); // for max begin\n            if (this.#vioCount > this.#maxVioCount) continue; // for max end\n            if (this.#checkForward(level) && this.#branch(level + 1, this.#vioCount)) return true;\n            for (const x of this.#xs)x.solverObject.reveal(level);\n        }\n        xc.clear();\n        return false;\n    }\n    // Checks for possible assignment to a future variable from the current variable assignment.\n    #checkForward(level) {\n        const xc = this.#xs[level];\n        for(let i = level + 1; i < this.#xs.length; ++i){\n            const future = this.#xs[i];\n            this.#cs = this._pro.constraintsBetween(xc, future);\n            for (const c of this.#cs){\n                if (c.emptyVariableSize() !== 1) continue;\n                if (this.#revise(future, c, level)) {\n                    if (future.solverObject.isEmpty()) return false; // Failure if the domain of one of the future variables is empty.\n                }\n            }\n        }\n        return true;\n    }\n    // Find the number of constraint violations that have increased due to the current value of the variable vc.\n    #getAdditionalViolationCount(level, xc) {\n        let avc = 0;\n        this.#checkedCs.clear(); // Reuse.\n        for(let i = 0; i < level; ++i){\n            this.#cs = this._pro.constraintsBetween(xc, this.#xs[i]);\n            for (const c of this.#cs){\n                if (this.#checkedCs.has(c)) continue;\n                if (c.isSatisfied() === 0) // Neither satisfied nor undefined.\n                ++avc;\n                this.#checkedCs.add(c);\n            }\n        }\n        return avc;\n    }\n    // Remove values from the domain of v1 that do not correspond to v2. That is, match v1 with v2.\n    #revise(x1, c, level) {\n        let deleted = false;\n        const d = x1.domain();\n        const dp = x1.solverObject;\n        for(let k = 0, n = d.size(); k < n; ++k){\n            if (dp.isValueHidden(k)) continue;\n            x1.assign(d.at(k));\n            if (c.isSatisfied() === 0 && this.#vioCount + 1 > this.#maxVioCount) {\n                dp.hide(k, level);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    exec() {\n        this.#endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        this.#iterCount = 0;\n        this._pro.clearAllVariables();\n        const r = this.#branch(0, 0);\n        if (r) this._debugOutput(\"stop: current degree is above the target\");\n        else {\n            if (this._iterLimit && this._iterLimit < this.#iterCount) this._debugOutput(\"stop: number of iterations has reached the limit\");\n            if (this.#endTime < Date.now()) this._debugOutput(\"stop: time limit has been reached\");\n        }\n        for (const a of this.#sol){\n            a.apply();\n            a.variable().solverObject.revealAll();\n        }\n        return r;\n    }\n}\n\n});\n\nparcelRegister(\"aDEbX\", function(module, exports) {\n\n$parcel$export(module.exports, \"LocalChanges\", function () { return $fefb29797493a6ea$export$8153937ab18ca581; });\n/**\n * Class implements the local changes method.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $fefb29797493a6ea$export$8153937ab18ca581 extends (0, $jWYxK.Solver) {\n    static #setPlusElement(s, e) {\n        return new Set(s).add(e);\n    }\n    static #setMinusElement(s, e) {\n        const sn = new Set(s);\n        sn.delete(e);\n        return sn;\n    }\n    #iterCount = 0;\n    #endTime = 0;\n    #globalReturn = false;\n    constructor(p, unassignAll = false){\n        super(p);\n        if (unassignAll) this._pro.clearAllVariables();\n    }\n    name() {\n        return \"Local Changes\";\n    }\n    #createNewV3(X1_X2, x, v) {\n        const newX3 = new Set();\n        const cs = new Set();\n        for (const xa of X1_X2){\n            const temp = this._pro.constraintsBetween(x, xa);\n            for (const c of temp)cs.add(c);\n        }\n        const origV = x.value(); // Save the value.\n        x.assign(v);\n        for (const c of cs){\n            if (c.isSatisfied() === 0) for (const xi of c)newX3.add(xi);\n        }\n        x.assign(origV); // Restore the value.\n        newX3.delete(x);\n        return newX3;\n    }\n    #isConsistent(A, x, v) {\n        const cs = new Set();\n        for (const xa of A){\n            const temp = this._pro.constraintsBetween(x, xa);\n            for (const c of temp)cs.add(c);\n        }\n        const origV = x.value(); // Save the value.\n        x.assign(v);\n        for (const c of cs)if (c.isSatisfied() === 0) {\n            x.assign(origV); // Restore the value.\n            return false;\n        }\n        x.assign(origV); // Restore the value.\n        return true;\n    }\n    #lcValue(X1, X2, x, v) {\n        if (!this.#isConsistent(X1, x, v)) return false;\n        const X1_X2 = X1.union(X2);\n        if (this.#isConsistent(X1_X2, x, v)) return true;\n        const X3 = this.#createNewV3(X1_X2, x, v);\n        const T = X1_X2.difference(X3);\n        if (!this.#isConsistent(T, x, v)) this._debugOutput(\"bug\");\n        for (const xx of X3)xx.clear();\n        X1 = $fefb29797493a6ea$export$8153937ab18ca581.#setPlusElement(X1, x);\n        X2 = X2.difference(X3);\n        return this.#lcVariables(X1, X2, X3);\n    }\n    #lcVariable(X1, X2, x, d) {\n        if (d.size === 0) return false;\n        const v = d.values().next().value;\n        const al = (0, $6nrDu.AssignmentList).fromVariables(X2);\n        x.assign(v);\n        const ret = this.#lcValue(X1, X2, x, v);\n        if (ret || this.#globalReturn) return ret;\n        x.clear();\n        al.apply();\n        return this.#lcVariable(X1, X2, x, $fefb29797493a6ea$export$8153937ab18ca581.#setMinusElement(d, v));\n    }\n    #lcVariables(X1, X2, X3) {\n        this._debugOutput(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n        // Success if violation rate improves from specified\n        if ((this._targetDeg ?? 1) <= this._pro.satisfiedConstraintRate()) {\n            this._debugOutput(\"stop: current degree is above the target\");\n            this.#globalReturn = true;\n            return true;\n        }\n        // Failure if repeated a specified number\n        if (this._iterLimit && this._iterLimit < this.#iterCount++) {\n            this._debugOutput(\"stop: number of iterations has reached the limit\");\n            this.#globalReturn = true;\n            return false;\n        }\n        // Failure if time limit is exceeded\n        if (this.#endTime < Date.now()) {\n            this._debugOutput(\"stop: time limit has been reached\");\n            this.#globalReturn = true;\n            return false;\n        }\n        if (X3.size === 0) return true;\n        const x = X3.values().next().value;\n        const d = new Set();\n        for (const v of x.domain())d.add(v);\n        const ret = this.#lcVariable(X1, X2, x, d);\n        if (!ret || this.#globalReturn) return ret;\n        X2 = $fefb29797493a6ea$export$8153937ab18ca581.#setPlusElement(X2, x);\n        X3 = $fefb29797493a6ea$export$8153937ab18ca581.#setMinusElement(X3, x);\n        return this.#lcVariables(X1, X2, X3);\n    }\n    exec() {\n        this.#endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        this.#iterCount = 0;\n        this.#globalReturn = false;\n        if (this._pro.emptyVariableSize() === 0) this._pro.clearAllVariables();\n        const notFixed = new Set();\n        const unassigned = new Set();\n        for (const x of this._pro.variables())(!x.isEmpty() ? notFixed : unassigned).add(x);\n        return this.#lcVariables(new Set(), notFixed, unassigned);\n    }\n}\n\n});\n\nparcelRegister(\"b9ZRJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"LocalChangesEx\", function () { return $b0d12def09c2af65$export$e577c7182ffc977b; });\n/**\n * Class implements the local changes method.\n * The implementation is optimized by converting recursive calls to loops.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $b0d12def09c2af65$export$e577c7182ffc977b extends (0, $jWYxK.Solver) {\n    static #setPlusElement(s, e) {\n        return new Set(s).add(e);\n    }\n    #iterCount = 0;\n    #endTime = 0;\n    #globalReturn = false;\n    constructor(p, unassignAll = false){\n        super(p);\n        if (unassignAll) this._pro.clearAllVariables();\n    }\n    name() {\n        return \"Local Changes Ex\";\n    }\n    #createNewV3(X1_X2, x, v) {\n        const newX3 = new Set();\n        const cs = new Set();\n        for (const xa of X1_X2){\n            const temp = this._pro.constraintsBetween(x, xa);\n            for (const c of temp)cs.add(c);\n        }\n        const origV = x.value(); // Save the value.\n        x.assign(v);\n        for (const c of cs){\n            if (c.isSatisfied() === 0) for (const xi of c)newX3.add(xi);\n        }\n        x.assign(origV); // Restore the value.\n        newX3.delete(x);\n        return newX3;\n    }\n    #isConsistent(A, x, v) {\n        const cs = new Set();\n        for (const xa of A){\n            const temp = this._pro.constraintsBetween(x, xa);\n            for (const c of temp)cs.add(c);\n        }\n        const origV = x.value(); // Save the value.\n        x.assign(v);\n        for (const c of cs)if (c.isSatisfied() === 0) {\n            x.assign(origV); // Restore the value.\n            return false;\n        }\n        x.assign(origV); // Restore the value.\n        return true;\n    }\n    #lcValue(X1, X2, x) {\n        if (!this.#isConsistent(X1, x, x.value())) return false;\n        const X1_X2 = X1.union(X2);\n        if (this.#isConsistent(X1_X2, x, x.value())) return true;\n        const X3 = this.#createNewV3(X1_X2, x, x.value());\n        X1 = $b0d12def09c2af65$export$e577c7182ffc977b.#setPlusElement(X1, x);\n        X2 = X2.difference(X3);\n        return this.#lcVariables(X1, X2, X3);\n    }\n    #lcVariable(X1, X2, x) {\n        for (const v of x.domain()){\n            const al = (0, $6nrDu.AssignmentList).fromVariables(X2);\n            x.assign(v);\n            const ret = this.#lcValue(X1, X2, x);\n            if (ret || this.#globalReturn) return ret;\n            x.clear();\n            al.apply();\n        }\n        return false;\n    }\n    #lcVariables(X1, X2, X3) {\n        X2 = new Set(X2); // Clone\n        X3 = new Set(X3); // Clone\n        while(true){\n            this._debugOutput(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n            // Success if violation rate improves from specified\n            if ((this._targetDeg ?? 1) <= this._pro.satisfiedConstraintRate()) {\n                this._debugOutput(\"stop: current degree is above the target\");\n                this.#globalReturn = true;\n                return true;\n            }\n            // Failure if repeated a specified number\n            if (this._iterLimit && this._iterLimit < this.#iterCount++) {\n                this._debugOutput(\"stop: number of iterations has reached the limit\");\n                this.#globalReturn = true;\n                return false;\n            }\n            // Failure if time limit is exceeded\n            if (this.#endTime < Date.now()) {\n                this._debugOutput(\"stop: time limit has been reached\");\n                this.#globalReturn = true;\n                return false;\n            }\n            if (X3.size === 0) return true;\n            const x = X3.values().next().value;\n            const ret = this.#lcVariable(X1, X2, x);\n            if (!ret || this.#globalReturn) return ret;\n            X2.add(x);\n            X3.delete(x);\n        }\n    }\n    exec() {\n        this.#endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        this.#iterCount = 0;\n        this.#globalReturn = false;\n        if (this._pro.emptyVariableSize() === 0) this._pro.clearAllVariables();\n        const notFixed = new Set();\n        const unassigned = new Set();\n        for (const x of this._pro.variables())(!x.isEmpty() ? notFixed : unassigned).add(x);\n        return this.#lcVariables(new Set(), notFixed, unassigned);\n    }\n}\n\n});\n\nparcelRegister(\"5pbCs\", function(module, exports) {\n\n$parcel$export(module.exports, \"Breakout\", function () { return $c9db9f0e52a83cc6$export$44de86bc32e07644; });\n/**\n * Class implements a solver using the breakout method.\n * Solves a problem as a maximum CSP.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $c9db9f0e52a83cc6$export$44de86bc32e07644 extends (0, $jWYxK.Solver) {\n    #isRandom = true;\n    #ws;\n    /**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */ constructor(p){\n        super(p);\n        this.#ws = new Array(this._pro.constraintSize());\n        this.#ws.fill(1);\n    }\n    name() {\n        return \"Breakout\";\n    }\n    /**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of local solutions, but makes the solution unrepeatable.\n\t * @param flag Whether the randomness is enabled.\n\t */ setRandomness(flag) {\n        this.#isRandom = flag;\n    }\n    #findCandidates(vioXs, canList) {\n        let maxDiff = 0;\n        for (const x of vioXs){\n            const x_v = x.value(); // Save the value\n            let nowVio = 0;\n            for (const c of x)nowVio += (1 - c.isSatisfied()) * this.#ws[c.index()];\n            out: for (const v of x.domain()){\n                if (x_v === v) continue;\n                x.assign(v);\n                let diff = nowVio;\n                for (const c of x){\n                    diff -= (1 - c.isSatisfied()) * this.#ws[c.index()];\n                    // If the improvement is less than the previous improvement, try the next variable.\n                    if (diff < maxDiff) continue out;\n                }\n                if (diff > maxDiff) {\n                    maxDiff = diff;\n                    canList.clear();\n                    canList.addVariable(x, v);\n                } else if (maxDiff !== 0) canList.addVariable(x, v);\n            }\n            x.assign(x_v); // Restore the value.\n        }\n    }\n    #listViolatingVariables(vioCs) {\n        const xs = new Set();\n        for (const c of vioCs)for (const x of c)xs.add(x);\n        return Array.from(xs);\n    }\n    exec() {\n        const endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        let iterCount = 0;\n        for (const x of this._pro.variables())if (x.isEmpty()) x.assign(x.domain().at(0));\n        const canList = new (0, $6nrDu.AssignmentList)();\n        const p = this._pro;\n        while(true){\n            const vcs = p.violatingConstraints();\n            // Success if violation rate improves from specified\n            if ((this._targetDeg ?? 1) <= p.satisfiedConstraintRate()) {\n                this._debugOutput(\"stop: current degree is above the target\");\n                return true;\n            }\n            // Failure if repeated a specified number\n            if (this._iterLimit && this._iterLimit < iterCount++) {\n                this._debugOutput(\"stop: number of iterations has reached the limit\");\n                return false;\n            }\n            // Failure if time limit is exceeded\n            if (endTime < Date.now()) {\n                this._debugOutput(\"stop: time limit has been reached\");\n                return false;\n            }\n            this._debugOutput(vcs.length + \" violations\");\n            this.#findCandidates(this.#listViolatingVariables(vcs), canList);\n            if (0 < canList.size()) {\n                const a = this.#isRandom ? canList.random() : canList.at(0);\n                a.apply();\n                canList.clear();\n                this._debugOutput(\"\t\" + a);\n            } else {\n                for (const c of vcs)this.#ws[c.index()] += 1;\n                this._debugOutput(\"breakout\");\n            }\n        }\n    }\n}\n\n});\n\nparcelRegister(\"2AvJP\", function(module, exports) {\n\n$parcel$export(module.exports, \"GENET\", function () { return $047eed9e2a62e006$export$d94917317b4f74cb; });\n/**\n * This class implements GENET.\n * CSP (but only Binary CSP) is supported.\n * Find the solution to the problem as the maximum CSP.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $047eed9e2a62e006$export$d94917317b4f74cb extends (0, $jWYxK.Solver) {\n    static nextInt(max) {\n        return Math.floor(Math.random() * Math.floor(max));\n    }\n    #clusters = [];\n    #connections = [];\n    /**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */ constructor(p){\n        super(p);\n    }\n    name() {\n        return \"GENET\";\n    }\n    #createNetwork() {\n        this._debugOutput(\"network creation start\");\n        const cons = [];\n        for (const x of this._pro.variables()){\n            if (x.domain().size() === 0) return false;\n            this.#clusters.push(new $047eed9e2a62e006$var$Cluster(x));\n        }\n        for (const c of this._pro.constraints())if (c.size() === 1) {\n            const x = c.at(0);\n            const cl = this.#clusters[x.index()];\n            for(let i = 0; i < cl.size(); ++i){\n                const origV = x.value(); // Save the value.\n                x.assign(cl.get(i)._value);\n                if (c.isSatisfied() === 0) cons.push(new $047eed9e2a62e006$var$Connection(cl.get(i)));\n                x.assign(origV); // Restore the value.\n            }\n        } else {\n            const x1 = c.at(0);\n            const x2 = c.at(1);\n            const cl_f = this.#clusters[x1.index()];\n            const cl_s = this.#clusters[x2.index()];\n            for(let i = 0; i < cl_f.size(); ++i){\n                const origV1 = x1.value(); // Save the value.\n                x1.assign(cl_f.get(i)._value);\n                for(let j = 0; j < cl_s.size(); ++j){\n                    const origV2 = x2.value(); // Save the value.\n                    x2.assign(cl_s.get(j)._value);\n                    if (c.isSatisfied() === 0) cons.push(new $047eed9e2a62e006$var$Connection(cl_f.get(i), cl_s.get(j)));\n                    x2.assign(origV2); // Restore the value.\n                }\n                x1.assign(origV1); // Restore the value.\n            }\n        }\n        for (const cl of this.#clusters)for (const n of cl._neurons)n.lockConnections();\n        this.#connections = cons;\n        this._debugOutput(\"network creation complete\");\n        return true;\n    }\n    #shuffle(is) {\n        for(let i = is.length; i > 1; --i){\n            const j = $047eed9e2a62e006$export$d94917317b4f74cb.nextInt(i);\n            const temp = is[i - 1];\n            is[i - 1] = is[j];\n            is[j] = temp;\n        }\n        return is;\n    }\n    exec() {\n        if (!this.#createNetwork()) throw new Error();\n        const endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        let iterCount = 0;\n        const sol = new (0, $6nrDu.AssignmentList)();\n        const order = [];\n        for(let i = 0; i < this.#clusters.length; ++i)order.push(i);\n        const p = this._pro;\n        let cur = p.satisfiedConstraintRate();\n        let success = false;\n        while(true){\n            if (this._iterLimit && this._iterLimit < iterCount++) {\n                this._debugOutput(\"stop: number of iterations has reached the limit\");\n                break;\n            }\n            if (endTime < Date.now()) {\n                this._debugOutput(\"stop: time limit has been reached\");\n                break;\n            }\n            let modified = false;\n            for (const i of this.#shuffle(order))if (this.#clusters[i].setActivityMaximumInput()) modified = true; // Turn on the node with the largest input in each cluster\n            if (!modified) for (const con of this.#connections)con.refreshWeight(); // Update weights for all connections\n            else {\n                for (const clu of this.#clusters)clu.applyToVariable(); // Apply to variable\n                const rate = p.satisfiedConstraintRate();\n                if (cur < rate) {\n                    cur = rate;\n                    this._debugOutput(`satisfied constraint rate: ${rate}`);\n                    sol.setProblem(this._pro);\n                    if (this.foundSolution(sol, rate)) {\n                        success = true;\n                        break;\n                    }\n                    if (this._targetDeg ?? 1 <= cur) {\n                        this._debugOutput(\"stop: current degree is above the target\");\n                        success = true;\n                        break;\n                    }\n                }\n            }\n        }\n        sol.apply(); // Despite the failures, the best assignment so far is applied for now.\n        return success;\n    }\n}\nclass $047eed9e2a62e006$var$Cluster {\n    static nextInt(max) {\n        return Math.floor(Math.random() * Math.floor(max));\n    }\n    #x;\n    #index = 0;\n    #maxNeurons = [];\n    _neurons = [];\n    constructor(x){\n        this.#x = x;\n        for (const v of x.domain())this._neurons.push(new $047eed9e2a62e006$var$Neuron(v));\n        this.#setActivity($047eed9e2a62e006$var$Cluster.nextInt(this._neurons.length));\n    }\n    #setActivity(index) {\n        for (const n of this._neurons)n._isActive = false;\n        this._neurons[index]._isActive = true;\n        this.#index = index;\n    }\n    applyToVariable() {\n        this.#x.assign(this._neurons[this.#index]._value);\n    }\n    get(index) {\n        return this._neurons[index];\n    }\n    neurons() {\n        return this._neurons;\n    }\n    // Turn on the node with the largest input.\n    setActivityMaximumInput() {\n        this.#maxNeurons.length = 0;\n        let max = Number.NEGATIVE_INFINITY;\n        let alreadyOn = false;\n        for(let i = 0; i < this._neurons.length; ++i){\n            const input = this._neurons[i].getInput();\n            if (max <= input) {\n                if (max < input) {\n                    max = input;\n                    this.#maxNeurons.length = 0;\n                    alreadyOn = false;\n                }\n                this.#maxNeurons.push(i);\n                if (this.#index === i) alreadyOn = true;\n            }\n        }\n        if (alreadyOn || this.#maxNeurons.length === 0) return false;\n        this.#setActivity(this.#maxNeurons[$047eed9e2a62e006$var$Cluster.nextInt(this.#maxNeurons.length)]);\n        return true;\n    }\n    size() {\n        return this._neurons.length;\n    }\n}\nclass $047eed9e2a62e006$var$Connection {\n    #first;\n    #second;\n    _weight;\n    // Order of neurons must be the same as the order of variables that the constraint has.\n    constructor(first, second = null){\n        this._weight = -1;\n        this.#first = first;\n        this.#first.addConnection(this);\n        this.#second = second;\n        if (this.#second) this.#second.addConnection(this);\n    }\n    getNeuron(self) {\n        if (self === this.#first) return this.#second;\n        if (self === this.#second) return this.#first;\n        return null;\n    }\n    refreshWeight() {\n        if (!this.#first._isActive || this.#second !== null && !this.#second._isActive) return;\n        this._weight += -1;\n    }\n}\nclass $047eed9e2a62e006$var$Neuron {\n    #conTemp = [];\n    #connections = [];\n    _value;\n    _isActive = false;\n    constructor(value){\n        this._value = value;\n    }\n    addConnection(c) {\n        this.#conTemp.push(c);\n    }\n    lockConnections() {\n        this.#connections = [\n            ...this.#conTemp\n        ];\n        this.#conTemp = null; // No longer being used.\n    }\n    getInput() {\n        let ret = 0;\n        for (const c of this.#connections){\n            const n = c.getNeuron(this); // If n is null, then the unary constraint.\n            ret += c._weight * (n === null || n._isActive ? 1 : 0);\n        }\n        return ret;\n    }\n}\n\n});\n\nparcelRegister(\"9BMnn\", function(module, exports) {\n\n$parcel$export(module.exports, \"CrispSRS3\", function () { return $73c03d91a2e9b25f$export$193930056f923a8; });\n/**\n * This class implements the SRS algorithm for crisp CSP.\n * The given crisp CSP is treated as the maximum CSP.\n * Similar to SRS 3, the repair algorithm searches for an assignment that\n * satisfies itself without reducing the number of satisfactions of its neighbors.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $73c03d91a2e9b25f$export$193930056f923a8 extends (0, $jWYxK.Solver) {\n    #isRandom = true;\n    #closedList = new Set();\n    #openList = new Set();\n    #nodes = [];\n    #neighborConstraints = [];\n    /**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */ constructor(p){\n        super(p);\n        for (const c of this._pro.constraints()){\n            this.#nodes.push(new $73c03d91a2e9b25f$var$TreeNode(c));\n            this.#neighborConstraints.push(null);\n        }\n    }\n    name() {\n        return \"SRS 3 for Crisp CSPs\";\n    }\n    /**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of falling into a local solution, but makes the solution unrepeatable.\n\t * @param flag If true, randomness is enabled.\n\t */ setRandomness(flag) {\n        this.#isRandom = flag;\n    }\n    #getNeighborConstraints(c) {\n        const i = c.index();\n        if (this.#neighborConstraints[i] === null) this.#neighborConstraints[i] = c.neighbors();\n        return this.#neighborConstraints[i];\n    }\n    #repair(c0) {\n        this._debugOutput(\"repair\");\n        const canList = new (0, $6nrDu.AssignmentList)();\n        let maxDiff = 0;\n        for (const x of c0){\n            const x_v = x.value(); // Save the value\n            let nowVio = 0;\n            for (const c of x)nowVio += 1 - c.isSatisfied();\n            out: for (const v of x.domain()){\n                if (x_v === v) continue;\n                x.assign(v);\n                if (c0.isSatisfied() !== 1) continue; // Assuming c0 improvement\n                let diff = nowVio;\n                for (const c of x){\n                    diff -= 1 - c.isSatisfied();\n                    if (diff < maxDiff) continue out; // If the improvement is less than the previous improvement, try the next variable.\n                }\n                if (diff > maxDiff) {\n                    maxDiff = diff;\n                    canList.clear();\n                    canList.addVariable(x, v);\n                } else if (maxDiff !== 0) canList.addVariable(x, v);\n            }\n            x.assign(x_v); // Restore the value\n        }\n        if (canList.size() > 0) {\n            const a = this.#isRandom ? canList.random() : canList.at(0);\n            a.apply();\n            this._debugOutput(\"\t\" + a);\n            return true;\n        }\n        return false;\n    }\n    #shrink(node, c_stars) {\n        const temp = [];\n        let cur = node;\n        while(true){\n            cur = cur.parent();\n            temp.length = 0;\n            cur.getDescendants(temp);\n            cur.clear();\n            for (const n of c_stars){\n                this.#openList.delete(n);\n                this.#closedList.delete(n);\n            }\n            if (c_stars.delete(cur)) break;\n            this.#openList.add(cur);\n            if (cur.parent() !== null && !this.#repair(cur.parent().getObject())) break;\n        }\n    }\n    #spread(n) {\n        this._debugOutput(\"spread\");\n        this.#closedList.add(n);\n        for (const c of this.#getNeighborConstraints(n.getObject())){\n            const tnc = this.#nodes[c.index()];\n            if (!this.#closedList.has(tnc) && !this.#openList.has(tnc)) {\n                tnc.clear(); // Because of its reuse, it may have had children when it was used before.\n                n.add(tnc);\n                this.#openList.add(tnc);\n            }\n        }\n    }\n    #srs(c_stars) {\n        this._debugOutput(\"srs\");\n        const endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        let iterCount = 0;\n        this.#closedList.clear();\n        this.#openList.clear();\n        for (const n of c_stars)this.#openList.add(n);\n        const p = this._pro;\n        while(c_stars.size && this.#openList.size){\n            if ((this._targetDeg ?? 1) <= p.satisfiedConstraintRate()) {\n                this._debugOutput(\"stop: current degree is above the target\");\n                return true;\n            }\n            if (this._iterLimit && this._iterLimit < iterCount++) {\n                this._debugOutput(\"stop: number of iterations has reached the limit\");\n                return false;\n            }\n            if (endTime < Date.now()) {\n                this._debugOutput(\"stop: time limit has been reached\");\n                return false;\n            }\n            const node = this.#openList.values().next().value;\n            this.#openList.delete(node);\n            if (this.#repair(node.getObject())) {\n                if (!c_stars.delete(node)) {\n                    if (node.parent() !== null && this.#repair(node.parent().getObject())) this.#shrink(node, c_stars);\n                    else this.#spread(node);\n                }\n            } else this.#spread(node);\n        }\n        return false;\n    }\n    exec() {\n        const vcs = this._pro.violatingConstraints();\n        const c_stars = new Set();\n        for (const c of vcs){\n            const tnc = this.#nodes[c.index()];\n            c_stars.add(tnc);\n        }\n        if (this.#srs(c_stars)) return true;\n        return c_stars.size === 0;\n    }\n}\nclass $73c03d91a2e9b25f$var$TreeNode {\n    #children = [];\n    #parent;\n    #obj;\n    constructor(obj){\n        this.#parent = null;\n        this.#obj = obj;\n    }\n    add(tn) {\n        tn.#parent = this;\n        this.#children.push(tn);\n    }\n    clear() {\n        for (const tn of this.#children)tn.#parent = null;\n        this.#children.length = 0;\n    }\n    getDescendants(tns) {\n        tns.push(this);\n        for (const tn of this.#children)tn.getDescendants(tns);\n    }\n    getObject() {\n        return this.#obj;\n    }\n    parent() {\n        return this.#parent;\n    }\n}\n\n});\n\nparcelRegister(\"9NLdx\", function(module, exports) {\n\n$parcel$export(module.exports, \"FuzzyForwardChecking\", function () { return $40a3d027300d875f$export$2d94cf9ddb103458; });\n/**\n * This class implements the forward checking method for fuzzy CSP.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n * Each variable must have its own domain because it hides domain elements as branch pruning.\n * Forward checking is also performed for problems with polynomial constraints.\n *\n * @author Takuto Yanagida\n * @version 2024-10-23\n */ \nvar $dldqc = parcelRequire(\"dldqc\");\n\nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $5V057 = parcelRequire(\"5V057\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $40a3d027300d875f$export$2d94cf9ddb103458 extends (0, $jWYxK.Solver) {\n    static CONTINUE = 0;\n    static TERMINATE = 1;\n    #xs;\n    #sol = new (0, $6nrDu.AssignmentList)();\n    #relCons = [];\n    #solWorstDeg = 0;\n    #iterCount = 0;\n    #endTime = 0;\n    #useMRV = false;\n    #degInc = 0;\n    #sequence;\n    #unaryCons;\n    #checkedCons;\n    #pruneIntensively = false;\n    /**\n\t * Generates the solver given a fuzzy constraint satisfaction problem.\n\t * @param p A fuzzy problem.\n\t * @param worstSatisfactionDegree Worst satisfaction degree.\n\t */ constructor(p, worstSatisfactionDegree = null){\n        super(p);\n        this.#xs = [\n            ...this._pro.variables()\n        ];\n        this.#sequence = new Array(this._pro.variableSize());\n        this.#initializeRelatedConstraintTable();\n        this.#checkedCons = new Array(this._pro.constraintSize());\n        const temp = [];\n        for (const c of this._pro.constraints())if (c.size() === 1) temp.push(c);\n        this.#unaryCons = [\n            ...temp\n        ]; // To make it even if it is empty.\n        if (worstSatisfactionDegree) this.#solWorstDeg = worstSatisfactionDegree;\n    }\n    name() {\n        return \"Forward Checking for Fuzzy CSPs\";\n    }\n    /**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */ setUsingMinimumRemainingValuesHeuristics(flag) {\n        this.#useMRV = flag;\n    }\n    /**\n\t * If a solution is found and the search continues, it specifies how much the worst constraint satisfaction degree should be increased.\n\t * @param degree Increasing constraint satisfaction degree.\n\t */ setIncrementStepOfWorstSatisfactionDegree(degree) {\n        this.#degInc = degree;\n    }\n    /**\n\t * Specifies whether or not to intensively prune branches when the problem contains 3- or n-ary constraints.\n\t * Depending on the problem, intensive pruning may increase processing time.\n\t * Default is false.\n\t * @param flag Whether or not to intensively prune branches.\n\t */ setIntensivePruning(flag) {\n        this.#pruneIntensively = flag;\n    }\n    /**\n\t * Constraint satisfaction degree is set as an achievement goal that serves as a condition for stopping the solver.\n\t * The solver stops as successful when the specified degree is reached or exceeded.\n\t * The default (unset) is 0.8.\n\t * @param rate Degree. null indicates not set.\n\t */ setTargetRate(rate = null) {\n        this._targetDeg = rate;\n        if (this._targetDeg === null) this.#solWorstDeg = 0;\n        else {\n            // Find the worstSatisfactionDegree_ that is slightly smaller than the targetDegree_.\n            let e = Number.MIN_VALUE;\n            this.#solWorstDeg = this._targetDeg - e;\n            while(this.#solWorstDeg >= this._targetDeg){\n                e *= 10;\n                this.#solWorstDeg = this._targetDeg - e;\n            }\n        }\n    }\n    // Initializes a table that caches constraints between two variables.\n    #initializeRelatedConstraintTable() {\n        this.#relCons = [];\n        for(let j = 0; j < this.#xs.length; ++j){\n            this.#relCons.push(new Array(this.#xs.length));\n            for(let i = 0; i < this.#xs.length; ++i)if (i < j) this.#relCons[j][i] = this._pro.constraintsBetween(this.#xs[i], this.#xs[j]);\n        }\n    }\n    // Retrieves an array of constraints from a table that caches constraints between two variables.\n    #getConstraintsBetween(vi_index, vj_index) {\n        if (vi_index < vj_index) return this.#relCons[vj_index][vi_index];\n        return this.#relCons[vi_index][vj_index];\n    }\n    // Prune elements of the domain that make the unary constraint worse than the current worst degree.\n    #pruneUnaryConstraints() {\n        for (const c of this.#unaryCons){\n            const x = c.at(0);\n            const orgVal = x.value(); // Save the value.\n            const d = x.domain();\n            const dp = x.solverObject;\n            for(let i = 0, n = d.size(); i < n; ++i){\n                x.assign(d.at(i));\n                if (c.satisfactionDegree() <= this.#solWorstDeg) dp.hide(i, -1); // Here's a branch pruning!\n            }\n            x.assign(orgVal); // Restore the value.\n            if (dp.isEmpty()) return false;\n        }\n        return true;\n    }\n    // Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\n    #checkForwardConsistency(level, vi, c) {\n        const d_i = vi.domain();\n        const dp_i = vi.solverObject;\n        for(let i = 0, n = d_i.size(); i < n; ++i){\n            if (dp_i.isValueHidden(i)) continue;\n            vi.assign(d_i.at(i));\n            if (c.satisfactionDegree() <= this.#solWorstDeg) dp_i.hide(i, level); // Here's a branch pruning!\n        }\n        vi.clear();\n        return !dp_i.isEmpty(); // Succeeds if the domain di of the future variable vi is not empty.\n    }\n    // Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there are two unassigned variables in the scope of the constraint).\n    #checkForwardConsistency2(level, vi, c) {\n        const d_i = vi.domain();\n        const dp_i = vi.solverObject;\n        let vj = null;\n        for (const x of c)if (x.isEmpty() && x !== vi) {\n            vj = x;\n            break;\n        }\n        const d_j = vj.domain();\n        const dp_j = vj.solverObject;\n        loop_i: for(let i = 0, ni = d_i.size(); i < ni; ++i){\n            if (dp_i.isValueHidden(i)) continue;\n            vi.assign(d_i.at(i)); // Tentative assignment to vi\n            for(let j = 0, nj = d_j.size(); j < nj; ++j){\n                if (dp_j.isValueHidden(j)) continue;\n                vj.assign(d_j.at(j)); // Tentative assignment to vj\n                const s = c.satisfactionDegree();\n                if (s > this.#solWorstDeg) continue loop_i; // Tentative assignment to vi was OK -> next tentative assignment.\n            }\n            dp_i.hide(i, level); // It is not a solution when it is 'smaller than or equals'.\n        }\n        vj.clear();\n        vi.clear();\n        return !dp_i.isEmpty(); // Succeeds if the domain di of the future variable vi is not empty.\n    }\n    // Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there are three unassigned variables in the scope of the constraint).\n    #checkForwardConsistency3(level, vi, c) {\n        const d_i = vi.domain();\n        const dp_i = vi.solverObject;\n        let vj = null;\n        let vk = null;\n        for (const x of c)if (x.isEmpty() && x !== vi) {\n            if (vj === null) vj = x;\n            else {\n                vk = x;\n                break;\n            }\n        }\n        const d_j = vj.domain();\n        const d_k = vk.domain();\n        const dp_j = vj.solverObject;\n        const dp_k = vk.solverObject;\n        loop_i: for(let i = 0, ni = d_i.size(); i < ni; ++i){\n            if (dp_i.isValueHidden(i)) continue;\n            vi.assign(d_i.at(i)); // Tentative assignment to vi\n            for(let j = 0, nj = d_j.size(); j < nj; ++j){\n                if (dp_j.isValueHidden(j)) continue;\n                vj.assign(d_j.at(j)); // Tentative assignment to vj\n                for(let k = 0, nk = d_k.size(); k < nk; ++k){\n                    if (dp_k.isValueHidden(k)) continue;\n                    vk.assign(d_k.at(k)); // Tentative assignment to vk\n                    const s = c.satisfactionDegree();\n                    if (s > this.#solWorstDeg) continue loop_i; // Tentative assignment to vi was OK -> next tentative assignment.\n                }\n            }\n            dp_i.hide(i, level); // It is not a solution when it is 'smaller than or equals'.\n        }\n        vk.clear();\n        vj.clear();\n        vi.clear();\n        return !dp_i.isEmpty(); // Succeeds if the domain di of the future variable vi is not empty.\n    }\n    // In the case of polynomial constraints and when there are four or more unassigned variables, all combinations of assignments of unassigned variables are examined and pruned.\n    #checkForwardConsistencyN(level, v_i, c, emptySize) {\n        const d_i = v_i.domain();\n        const dp_i = v_i.solverObject;\n        const emp = new Array(emptySize - 1);\n        let j = 0;\n        for (const x of c)if (x.isEmpty() && x !== v_i) emp[j++] = x;\n        const indexes = new Array(emp.length);\n        loop_i: for(let i = 0, n = d_i.size(); i < n; ++i){\n            if (dp_i.isValueHidden(i)) continue;\n            v_i.assign(d_i.at(i)); // Tentative assignment to vi\n            indexes.fill(0);\n            comLoop: while(true){\n                let hidden = false;\n                for(let k = 0; k < emp.length; ++k){\n                    const d_k = emp[k].domain();\n                    const dp_k = emp[k].solverObject;\n                    if (dp_k.isValueHidden(indexes[k])) {\n                        hidden = true;\n                        break;\n                    }\n                    emp[k].assign(d_k.at(indexes[k]));\n                }\n                if (!hidden) {\n                    const s = c.satisfactionDegree();\n                    if (s > this.#solWorstDeg) continue loop_i; // Tentative assignment to vi was OK -> next tentative assignment.\n                }\n                for(let k = 0; k < emp.length; ++k){\n                    indexes[k] += 1;\n                    if (indexes[k] < emp[k].domain().size()) break;\n                    indexes[k] = 0;\n                    if (k === emp.length - 1) break comLoop;\n                }\n            }\n            dp_i.hide(i, level);\n        }\n        for (const x of emp)x.clear();\n        v_i.clear();\n        return !dp_i.isEmpty(); // Succeeds if the domain di of the future variable vi is not empty.\n    }\n    // Checks for possible assignment to a future variable from the current variable assignment.\n    #checkForward(level, index) {\n        for (const x_i of this.#xs){\n            if (!x_i.isEmpty()) continue; // If it is a past or present variable.\n            const cs = this.#getConstraintsBetween(index, x_i.index());\n            for (const c of cs){\n                const emptySize = c.emptyVariableSize();\n                if (emptySize === 1) {\n                    if (!this.#checkForwardConsistency(level, x_i, c)) return false;\n                } else if (this.#pruneIntensively) {\n                    if (emptySize === 2) {\n                        if (!this.#checkForwardConsistency2(level, x_i, c)) return false;\n                    } else if (emptySize === 3) {\n                        if (!this.#checkForwardConsistency3(level, x_i, c)) return false;\n                    } else if (emptySize > 3) {\n                        if (!this.#checkForwardConsistencyN(level, x_i, c, emptySize)) return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    // Checks to see if the current variable assignment makes the degree of the past variable worse than the current worst degree.\n    #checkBackwardConsistency(vc) {\n        this.#checkedCons.fill(false); // Reuse.\n        for(let i = 0; i < this.#xs.length; ++i){\n            const x_i = this.#xs[i];\n            if (x_i === vc || x_i.isEmpty()) continue; // If it is a future variable or a present variable.\n            const cs = this.#getConstraintsBetween(vc.index(), i);\n            for (const c of cs){\n                if (this.#checkedCons[c.index()]) continue; // Because of the possibility of duplication in polynomial constraints\n                const s = c.satisfactionDegree();\n                if (s !== (0, $dldqc.Constraint).UNDEFINED && s <= this.#solWorstDeg) return false;\n                this.#checkedCons[c.index()] = true;\n            }\n        }\n        return true;\n    }\n    #refresh() {\n        for(let i = 0; i < this.#sequence.length; ++i){\n            const index_x_i = this.#sequence[i].index();\n            for(let j = i + 1; j < this.#sequence.length; ++j){\n                const x_j = this.#sequence[j];\n                const cs = this.#getConstraintsBetween(index_x_i, x_j.index());\n                for (const c of cs){\n                    const orgVal = x_j.value();\n                    const d_j = x_j.domain();\n                    const dp_j = x_j.solverObject;\n                    for(let k = 0, n = d_j.size(); k < n; ++k){\n                        if (dp_j.isValueHidden(k)) continue;\n                        x_j.assign(d_j.at(k));\n                        if (c.satisfactionDegree() <= this.#solWorstDeg) dp_j.hide(k, i); // Here's a branch pruning!\n                    }\n                    x_j.assign(orgVal);\n                }\n            }\n        }\n    }\n    // Returns the index of the smallest domain variable.\n    #indexOfVariableWithMRV() {\n        let index = 0;\n        let size = Number.MAX_VALUE;\n        for(let i = 0; i < this.#xs.length; ++i){\n            const x = this.#xs[i];\n            if (!x.isEmpty()) continue;\n            const d = x.domain();\n            const s = d.size() - x.solverObject.hiddenSize();\n            if (s < size) {\n                size = s;\n                index = i;\n            }\n        }\n        return index;\n    }\n    // Performs search one variable at a time.\n    #branch(level) {\n        let bc = $40a3d027300d875f$export$2d94cf9ddb103458.CONTINUE;\n        const xc_index = this.#useMRV ? this.#indexOfVariableWithMRV() : level;\n        const xc = this.#xs[xc_index];\n        const d = xc.domain();\n        const dp = xc.solverObject;\n        this.#sequence[level] = xc;\n        for(let i = 0, n = d.size(); i < n; ++i){\n            if (dp.isValueHidden(i)) continue;\n            if (this._iterLimit && this._iterLimit < this.#iterCount++ || this.#endTime < Date.now()) {\n                bc = $40a3d027300d875f$export$2d94cf9ddb103458.TERMINATE; // Search terminated due to restrictions.\n                break;\n            }\n            xc.assign(d.at(i));\n            for (const x of this.#xs)x.solverObject.reveal(level);\n            if (!this.#checkBackwardConsistency(xc)) continue;\n            if (!this.#checkForward(level, xc_index)) continue;\n            const nextLevel = level + 1;\n            bc = nextLevel === this.#xs.length - 1 ? this.#branchLast(nextLevel) : this.#branch(nextLevel);\n            if (bc === $40a3d027300d875f$export$2d94cf9ddb103458.TERMINATE) break;\n        }\n        if (bc === $40a3d027300d875f$export$2d94cf9ddb103458.CONTINUE) for (const x of this.#xs)x.solverObject.reveal(level);\n        xc.clear();\n        return bc;\n    }\n    // Performs search on the last variable.\n    #branchLast(level) {\n        let bc = $40a3d027300d875f$export$2d94cf9ddb103458.CONTINUE;\n        const xc = this.#xs[this.#useMRV ? this.#indexOfVariableWithMRV() : level];\n        const d = xc.domain();\n        const dp = xc.solverObject;\n        this.#sequence[level] = xc;\n        for(let i = 0, n = d.size(); i < n; ++i){\n            if (dp.isValueHidden(i)) continue;\n            if (this._iterLimit && this._iterLimit < this.#iterCount++ || this.#endTime < Date.now()) {\n                bc = $40a3d027300d875f$export$2d94cf9ddb103458.TERMINATE; // Search terminated due to restrictions.\n                break;\n            }\n            xc.assign(d.at(i));\n            const deg = this._pro.worstSatisfactionDegree();\n            if (deg > this.#solWorstDeg) {\n                this.#solWorstDeg = deg;\n                this.#sol.setProblem(this._pro);\n                bc = $40a3d027300d875f$export$2d94cf9ddb103458.TERMINATE;\n                if (this._targetDeg !== null && this._targetDeg <= this.#solWorstDeg) break;\n                this.#pruneUnaryConstraints();\n                this.#refresh();\n            }\n        }\n        xc.clear();\n        return bc;\n    }\n    // Do search.\n    exec() {\n        this.#endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        this.#iterCount = 0;\n        for (const x of this.#xs)x.solverObject = new (0, $5V057.DomainPruner)(x.domain().size()); // Generation of domain pruners.\n        this._pro.clearAllVariables();\n        if (!this.#pruneUnaryConstraints()) return false; // Since _worstSatisfactionDegree_ has been updated, call this function.\n        let success = false;\n        while(true){\n            const bc = this.#branch(0);\n            if (bc === $40a3d027300d875f$export$2d94cf9ddb103458.TERMINATE) {\n                if (this._iterLimit && this._iterLimit < this.#iterCount++) {\n                    this._debugOutput(\"stop: number of iterations has reached the limit\");\n                    break;\n                }\n                if (this.#endTime < Date.now()) {\n                    this._debugOutput(\"stop: time limit has been reached\");\n                    break;\n                }\n            }\n            if (this.#sol.isEmpty()) break;\n            this._debugOutput(`\\tfound a solution: ${this.#solWorstDeg}`);\n            if (this.foundSolution(this.#sol, this.#solWorstDeg)) {\n                success = true;\n                break;\n            }\n            if (this._targetDeg === null) {\n                success = true;\n                this.#solWorstDeg += this.#degInc; // Find the next solution within the limit.\n            } else if (this._targetDeg <= this.#solWorstDeg) {\n                this._debugOutput(\"stop: current degree is above the target\");\n                success = true;\n                break;\n            }\n            for (const x of this.#xs)x.solverObject.revealAll();\n        }\n        this.#sol.apply();\n        for (const x of this.#xs)x.solverObject = null; // Delete branch pruner\n        return success;\n    }\n}\n\n});\n\nparcelRegister(\"kYz6B\", function(module, exports) {\n\n$parcel$export(module.exports, \"FuzzyForwardCheckingBc\", function () { return $6186101130384aed$export$532d5536583284b8; });\n/**\n * This class implements the forward checking method for fuzzy CSPs that contain only binary constraints.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n *\n * @author Takuto Yanagida\n * @version 2024-10-23\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $5V057 = parcelRequire(\"5V057\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $6186101130384aed$export$532d5536583284b8 extends (0, $jWYxK.Solver) {\n    static CONTINUE = 0;\n    static TERMINATE = 1;\n    #xs;\n    #sol = new (0, $6nrDu.AssignmentList)();\n    #relCons = [];\n    #solWorstDeg = 0;\n    #iterCount = 0;\n    #endTime = 0;\n    #useMRV = false;\n    #degInc = 0;\n    /**\n\t * Generates the solver given a fuzzy constraint satisfaction problem.\n\t * @param p A fuzzy problem.\n\t * @param worstSatisfactionDegree Worst satisfaction degree.\n\t */ constructor(p, worstSatisfactionDegree = null){\n        super(p);\n        this.#xs = [\n            ...this._pro.variables()\n        ];\n        this.#initializeRelatedConstraintTable();\n        this.#solWorstDeg = Math.max(0, p.worstSatisfactionDegree());\n        if (worstSatisfactionDegree) this.#solWorstDeg = worstSatisfactionDegree;\n    }\n    name() {\n        return \"Forward Checking for Fuzzy CSPs of Binary Constraints\";\n    }\n    /**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */ setUsingMinimumRemainingValuesHeuristics(flag) {\n        this.#useMRV = flag;\n    }\n    /**\n\t * If a solution is found and the search continues, it specifies how much the worst constraint satisfaction degree should be increased.\n\t * @param degree Increasing constraint satisfaction degree.\n\t */ setIncrementStepOfWorstSatisfactionDegree(degree) {\n        this.#degInc = degree;\n    }\n    /**\n\t * Constraint satisfaction degree is set as an achievement goal that serves as a condition for stopping the solver.\n\t * The solver stops as successful when the specified degree is reached or exceeded.\n\t * The default (unset) is 0.8.\n\t * @param rate Degree. null indicates not set.\n\t */ setTargetRate(rate = null) {\n        this._targetDeg = rate;\n        if (this._targetDeg === null) this.#solWorstDeg = 0;\n        else {\n            // Find the worstSatisfactionDegree_ that is slightly smaller than the targetDegree_.\n            let e = Number.MIN_VALUE;\n            this.#solWorstDeg = this._targetDeg - e;\n            while(this.#solWorstDeg >= this._targetDeg){\n                e *= 10;\n                this.#solWorstDeg = this._targetDeg - e;\n            }\n        }\n    }\n    // Initializes a table that caches constraints between two variables.\n    #initializeRelatedConstraintTable() {\n        this.#relCons = [];\n        for(let j = 0; j < this.#xs.length; ++j){\n            this.#relCons.push(new Array(this.#xs.length));\n            for(let i = 0; i < this.#xs.length; ++i)if (i < j) this.#relCons[j][i] = this._pro.constraintsBetween(this.#xs[i], this.#xs[j]);\n        }\n    }\n    // Retrieves an array of constraints from a table that caches constraints between two variables.\n    #getConstraintsBetween(vi_index, vj_index) {\n        if (vi_index < vj_index) return this.#relCons[vj_index][vi_index];\n        return this.#relCons[vi_index][vj_index];\n    }\n    // Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\n    #checkForwardConsistency(level, vi, c) {\n        const d_i = vi.domain();\n        const dp_i = vi.solverObject;\n        for(let i = 0, n = d_i.size(); i < n; ++i){\n            if (dp_i.isValueHidden(i)) continue;\n            vi.assign(d_i.at(i));\n            if (c.satisfactionDegree() <= this.#solWorstDeg) dp_i.hide(i, level); // Here's a branch pruning!\n        }\n        vi.clear();\n        return !dp_i.isEmpty(); // Succeeds if the domain di of the future variable vi is not empty.\n    }\n    // Checks for possible assignment to a future variable from the current variable assignment.\n    #checkForward(level, index) {\n        for (const x_i of this.#xs){\n            if (!x_i.isEmpty()) continue; // If it is a past or present variable.\n            const cs = this.#getConstraintsBetween(index, x_i.index());\n            for (const c of cs)if (c.size() === 2) {\n                if (!this.#checkForwardConsistency(level, x_i, c)) return false;\n            }\n        }\n        return true;\n    }\n    // Returns the index of the smallest domain variable.\n    #indexOfVariableWithMRV() {\n        let index = 0;\n        let size = Number.MAX_VALUE;\n        for(let i = 0; i < this.#xs.length; ++i){\n            const x = this.#xs[i];\n            if (!x.isEmpty()) continue;\n            const d = x.domain();\n            const s = d.size() - x.solverObject.hiddenSize();\n            if (s < size) {\n                size = s;\n                index = i;\n            }\n        }\n        return index;\n    }\n    // Performs search one variable at a time.\n    #branch(level) {\n        let bc = $6186101130384aed$export$532d5536583284b8.CONTINUE;\n        const xc_index = this.#useMRV ? this.#indexOfVariableWithMRV() : level;\n        const xc = this.#xs[xc_index];\n        const d = xc.domain();\n        const dp = xc.solverObject;\n        for(let i = 0, n = d.size(); i < n; ++i){\n            if (dp.isValueHidden(i)) continue;\n            if (this._iterLimit && this._iterLimit < this.#iterCount++ || this.#endTime < Date.now()) {\n                bc = $6186101130384aed$export$532d5536583284b8.TERMINATE; // Search terminated due to restrictions.\n                break;\n            }\n            xc.assign(d.at(i));\n            for (const x of this.#xs)x.solverObject.reveal(level);\n            if (!this.#checkForward(level, xc_index)) continue;\n            const nextLevel = level + 1;\n            bc = nextLevel === this.#xs.length - 1 ? this.#branchLast(nextLevel) : this.#branch(nextLevel);\n            if (bc === $6186101130384aed$export$532d5536583284b8.TERMINATE) break;\n        }\n        if (bc === $6186101130384aed$export$532d5536583284b8.CONTINUE) for (const v of this.#xs)v.solverObject.reveal(level);\n        xc.clear();\n        return bc;\n    }\n    // Performs search on the last variable.\n    #branchLast(level) {\n        let bc = $6186101130384aed$export$532d5536583284b8.CONTINUE;\n        const xc = this.#xs[this.#useMRV ? this.#indexOfVariableWithMRV() : level];\n        const d = xc.domain();\n        const dp = xc.solverObject;\n        for(let i = 0, n = d.size(); i < n; ++i){\n            if (dp.isValueHidden(i)) continue;\n            if (this._iterLimit && this._iterLimit < this.#iterCount++ || this.#endTime < Date.now()) {\n                bc = $6186101130384aed$export$532d5536583284b8.TERMINATE; // Search terminated due to restrictions.\n                break;\n            }\n            xc.assign(d.at(i));\n            const deg = this._pro.worstSatisfactionDegree();\n            if (deg > this.#solWorstDeg) {\n                this.#solWorstDeg = deg;\n                this.#sol.setProblem(this._pro);\n                bc = $6186101130384aed$export$532d5536583284b8.TERMINATE; // Search terminated due to restrictions.\n                if (this._targetDeg !== null && this._targetDeg <= this.#solWorstDeg) break;\n            }\n        }\n        xc.clear();\n        return bc;\n    }\n    // Do search.\n    exec() {\n        this.#endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        this.#iterCount = 0;\n        for (const x of this.#xs)x.solverObject = new (0, $5V057.DomainPruner)(x.domain().size()); // Generation of domain pruners.\n        this._pro.clearAllVariables();\n        const sol = new (0, $6nrDu.AssignmentList)();\n        let success = false;\n        while(true){\n            const bc = this.#branch(0);\n            if (bc === $6186101130384aed$export$532d5536583284b8.TERMINATE) {\n                if (this._iterLimit && this._iterLimit < this.#iterCount++) {\n                    this._debugOutput(\"stop: number of iterations has reached the limit\");\n                    break;\n                }\n                if (this.#endTime < Date.now()) {\n                    this._debugOutput(\"stop: time limit has been reached\");\n                    break;\n                }\n            }\n            if (this.#sol.isEmpty()) break;\n            sol.setAssignmentList(this.#sol);\n            this.#sol.clear(); // Clear it so that if the solution is not found in the next search, it will be known.\n            this._debugOutput(`\\tfound a solution: ${this.#solWorstDeg}`);\n            if (this.foundSolution(sol, this.#solWorstDeg)) {\n                success = true;\n                break;\n            }\n            if (this._targetDeg === null) {\n                success = true;\n                if (this.#solWorstDeg + this.#degInc > 1) break;\n                this.#solWorstDeg += this.#solWorstDeg + this.#degInc > 1 ? 0 : this.#degInc; // Find the next solution within the limit.\n            } else if (this._targetDeg <= this.#solWorstDeg) {\n                this._debugOutput(`stop: current degree is above the target`);\n                success = true;\n                break;\n            }\n            for (const x of this.#xs)x.solverObject.revealAll();\n        }\n        sol.apply();\n        for (const x of this.#xs)x.solverObject = null; // Delete branch pruner\n        return success;\n    }\n}\n\n});\n\nparcelRegister(\"2TCdz\", function(module, exports) {\n\n$parcel$export(module.exports, \"FlexibleLocalChanges\", function () { return $2781e45b3d984d73$export$c15ba88cf158f3d6; });\n/**\n * A class that implements the flexible local changes method.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $dldqc = parcelRequire(\"dldqc\");\n\nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $2781e45b3d984d73$export$c15ba88cf158f3d6 extends (0, $jWYxK.Solver) {\n    static #setPlusElement(s, e) {\n        const sn = new Set(s);\n        sn.add(e);\n        return sn;\n    }\n    static #setMinusElement(s, e) {\n        const sn = new Set(s);\n        sn.delete(e);\n        return sn;\n    }\n    #lt = 0;\n    #lb = 0;\n    #iterCount = 0;\n    #endTime = 0;\n    #globalReturn = 0;\n    constructor(p){\n        super(p);\n        this.#computeHighestAndLowestConsistencyDegree();\n    }\n    name() {\n        return \"Flexible Local Changes\";\n    }\n    #choose(x2, cr) {\n        const res = new Map();\n        for (const c of cr){\n            if (!c.isDefined()) continue;\n            for (const x of c)if (!res.has(x)) res.set(x, 1);\n            else res.set(x, (res.get(x) ?? 0) + 1);\n        }\n        const xs = [\n            ...x2\n        ];\n        xs.sort((o1, o2)=>{\n            let res1 = 0;\n            let res2 = 0;\n            if (res.has(o1)) res1 = res.get(o1) ?? 0;\n            if (res.has(o2)) res2 = res.get(o2) ?? 0;\n            if (res1 < res2) return 1;\n            if (res1 > res2) return -1;\n            return 0;\n        });\n        const ret = new Set();\n        for (const x of xs){\n            let remain = false;\n            for (const c of cr)if (c.isDefined()) {\n                remain = true;\n                break;\n            }\n            if (!remain) break;\n            x.clear();\n            ret.add(x);\n        }\n        return ret;\n    }\n    #computeHighestAndLowestConsistencyDegree() {\n        let low = 1;\n        let high = 0;\n        for (const x of this._pro.variables())for (const c of x){\n            const l = c.lowestConsistencyDegree();\n            const h = c.highestConsistencyDegree();\n            if (l < low) low = l;\n            if (h > high) high = h;\n        }\n        this.#lb = low;\n        this.#lt = high;\n    }\n    #flcRepair(X1, X2, xi, consX1xi, consX12, cr, rc) {\n        const X3p = this.#choose(X2, cr);\n        const X1p = $2781e45b3d984d73$export$c15ba88cf158f3d6.#setPlusElement(X1, xi);\n        const X2p = X2.difference(X3p);\n        return this.#flcVariables(X1p, X2p, X3p, consX1xi, Math.min(consX12, consX1xi), rc);\n    }\n    #flcVariable(X1, X2, xi, consX1, consX12, rc) {\n        let bestCons = this.#lb;\n        if (xi.domain().size() === 0) return bestCons;\n        let bestX2 = (0, $6nrDu.AssignmentList).fromVariables(X2);\n        let bestDij = xi.domain().at(0);\n        const x2Store = (0, $6nrDu.AssignmentList).fromVariables(X2);\n        for(let j = 0; j < xi.domain().size() && bestCons < consX12; ++j){\n            const dij = xi.domain().at(j);\n            xi.assign(dij);\n            const consX1_xi = Math.min(consX1, this.#testX1(X1, xi, bestCons, rc));\n            if (consX1_xi > Math.max(bestCons, rc)) {\n                const crNew = new Set();\n                const consX12_xi = Math.min(Math.min(consX1_xi, consX12), this.#testX12(X1, X2, xi, consX1_xi, consX12, crNew));\n                if (consX12_xi > bestCons) {\n                    bestCons = consX12_xi;\n                    bestDij = dij;\n                    bestX2 = (0, $6nrDu.AssignmentList).fromVariables(X2);\n                }\n                if (crNew.size) {\n                    const repairCons = this.#flcRepair(X1, X2, xi, consX1_xi, consX12, crNew, Math.max(rc, bestCons));\n                    if (this.#globalReturn !== -1) return bestCons;\n                    if (repairCons > bestCons) {\n                        bestCons = repairCons;\n                        bestDij = dij;\n                        bestX2 = (0, $6nrDu.AssignmentList).fromVariables(X2);\n                    }\n                    x2Store.apply();\n                }\n            }\n        }\n        bestX2.apply();\n        xi.assign(bestDij);\n        return bestCons;\n    }\n    #flcVariables(X1, X2, X3, consX1, consX12, rc) {\n        this._debugOutput(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n        // Success if the degree improves from specified\n        if (this._targetDeg !== null && this._targetDeg <= this._pro.worstSatisfactionDegree()) {\n            this._debugOutput(\"stop: current degree is above the target\");\n            this.#globalReturn = 1;\n            return consX12;\n        }\n        // Failure if repeated a specified number\n        if (this._iterLimit && this._iterLimit < this.#iterCount++) {\n            this._debugOutput(\"stop: number of iterations has reached the limit\");\n            this.#globalReturn = 0;\n            return consX12;\n        }\n        // Failure if time limit is exceeded\n        if (this.#endTime < Date.now()) {\n            this._debugOutput(\"stop: time limit has been reached\");\n            this.#globalReturn = 0;\n            return consX12;\n        }\n        if (X3.size === 0) return consX12;\n        const xi = X3.values().next().value;\n        const consX12xi = this.#flcVariable(X1, X2, xi, consX1, consX12, rc);\n        if (this.#globalReturn !== -1) return consX12;\n        if (consX12xi < rc) return this.#lb;\n        X2 = $2781e45b3d984d73$export$c15ba88cf158f3d6.#setPlusElement(X2, xi);\n        X3 = $2781e45b3d984d73$export$c15ba88cf158f3d6.#setMinusElement(X3, xi);\n        return this.#flcVariables(X1, X2, X3, consX1, consX12xi, rc);\n    }\n    #initTest(X, cr) {\n        const cs = new Set();\n        for (const x of X)for (const c of x)cs.add(c); // All variables in X have been assigned.\n        let ret = 1;\n        for (const c of cs){\n            const sd = c.satisfactionDegree();\n            if (sd === (0, $dldqc.Constraint).UNDEFINED) continue;\n            if (sd < ret) ret = sd;\n        }\n        for (const c of this._pro.constraints()){\n            const cd = c.lowestConsistencyDegree();\n            if (cd < this.#lt) cr.add(c);\n        }\n        return ret;\n    }\n    #testX1(X1, xi, bestCons, rc) {\n        let cd = 1;\n        const cs = new Set();\n        for (const x of X1){\n            const temp = this._pro.constraintsBetween(x, xi);\n            for (const c of temp)cs.add(c);\n        }\n        for (const c of cs){\n            const d = c.satisfactionDegree();\n            if (d === (0, $dldqc.Constraint).UNDEFINED) continue;\n            if (d < cd) cd = d;\n            // If it is determined that a better solution than the current solution cannot be obtained\n            if (cd <= bestCons || cd <= rc) return cd;\n        }\n        return cd;\n    }\n    #testX12(X1, X2, xi, consX1xi, consX12, cr) {\n        let csd = 1;\n        const cs = new Set();\n        for (const x of X1){\n            const temp = this._pro.constraintsBetween(x, xi);\n            for (const c of temp)cs.add(c);\n        }\n        for (const x of X2){\n            const temp = this._pro.constraintsBetween(x, xi);\n            for (const c of temp)cs.add(c);\n        }\n        for (const c of cs){\n            const sd = c.satisfactionDegree();\n            if (sd === (0, $dldqc.Constraint).UNDEFINED) continue;\n            if (sd < csd) csd = sd;\n        }\n        for (const c of cs){\n            const sd = c.satisfactionDegree();\n            if (sd === (0, $dldqc.Constraint).UNDEFINED) continue;\n            if (sd < consX1xi || sd < consX12) cr.add(c);\n        }\n        return csd;\n    }\n    exec() {\n        this.#endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        this.#iterCount = 0;\n        this.#globalReturn = -1;\n        const wsd = this._pro.worstSatisfactionDegree();\n        if (this._pro.emptyVariableSize() === 0) this._pro.clearAllVariables();\n        const X1 = new Set();\n        const X2 = new Set(); // Currently assigned variables.\n        const X3 = new Set(); // Currently unassigned variables.\n        for (const x of this._pro.variables())(!x.isEmpty() ? X2 : X3).add(x);\n        const cr = new Set();\n        const initCons = this.#initTest(X2, cr);\n        let rc;\n        let initSol = null;\n        if (X3.size === 0) {\n            rc = initCons;\n            initSol = (0, $6nrDu.AssignmentList).fromVariables(X2);\n        } else rc = this.#lb;\n        const X3p = this.#choose(X2, cr).union(X3);\n        const X2p = X2.difference(X3p);\n        let result = this.#flcVariables(X1, X2p, X3p, this.#lt, this.#lt, rc);\n        if (result < rc) {\n            if (initSol !== null) initSol.apply();\n        }\n        result = this._pro.worstSatisfactionDegree();\n        return result > wsd && result > 0 && (this.#globalReturn !== 0 || this._targetDeg === null);\n    }\n}\n\n});\n\nparcelRegister(\"kpsHE\", function(module, exports) {\n\n$parcel$export(module.exports, \"FlexibleLocalChangesEx\", function () { return $161a1ffca4c8b498$export$f3429dcb0286bfee; });\n/**\n * A class that implements the flexible local changes method.\n * The implementation is optimized by converting recursive calls to loops.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $dldqc = parcelRequire(\"dldqc\");\n\nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $161a1ffca4c8b498$export$f3429dcb0286bfee extends (0, $jWYxK.Solver) {\n    static #setPlusElement(s, e) {\n        const sn = new Set(s);\n        sn.add(e);\n        return sn;\n    }\n    #lt = 0;\n    #lb = 0;\n    #iterCount = 0;\n    #endTime = 0;\n    #globalReturn = 0;\n    constructor(p){\n        super(p);\n        this.#computeHighestAndLowestConsistencyDegree();\n    }\n    name() {\n        return \"Flexible Local Changes Ex\";\n    }\n    #choose(x2, cr) {\n        const res = new Map();\n        for (const c of cr){\n            if (!c.isDefined()) continue;\n            for (const x of c)if (!res.has(x)) res.set(x, 1);\n            else res.set(x, (res.get(x) ?? 0) + 1);\n        }\n        const xs = [\n            ...x2\n        ];\n        xs.sort((o1, o2)=>{\n            let res1 = 0;\n            let res2 = 0;\n            if (res.has(o1)) res1 = res.get(o1) ?? 0;\n            if (res.has(o2)) res2 = res.get(o2) ?? 0;\n            if (res1 < res2) return 1;\n            if (res1 > res2) return -1;\n            return 0;\n        });\n        const ret = new Set();\n        for (const x of xs){\n            let remain = false;\n            for (const c of cr)if (c.isDefined()) {\n                remain = true;\n                break;\n            }\n            if (!remain) break;\n            x.clear();\n            ret.add(x);\n        }\n        return ret;\n    }\n    #computeHighestAndLowestConsistencyDegree() {\n        let low = 1;\n        let high = 0;\n        for (const x of this._pro.variables())for (const c of x){\n            const l = c.lowestConsistencyDegree();\n            const h = c.highestConsistencyDegree();\n            if (l < low) low = l;\n            if (h > high) high = h;\n        }\n        this.#lb = low;\n        this.#lt = high;\n    }\n    #flcRepair(X1, X2, xi, consX1xi, consX12, cr, rc) {\n        const X3p = this.#choose(X2, cr);\n        const X1p = $161a1ffca4c8b498$export$f3429dcb0286bfee.#setPlusElement(X1, xi);\n        const X2p = X2.difference(X3p);\n        return this.#flcVariables(X1p, X2p, X3p, consX1xi, Math.min(consX12, consX1xi), rc);\n    }\n    #flcVariable(X1, X2, xi, consX1, consX12, rc) {\n        let bestCons = this.#lb;\n        if (xi.domain().size() === 0) return bestCons;\n        let bestX2 = (0, $6nrDu.AssignmentList).fromVariables(X2);\n        let bestDij = xi.domain().at(0);\n        const x2Store = (0, $6nrDu.AssignmentList).fromVariables(X2);\n        for(let j = 0; j < xi.domain().size() && bestCons < consX12; ++j){\n            const dij = xi.domain().at(j);\n            xi.assign(dij);\n            const consX1_xi = Math.min(consX1, this.#testX1(X1, xi, bestCons, rc));\n            if (consX1_xi > Math.max(bestCons, rc)) {\n                const crNew = new Set();\n                const consX12_xi = Math.min(Math.min(consX1_xi, consX12), this.#testX12(X1, X2, xi, consX1_xi, consX12, crNew));\n                if (consX12_xi > bestCons) {\n                    bestCons = consX12_xi;\n                    bestDij = dij;\n                    bestX2 = (0, $6nrDu.AssignmentList).fromVariables(X2);\n                }\n                if (crNew.size) {\n                    const repairCons = this.#flcRepair(X1, X2, xi, consX1_xi, consX12, crNew, Math.max(rc, bestCons));\n                    if (this.#globalReturn !== -1) return bestCons;\n                    if (repairCons > bestCons) {\n                        bestCons = repairCons;\n                        bestDij = dij;\n                        bestX2 = (0, $6nrDu.AssignmentList).fromVariables(X2);\n                    }\n                    x2Store.apply();\n                }\n            }\n        }\n        bestX2.apply();\n        xi.assign(bestDij);\n        return bestCons;\n    }\n    #flcVariables(X1, X2, X3, consX1, consX12, rc) {\n        X2 = new Set(X2); // Clone\n        X3 = new Set(X3); // Clone\n        while(true){\n            this._debugOutput(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n            // Success if the degree improves from specified\n            if (this._targetDeg !== null && this._targetDeg <= this._pro.worstSatisfactionDegree()) {\n                this._debugOutput(\"stop: current degree is above the target\");\n                this.#globalReturn = 1;\n                return consX12;\n            }\n            // Failure if repeated a specified number\n            if (this._iterLimit && this._iterLimit < this.#iterCount++) {\n                this._debugOutput(\"stop: number of iterations has reached the limit\");\n                this.#globalReturn = 0;\n                return consX12;\n            }\n            // Failure if time limit is exceeded\n            if (this.#endTime < Date.now()) {\n                this._debugOutput(\"stop: time limit has been reached\");\n                this.#globalReturn = 0;\n                return consX12;\n            }\n            if (X3.size === 0) return consX12;\n            const xi = X3.values().next().value;\n            const consX12xi = this.#flcVariable(X1, X2, xi, consX1, consX12, rc);\n            if (this.#globalReturn !== -1) return consX12;\n            if (consX12xi < rc) return this.#lb;\n            X2.add(xi);\n            X3.delete(xi);\n            consX12 = consX12xi;\n        }\n    }\n    #initTest(X, cr) {\n        const cs = new Set();\n        for (const x of X)for (const c of x)cs.add(c); // All variables in X have been assigned.\n        let ret = 1;\n        for (const c of cs){\n            const sd = c.satisfactionDegree();\n            if (sd === (0, $dldqc.Constraint).UNDEFINED) continue;\n            if (sd < ret) ret = sd;\n        }\n        for (const c of this._pro.constraints()){\n            const cd = c.lowestConsistencyDegree();\n            if (cd < this.#lt) cr.add(c);\n        }\n        return ret;\n    }\n    #testX1(X1, xi, bestCons, rc) {\n        let cd = 1;\n        const cs = new Set();\n        for (const x of X1){\n            const temp = this._pro.constraintsBetween(x, xi);\n            for (const c of temp)cs.add(c);\n        }\n        for (const c of cs){\n            const d = c.satisfactionDegree();\n            if (d === (0, $dldqc.Constraint).UNDEFINED) continue;\n            if (d < cd) cd = d;\n            // If it is determined that a better solution than the current solution cannot be obtained\n            if (cd <= bestCons || cd <= rc) return cd;\n        }\n        return cd;\n    }\n    #testX12(X1, X2, xi, consX1xi, consX12, cr) {\n        let csd = 1;\n        const cs = new Set();\n        for (const x of X1){\n            const temp = this._pro.constraintsBetween(x, xi);\n            for (const c of temp)cs.add(c);\n        }\n        for (const x of X2){\n            const temp = this._pro.constraintsBetween(x, xi);\n            for (const c of temp)cs.add(c);\n        }\n        for (const c of cs){\n            const sd = c.satisfactionDegree();\n            if (sd === (0, $dldqc.Constraint).UNDEFINED) continue;\n            if (sd < csd) csd = sd;\n        }\n        for (const c of cs){\n            const sd = c.satisfactionDegree();\n            if (sd === (0, $dldqc.Constraint).UNDEFINED) continue;\n            if (sd < consX1xi || sd < consX12) cr.add(c);\n        }\n        return csd;\n    }\n    exec() {\n        this.#endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        this.#iterCount = 0;\n        this.#globalReturn = -1;\n        const wsd = this._pro.worstSatisfactionDegree();\n        if (this._pro.emptyVariableSize() === 0) this._pro.clearAllVariables();\n        const X1 = new Set();\n        const X2 = new Set(); // Currently assigned variables.\n        const X3 = new Set(); // Currently unassigned variables.\n        for (const x of this._pro.variables())(!x.isEmpty() ? X2 : X3).add(x);\n        const cr = new Set();\n        const initCons = this.#initTest(X2, cr);\n        let rc;\n        let initSol = null;\n        if (X3.size === 0) {\n            rc = initCons;\n            initSol = (0, $6nrDu.AssignmentList).fromVariables(X2);\n        } else rc = this.#lb;\n        const X3p = this.#choose(X2, cr).union(X3);\n        const X2p = X2.difference(X3p);\n        let result = this.#flcVariables(X1, X2p, X3p, this.#lt, this.#lt, rc);\n        if (result < rc) {\n            if (initSol !== null) initSol.apply();\n        }\n        result = this._pro.worstSatisfactionDegree();\n        return result > wsd && result > 0 && (this.#globalReturn !== 0 || this._targetDeg === null);\n    }\n}\n\n});\n\nparcelRegister(\"ksORy\", function(module, exports) {\n\n$parcel$export(module.exports, \"FuzzyBreakout\", function () { return $eae699847452ddd0$export$151ca5d788220218; });\n/**\n * Class implements a solver using the breakout method for fuzzy CSP.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $eae699847452ddd0$export$151ca5d788220218 extends (0, $jWYxK.Solver) {\n    #isRandom = true;\n    #ws;\n    #lastSolDeg = 0;\n    constructor(p){\n        super(p);\n        this.#ws = new Array(this._pro.constraintSize());\n        this.#ws.fill(1);\n    }\n    name() {\n        return \"Fuzzy Breakout\";\n    }\n    /**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of local solutions, but makes the solution unrepeatable.\n\t * @param flag Whether the randomness is enabled.\n\t */ setRandomness(flag) {\n        this.#isRandom = flag;\n    }\n    #findCandidates(worstXs, canList) {\n        let maxDiff = 0;\n        for (const x of worstXs){\n            const x_v = x.value(); // Save the value\n            let nowVio = 0;\n            for (const c of x)nowVio += (1 - c.satisfactionDegree()) * this.#ws[c.index()];\n            out: for (const v of x.domain()){\n                if (x_v === v) continue;\n                x.assign(v);\n                let diff = nowVio;\n                for (const c of x){\n                    diff -= (1 - c.satisfactionDegree()) * this.#ws[c.index()];\n                    // If the improvement is less than the previous improvement, try the next variable.\n                    if (diff < maxDiff) continue out;\n                }\n                if (diff > maxDiff) {\n                    maxDiff = diff;\n                    canList.clear();\n                    canList.addVariable(x, v);\n                } else if (maxDiff !== 0) canList.addVariable(x, v);\n            }\n            x.assign(x_v); // Restore the value.\n        }\n    }\n    #listWorstVariables(worstCs) {\n        const xs = new Set();\n        for (const c of worstCs)for (const x of c)xs.add(x);\n        return Array.from(xs);\n    }\n    exec() {\n        const endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        let iterCount = 0;\n        for (const x of this._pro.variables())if (x.isEmpty()) x.assign(x.domain().at(0));\n        const deg = this._pro.worstSatisfactionDegree();\n        const canList = new (0, $6nrDu.AssignmentList)();\n        const sol = new (0, $6nrDu.AssignmentList)();\n        while(true){\n            const [vcs, wsd] = this._pro.constraintsWithWorstSatisfactionDegree();\n            // Success if the degree improves from specified\n            if (this._targetDeg !== null && this._targetDeg <= wsd) {\n                this._debugOutput(\"stop: current degree is above the target\");\n                return true;\n            }\n            // Failure if repeated a specified number\n            if (this._iterLimit && this._iterLimit < iterCount++) {\n                this._debugOutput(\"stop: number of iterations has reached the limit\");\n                break;\n            }\n            // Failure if time limit is exceeded\n            if (endTime < Date.now()) {\n                this._debugOutput(\"stop: time limit has been reached\");\n                break;\n            }\n            this._debugOutput(\"worst satisfaction degree: \" + wsd);\n            if (this.#lastSolDeg < wsd) {\n                sol.setProblem(this._pro);\n                this.#lastSolDeg = wsd;\n                if (this.foundSolution(sol, this.#lastSolDeg)) return true;\n            }\n            this.#findCandidates(this.#listWorstVariables(vcs), canList);\n            if (0 < canList.size()) {\n                const a = this.#isRandom ? canList.random() : canList.at(0);\n                a.apply();\n                canList.clear();\n                this._debugOutput(\"\t\" + a);\n            } else {\n                for (const c of vcs)this.#ws[c.index()] += 1;\n                this._debugOutput(\"breakout\");\n            }\n        }\n        if (this._targetDeg === null && deg < this._pro.worstSatisfactionDegree()) return true;\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"8e260\", function(module, exports) {\n\n$parcel$export(module.exports, \"FuzzyGENET\", function () { return $5861f7a2b2a98532$export$6a3df005617df82a; });\n/**\n * This class implements fuzzy GENET.\n * CSPs and FCSPs (but only Binary (F)CSPs) is supported.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $5861f7a2b2a98532$export$6a3df005617df82a extends (0, $jWYxK.Solver) {\n    static nextInt(max) {\n        return Math.floor(Math.random() * Math.floor(max));\n    }\n    #clusters = [];\n    #connections = [];\n    #worstSatisfactionDegree;\n    constructor(p, worstSatisfactionDegree = 1){\n        super(p);\n        this.#worstSatisfactionDegree = worstSatisfactionDegree;\n    }\n    name() {\n        return \"Fuzzy GENET\";\n    }\n    #createNetwork(worstDeg) {\n        this._debugOutput(\"network creation start\");\n        const cons = [];\n        for (const x of this._pro.variables()){\n            if (x.domain().size() === 0) return false;\n            this.#clusters.push(new $5861f7a2b2a98532$var$Cluster(x));\n        }\n        for (const c of this._pro.constraints())if (c.size() === 1) {\n            const x = c.at(0);\n            const cl = this.#clusters[x.index()];\n            for(let i = 0; i < cl.size(); ++i){\n                const origV = x.value(); // Save the value.\n                x.assign(cl.get(i)._value);\n                if (c.satisfactionDegree() <= worstDeg) cons.push(new $5861f7a2b2a98532$var$Connection(c, cl.get(i)));\n                x.assign(origV); // Restore the value.\n            }\n        } else {\n            const x1 = c.at(0);\n            const x2 = c.at(1);\n            const cl_f = this.#clusters[x1.index()];\n            const cl_s = this.#clusters[x2.index()];\n            for(let i = 0; i < cl_f.size(); ++i){\n                const origV1 = x1.value(); // Save the value.\n                x1.assign(cl_f.get(i)._value);\n                for(let j = 0; j < cl_s.size(); ++j){\n                    const origV2 = x2.value(); // Save the value.\n                    x2.assign(cl_s.get(j)._value);\n                    if (c.satisfactionDegree() <= worstDeg) cons.push(new $5861f7a2b2a98532$var$Connection(c, cl_f.get(i), cl_s.get(j)));\n                    x2.assign(origV2); // Restore the value.\n                }\n                x1.assign(origV1); // Restore the value.\n            }\n        }\n        for (const cl of this.#clusters)for (const n of cl._neurons)n.lockConnections();\n        this.#connections = cons;\n        this._debugOutput(\"network creation complete\");\n        return true;\n    }\n    #shuffle(is) {\n        for(let i = is.length; i > 1; --i){\n            const j = $5861f7a2b2a98532$export$6a3df005617df82a.nextInt(i);\n            const temp = is[i - 1];\n            is[i - 1] = is[j];\n            is[j] = temp;\n        }\n        return is;\n    }\n    exec() {\n        if (!this.#createNetwork(this.#worstSatisfactionDegree)) throw new Error();\n        const endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        let iterCount = 0;\n        const sol = new (0, $6nrDu.AssignmentList)();\n        const order = [];\n        for(let i = 0; i < this.#clusters.length; ++i)order.push(i);\n        let cur = this._pro.worstSatisfactionDegree();\n        let success = false;\n        while(true){\n            if (this._iterLimit && this._iterLimit < iterCount++) {\n                this._debugOutput(\"stop: number of iterations has reached the limit\");\n                break;\n            }\n            if (endTime < Date.now()) {\n                this._debugOutput(\"stop: time limit has been reached\");\n                break;\n            }\n            let modified = false;\n            for (const i of this.#shuffle(order))if (this.#clusters[i].setActivityMaximumInput()) modified = true; // Turn on the node with the largest input in each cluster\n            if (!modified) {\n                for (const con of this.#connections)con.refreshWeight(); // Update weights for all connections\n                continue;\n            } else {\n                for (const clu of this.#clusters)clu.applyToVariable(); // Apply to variable\n                const d = this._pro.worstSatisfactionDegree();\n                if (cur < d) {\n                    cur = d;\n                    this._debugOutput(`worst satisfaction degree: ${d}`);\n                    sol.setProblem(this._pro);\n                    if (this.foundSolution(sol, d)) {\n                        success = true;\n                        break;\n                    }\n                    if (this._targetDeg === null) success = true;\n                    else if (this._targetDeg <= cur) {\n                        this._debugOutput(\"stop: current degree is above the target\");\n                        success = true;\n                        break;\n                    }\n                }\n            }\n        }\n        sol.apply();\n        return success;\n    }\n}\nclass $5861f7a2b2a98532$var$Cluster {\n    static nextInt(max) {\n        return Math.floor(Math.random() * Math.floor(max));\n    }\n    #x;\n    #index = 0;\n    #maxNeurons = [];\n    _neurons = [];\n    constructor(x){\n        this.#x = x;\n        for (const v of x.domain())this._neurons.push(new $5861f7a2b2a98532$var$Neuron(v));\n        this.#setActivity($5861f7a2b2a98532$var$Cluster.nextInt(this._neurons.length));\n    }\n    #setActivity(index) {\n        for (const n of this._neurons)n._isActive = false;\n        this._neurons[index]._isActive = true;\n        this.#index = index;\n    }\n    applyToVariable() {\n        this.#x.assign(this._neurons[this.#index]._value);\n    }\n    get(index) {\n        return this._neurons[index];\n    }\n    neurons() {\n        return this._neurons;\n    }\n    // Turn on the node with the largest input.\n    setActivityMaximumInput() {\n        this.#maxNeurons.length = 0;\n        let max = Number.NEGATIVE_INFINITY;\n        let alreadyOn = false;\n        for(let i = 0; i < this._neurons.length; ++i){\n            const input = this._neurons[i].getInput();\n            if (max <= input) {\n                if (max < input) {\n                    max = input;\n                    this.#maxNeurons.length = 0;\n                    alreadyOn = false;\n                }\n                this.#maxNeurons.push(i);\n                if (this.#index === i) alreadyOn = true;\n            }\n        }\n        if (alreadyOn || this.#maxNeurons.length === 0) return false;\n        this.#setActivity(this.#maxNeurons[$5861f7a2b2a98532$var$Cluster.nextInt(this.#maxNeurons.length)]);\n        return true;\n    }\n    size() {\n        return this._neurons.length;\n    }\n}\nclass $5861f7a2b2a98532$var$Connection {\n    #c;\n    #first;\n    #second;\n    _weight;\n    // Order of neurons must be the same as the order of variables that the constraint has.\n    constructor(c, first, second = null){\n        this._weight = c.satisfactionDegree() - 1;\n        this.#c = c;\n        this.#first = first;\n        this.#first.addConnection(this);\n        this.#second = second;\n        if (this.#second !== null) this.#second.addConnection(this);\n    }\n    getNeuron(self) {\n        if (self === this.#first) return this.#second;\n        if (self === this.#second) return this.#first;\n        return null;\n    }\n    refreshWeight() {\n        if (!this.#first._isActive || this.#second !== null && !this.#second._isActive) return;\n        if (this.#c.size() === 1) this._weight += this.#c.fuzzyRelation().satisfactionDegree(this.#first._value) - 1;\n        else this._weight += this.#c.fuzzyRelation().satisfactionDegree(this.#first._value, this.#second._value) - 1;\n    }\n}\nclass $5861f7a2b2a98532$var$Neuron {\n    #conTemp = [];\n    #connections = [];\n    _value;\n    _isActive = false;\n    constructor(value){\n        this._value = value;\n    }\n    addConnection(c) {\n        this.#conTemp.push(c);\n    }\n    lockConnections() {\n        this.#connections = [\n            ...this.#conTemp\n        ];\n        this.#conTemp = null; // No longer being used.\n    }\n    getInput() {\n        let ret = 0;\n        for (const c of this.#connections){\n            const n = c.getNeuron(this); // If n is null, then the unary constraint.\n            ret += c._weight * (n === null || n._isActive ? 1 : 0);\n        }\n        return ret;\n    }\n}\n\n});\n\nparcelRegister(\"dfK30\", function(module, exports) {\n\n$parcel$export(module.exports, \"SRS3\", function () { return $9d09a091b6ea2794$export$4bfabca73d1ccb59; });\n/**\n * This class implements the SRS algorithm.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $dldqc = parcelRequire(\"dldqc\");\n\nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $jWYxK = parcelRequire(\"jWYxK\");\nclass $9d09a091b6ea2794$export$4bfabca73d1ccb59 extends (0, $jWYxK.Solver) {\n    // Threshold for adopting a candidate assignment at repair time (should be 0 if strictly following SRS 3)\n    static REPAIR_THRESHOLD = 0;\n    #closedList = new Set();\n    #openList = new Set();\n    #nodes = [];\n    #neighborConstraints = [];\n    #c_stars = new Set();\n    #iterCount = 0;\n    #endTime = 0;\n    #isRandom = true;\n    constructor(p){\n        super(p);\n        for (const c of this._pro.constraints()){\n            this.#nodes.push(new $9d09a091b6ea2794$var$TreeNode(c));\n            this.#neighborConstraints.push(null);\n        }\n    }\n    name() {\n        return \"SRS 3\";\n    }\n    #getNeighborConstraints(c) {\n        const i = c.index();\n        if (this.#neighborConstraints[i] === null) this.#neighborConstraints[i] = c.neighbors();\n        return this.#neighborConstraints[i];\n    }\n    #repair(c0) {\n        this._debugOutput(\"repair\");\n        const canList = new (0, $6nrDu.AssignmentList)();\n        const minDeg0 = c0.satisfactionDegree(); // Target c0 should certainly be an improvement over this.\n        const min = this._pro.worstSatisfactionDegree(); // Lower bound of neighborhood constraints.\n        let maxDeg0 = c0.satisfactionDegree(); // Satisfaction degree of target c0 for the most improvement so far.\n        // If a candidate satisfying the condition is stronger than the previous candidates,\n        // it is replaced, and if no candidate is found until the end, it fails.\n        for (const x of c0){\n            const x_v = x.value(); // Save the value\n            out: for (const v of x.domain()){\n                if (x_v === v) continue;\n                x.assign(v);\n                const deg0 = c0.satisfactionDegree();\n                // If target c0 cannot be improved, the assignment is rejected.\n                if (minDeg0 > deg0 || maxDeg0 - deg0 > $9d09a091b6ea2794$export$4bfabca73d1ccb59.REPAIR_THRESHOLD) continue;\n                for (const c of x){\n                    if (c === c0) continue;\n                    const deg = c.satisfactionDegree();\n                    // If one of the neighborhood constraints c is less than or equal to the worst, the assignment is rejected.\n                    if (deg !== (0, $dldqc.Constraint).UNDEFINED && deg < min) continue out;\n                }\n                if (deg0 > maxDeg0) {\n                    maxDeg0 = deg0;\n                    canList.clear();\n                }\n                canList.addVariable(x, v);\n            }\n            x.assign(x_v); // Restore the value\n        }\n        if (canList.size() > 0) {\n            const a = this.#isRandom ? canList.random() : canList.at(0);\n            a.apply();\n            this._debugOutput(\"\t\" + a);\n            return true;\n        }\n        return false;\n    }\n    #shrink(node) {\n        this._debugOutput(\"shrink\");\n        let removeCStar = false;\n        while(true){\n            node = node.parent();\n            if (this.#c_stars.delete(node)) {\n                removeCStar = true;\n                break;\n            }\n            if (!this.#repair(node.parent().getObject())) break;\n        }\n        const temp = [];\n        node.getDescendants(temp); // temp contains node.\n        for (const n of temp){\n            n.clear(); // Prepare for reuse\n            this.#openList.delete(n);\n            this.#closedList.delete(n);\n        }\n        if (!removeCStar) this.#openList.add(node);\n    }\n    #spread(node) {\n        this._debugOutput(\"spread\");\n        this.#closedList.add(node);\n        for (const c of this.#getNeighborConstraints(node.getObject())){\n            const tnc = this.#nodes[c.index()];\n            if (!this.#closedList.has(tnc) && !this.#openList.has(tnc)) {\n                node.add(tnc);\n                this.#openList.add(tnc);\n            }\n        }\n    }\n    #srs() {\n        this._debugOutput(\"srs\");\n        const [wsd_cs] = this._pro.constraintsWithWorstSatisfactionDegree();\n        for (const c of wsd_cs){\n            const cn = this.#nodes[c.index()];\n            cn.setParent(null);\n            this.#c_stars.add(cn);\n        }\n        this.#closedList.clear();\n        this.#openList.clear();\n        for (const n of this.#c_stars)this.#openList.add(n);\n        while(this.#c_stars.size && this.#openList.size){\n            if (this._iterLimit && this._iterLimit < this.#iterCount++) {\n                this._debugOutput(\"stop: number of iterations has reached the limit\");\n                return false;\n            }\n            if (this.#endTime < Date.now()) {\n                this._debugOutput(\"stop: time limit has been reached\");\n                return false;\n            }\n            const node = this.#openList.values().next().value;\n            this.#openList.delete(node);\n            if (this.#repair(node.getObject())) {\n                if (this.#c_stars.delete(node)) continue; // If the repaired node is included in C* (to be deleted)\n                if (this.#repair(node.parent().getObject())) {\n                    this.#shrink(node); // When its improvement leads to the improvement of its parents\n                    continue;\n                }\n            }\n            this.#spread(node);\n        }\n        return true;\n    }\n    exec() {\n        this.#endTime = this._timeLimit === null ? Number.MAX_VALUE : Date.now() + this._timeLimit;\n        this.#iterCount = 0;\n        if (this._targetDeg && this._targetDeg <= this._pro.worstSatisfactionDegree()) return true;\n        const sol = new (0, $6nrDu.AssignmentList)();\n        let success = false;\n        while(true){\n            const ret = this.#srs();\n            if (!ret || this.#c_stars.size) break;\n            const solutionWorstDeg = this._pro.worstSatisfactionDegree();\n            this._debugOutput(`\\tfound a solution: ${solutionWorstDeg}\\t${this._targetDeg}`);\n            sol.setProblem(this._pro);\n            if (this.foundSolution(sol, solutionWorstDeg)) {\n                success = true;\n                break;\n            }\n            if (this._targetDeg === null) success = true;\n            else if (this._targetDeg <= solutionWorstDeg) {\n                this._debugOutput(\"stop: current degree is above the target\");\n                success = true;\n                break;\n            }\n        }\n        return success;\n    }\n    /**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of falling into a local solution, but makes the solution unrepeatable.\n\t * @param flag If true, randomness is enabled.\n\t */ setRandomness(flag) {\n        this.#isRandom = flag;\n    }\n}\nclass $9d09a091b6ea2794$var$TreeNode {\n    #children = [];\n    #parent;\n    #obj;\n    constructor(obj){\n        this.#parent = null;\n        this.#obj = obj;\n    }\n    add(tn) {\n        tn.#parent = this;\n        this.#children.push(tn);\n    }\n    clear() {\n        for (const tn of this.#children)tn.#parent = null;\n        this.#children.length = 0;\n    }\n    getDescendants(tns) {\n        tns.push(this);\n        for (const tn of this.#children)tn.getDescendants(tns);\n    }\n    getObject() {\n        return this.#obj;\n    }\n    parent() {\n        return this.#parent;\n    }\n    setParent(p) {\n        this.#parent = p;\n    }\n}\n\n});\n\nparcelRegister(\"9wYtf\", function(module, exports) {\n\n$parcel$export(module.exports, \"SRS3_PF\", function () { return $c25e27777213027e$export$281ed65cbb041503; });\n/**\n * This class implements the SRS algorithm with PF.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $6nrDu = parcelRequire(\"6nrDu\");\n\nvar $6E6oA = parcelRequire(\"6E6oA\");\n\nvar $dfK30 = parcelRequire(\"dfK30\");\nclass $c25e27777213027e$export$281ed65cbb041503 extends (0, $dfK30.SRS3) {\n    constructor(p){\n        super(p);\n    }\n    name() {\n        return \"SRS 3 + PF\";\n    }\n    exec() {\n        let deg = 0;\n        let uvs = 0;\n        if (this._debug) {\n            deg = this._pro.worstSatisfactionDegree();\n            uvs = this._pro.emptyVariableSize();\n        }\n        const al = new (0, $6nrDu.AssignmentList)();\n        al.setProblem(this._pro);\n        const res = super.exec();\n        if (res) (0, $6E6oA.PostStabilization).apply(this._pro, al);\n        this._debugOutput(`result: ${res ? \"success\" : \"failure\"}`);\n        this._debugOutput(`satisfaction degree: ${deg} -> ${this._pro.worstSatisfactionDegree()}`);\n        this._debugOutput(`unassigned size: ${uvs} -> ${this._pro.emptyVariableSize()}`);\n        return res;\n    }\n}\n\n});\nparcelRegister(\"6E6oA\", function(module, exports) {\n\n$parcel$export(module.exports, \"PostStabilization\", function () { return $a907b38c9f6e07f7$export$52631f16ca582d39; });\n/**\n * Class of post-stabilization.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ class $a907b38c9f6e07f7$export$52631f16ca582d39 {\n    static apply(p, orig) {\n        console.log(\"start post-stabilization\");\n        let stabilized;\n        let count = 0;\n        do {\n            console.log(\"post-stabilization: count \" + count++);\n            stabilized = false;\n            let C_min = p.worstSatisfactionDegree();\n            const xs = p.variables();\n            for(let i = 0; i < xs.length; ++i){\n                const x = xs[i];\n                const org = x.value();\n                const a = orig.at(i);\n                if (org === a.value()) continue;\n                a.apply(); // Try to assign the original.\n                if (p.worstSatisfactionDegree() >= C_min) stabilized = true;\n                else x.assign(org); // Restore.\n            }\n        }while (stabilized);\n        console.log(\"finish post-stabilization\");\n        return true;\n    }\n}\n\n});\n\n\n\nparcelRegister(\"gXtgR\", function(module, exports) {\n/**\n * The class implements AC-3, one of the arc consistency algorithms.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ class $1ee9b77c35e92dd5$export$ac824f187e852f5a {\n    static #checkConsistency(c, x_j) {\n        for (const v of x_j.domain()){\n            x_j.assign(v);\n            if (c.isSatisfied() === 1) return true; // Current assignment of v_i is consistent.\n        }\n        return false;\n    }\n    static #reviseDomain(p, x_i, x_j) {\n        const v_i = x_i.value();\n        const v_j = x_j.value(); // Save the value.\n        const d_i = x_i.domain();\n        const temp = [];\n        const cs = p.constraintsBetween(x_i, x_j);\n        vs: for (const v of d_i){\n            x_i.assign(v);\n            for (const c of cs){\n                if (c.size() !== 2) continue; // Check the next constraint\n                if (!$1ee9b77c35e92dd5$export$ac824f187e852f5a.#checkConsistency(c, x_j)) continue vs; // Since there is no partner satisfying the constraint, check the next value.\n            }\n            temp.push(v);\n        }\n        x_i.assign(v_i); // Restore the value.\n        x_j.assign(v_j); // Restore the value.\n        if (temp.length !== d_i.size()) {\n            const nd = p.createDomain({\n                values: temp\n            });\n            x_i.domain(nd);\n            console.log(d_i.size() + \" -> \" + nd.size());\n            return true;\n        }\n        return false;\n    }\n    static apply(p) {\n        const cs = [];\n        for (const c of p.constraints())if (c.size() === 2) cs.push(c);\n        while(cs.length){\n            const c = cs.pop();\n            const v_k = c.at(0);\n            const v_m = c.at(1);\n            if ($1ee9b77c35e92dd5$export$ac824f187e852f5a.#reviseDomain(p, v_k, v_m)) {\n                for (const c1 of p.constraints())if (c1.size() === 2 && c1.at(1) === v_k && c1.at(0) !== v_m) cs.unshift(c1);\n            }\n        }\n    }\n}\n\n});\n\nparcelRegister(\"gIE9K\", function(module, exports) {\n/**\n * Utility class that performs node consistency.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */ class $a1f38b85eaa7d915$export$975ddbe83e2b310a {\n    /**\n\t * Guarantees consistency of fuzzy unary constraints. The domain of each variable is replaced as needed.\n\t * Deletes elements from domains that do not meet the specified worst satisfaction degree.\n\t * @param p A problem.\n\t * @param threshold Worst satisfaction degree.\n\t * @return True if there is no empty domain.\n\t */ static applyToProblem(p, threshold) {\n        for (const x of p.variables()){\n            const d = x.domain();\n            const origV = x.value(); // Save the value.\n            const elms = [];\n            for (const c of x){\n                if (c.size() !== 1) continue;\n                for (const v of d){\n                    x.assign(v);\n                    if (c.satisfactionDegree() >= threshold) elms.push(v);\n                }\n                p.removeConstraint(c);\n            }\n            x.assign(origV); // Restore the value.\n            if (elms.length === 0) return false;\n            x.domain(p.createDomain({\n                values: elms\n            }));\n        }\n        return true;\n    }\n    /**\n\t * Guarantees consistency of crisp unary constraints. The domain of each variable is replaced as needed.\n\t * It cannot be applied to crisp views of fuzzy constraint satisfaction problems because it changes the structure of the constraint graph.\n\t * @param p A crisp problem.\n\t * @return True if there is no empty domain.\n\t */ static applyToCrispProblem(p) {\n        for (const x of p.variables()){\n            const d = x.domain();\n            const origV = x.value(); // Save the value.\n            const elms = [];\n            for (const c of x){\n                if (c.size() !== 1) continue;\n                for (const v of d){\n                    x.assign(v);\n                    if (c.isSatisfied() === 1) elms.push(v);\n                }\n                p.removeConstraint(c);\n            }\n            x.assign(origV); // Restore the value.\n            if (elms.length === 0) return false;\n            x.domain(p.createDomain({\n                values: elms\n            }));\n        }\n        return true;\n    }\n}\n\n});\n\nparcelRegister(\"SSONT\", function(module, exports) {\n/**\n * Utility class for constraint satisfaction problems.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ \nvar $e7Kt8 = parcelRequire(\"e7Kt8\");\n\nvar $jQeFi = parcelRequire(\"jQeFi\");\nclass $dc58bfe0264b9624$export$32fae9b8f93405d0 {\n    static #averagePathLength(p, x, length, baseLength, xo) {\n        const xn = [];\n        for (const c of x){\n            for (const xi of c)if (length[xi.index()] === Number.MAX_VALUE) {\n                xn.push(xi);\n                length[xi.index()] = baseLength + 1;\n            }\n        }\n        for (const xi of xn)xo.add(xi);\n        for (const xi of xn)$dc58bfe0264b9624$export$32fae9b8f93405d0.#averagePathLength(p, xi, length, baseLength + 1, xo);\n    }\n    /**\n\t * Calculates the average path length for a given variable.\n\t * @param p A problem.\n\t * @param x A variable of the problem.\n\t * @return Average path length.\n\t */ static averagePathLength(p, x) {\n        const ls = new Array(p.variableSize());\n        ls.fill(Number.MAX_VALUE);\n        const xs = new Set();\n        xs.add(x);\n        ls[x.index()] = 0;\n        $dc58bfe0264b9624$export$32fae9b8f93405d0.#averagePathLength(p, x, ls, 0, xs);\n        let connectedSize = 0;\n        let sum = 0;\n        for(let i = 0; i < ls.length; ++i)if (ls[i] !== Number.MAX_VALUE && i !== x.index()) {\n            ++connectedSize;\n            sum += ls[i];\n        }\n        if (connectedSize === 0) return 0;\n        return sum / connectedSize;\n    }\n    /**\n\t * Calculates the average path length.\n\t * @param p A problem.\n\t * @return Average path length.\n\t */ static averagePathLengths(p) {\n        const ls = new Array(p.variableSize());\n        for (const x of p.variables())ls[x.index()] = $dc58bfe0264b9624$export$32fae9b8f93405d0.averagePathLength(p, x);\n        return ls;\n    }\n    /**\n\t * Gets an array containing all domains.\n\t * @param p A problem.\n\t * @return Array of domains.\n\t */ static domains(p) {\n        const ds = [];\n        for (const x of p.variables())ds.push(x.domain());\n        return ds;\n    }\n    /**\n\t * Returns the array of possible satisfaction degree values for all unary constraints.\n\t * @param p A problem.\n\t * @param degrees Array of degree values.\n\t * @return The array.\n\t */ static possibleSatisfactionDegreesOfUnaryConstraints(p, degrees) {\n        for (const c of p.constraints()){\n            if (c.size() !== 1) continue;\n            const x = c.at(0);\n            const origVal = x.value(); // Save the value.\n            for (const v of x.domain()){\n                x.assign(v);\n                degrees.push(c.satisfactionDegree());\n            }\n            x.assign(origVal); // Restore the value.\n        }\n        return degrees;\n    }\n    /**\n\t * Set up all domains.\n\t * @param p A problem.\n\t * @param ds Array of domains.\n\t */ static setDomains(p, ds) {\n        for(let i = 0; i < ds.length; ++i)p.variableAt(i).domain(ds[i]);\n    }\n    /**\n\t * Returns a view of the fuzzy constraint satisfaction problem as a crisp constraint satisfaction problem.\n\t * The relations and domains of the specified fuzzy constraint satisfaction problem are reused, but the other elements are newly generated.\n\t * Note: Assignments to variables and changes to domains of the view are reflected in the variables of the original problem.\n\t * @param p A fuzzy constraint satisfaction problem.\n\t * @param threshold The threshold of constraint satisfaction degree. A constraint is considered satisfied when the constraint satisfaction degree is greater than or equal to this value.\n\t * @return A crisp constraint satisfaction problem.\n\t */ static toViewAsCrispProblem(p, threshold) {\n        const cp = new $dc58bfe0264b9624$var$CrispFuzzyProblem();\n        for (const x of p.variables())cp.createVariable({\n            variable: x\n        });\n        for (const c of p.constraints()){\n            const xs = [];\n            for (const x of c)xs.push(cp.variableAt(x.index()));\n            let r;\n            if (c.isFuzzy()) r = new $dc58bfe0264b9624$var$CrispFuzzyRelation(c.fuzzyRelation(), threshold);\n            else r = c.crispRelation();\n            cp.createConstraint({\n                relation: r,\n                variables: xs\n            });\n        }\n        return cp;\n    }\n}\nclass $dc58bfe0264b9624$var$CrispFuzzyProblem extends (0, $e7Kt8.CrispProblem) {\n    createVariable(args) {\n        const iv = new (0, $jQeFi.ImaginaryVariable)(args.variable);\n        this.addVariable(iv);\n        return iv;\n    }\n}\nclass $dc58bfe0264b9624$var$CrispFuzzyRelation {\n    #th;\n    #fr;\n    constructor(fr, th){\n        this.#fr = fr;\n        this.#th = th;\n    }\n    isSatisfied(...vs) {\n        return this.#fr.satisfactionDegree(...vs) >= this.#th ? 1 : 0;\n    }\n}\n\n});\n\nparcelRegister(\"8B8kR\", function(module, exports) {\n/**\n * This class detects that a solver's operation is looping.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */ class $7ef143b542eec4a5$export$136021658ac30d9 {\n    #loopLength;\n    #iterCount;\n    #is = [];\n    #vs = [];\n    #cur = 0;\n    constructor(loopLength = 30, iterCount = 3){\n        this.#loopLength = loopLength;\n        this.#iterCount = iterCount;\n        this.#initArrays();\n    }\n    #assignToVariable(index, value) {\n        this.#is[this.#cur] = index;\n        this.#vs[this.#cur] = value;\n        if (--this.#cur === -1) this.#cur = this.#is.length - 1;\n    }\n    #checkLooping() {\n        const is = new Array(this.#loopLength);\n        const vs = new Array(this.#loopLength);\n        out: for(let length = 1; length <= this.#loopLength; ++length){\n            let offset = this.#cur + 1;\n            for(let i = 0; i < length; ++i){\n                if (i + offset === this.#is.length) offset -= this.#is.length;\n                is[i] = this.#is[i + offset];\n                vs[i] = this.#vs[i + offset];\n            }\n            let fi = length;\n            for(let i = 0; i < this.#iterCount - 1; ++i){\n                offset = this.#cur + 1;\n                for(let j = 0; j < length; ++j){\n                    if (fi + j + offset >= this.#is.length) offset -= this.#is.length;\n                    if (this.#is[fi + j + offset] !== is[j] || this.#vs[fi + j + offset] !== vs[j]) continue out;\n                }\n                fi += length;\n            }\n            return length;\n        }\n        return 0;\n    }\n    #initArrays() {\n        this.#is = new Array(this.#loopLength * this.#iterCount);\n        this.#vs = new Array(this.#loopLength * this.#iterCount);\n        this.#is.fill(-1);\n        this.#vs.fill(-1);\n        this.#cur = this.#is.length - 1;\n    }\n    checkLoop(variableIndex, value) {\n        this.#assignToVariable(variableIndex, value);\n        return this.#checkLooping();\n    }\n    clear() {\n        this.#is.fill(-1);\n        this.#vs.fill(-1);\n    }\n    iterationCount() {\n        return this.#iterCount;\n    }\n    loopLength() {\n        return this.#loopLength;\n    }\n    values() {\n        return this.#vs.slice();\n    }\n    variableIndices() {\n        return this.#is.slice();\n    }\n}\n\n});\n\n\nparcelRegister(\"iljD2\", function(module, exports) {\n\n$parcel$export(module.exports, \"waitFor\", function () { return $f4847ffd40982f3c$export$9bbfceb27f687c1b; });\n$parcel$export(module.exports, \"createLogOutput\", function () { return $f4847ffd40982f3c$export$ad5fb9bd399ebc56; });\nfunction $f4847ffd40982f3c$export$9bbfceb27f687c1b(fn) {\n    return new Promise((r)=>{\n        const si = setInterval(()=>{\n            if (fn()) {\n                clearInterval(si);\n                r(null);\n            }\n        }, 100);\n    });\n}\nfunction $f4847ffd40982f3c$export$ad5fb9bd399ebc56(id = \"output\") {\n    const output = document.getElementById(id);\n    return (e)=>{\n        output.value += `${e}\\n`;\n        setTimeout(()=>output.scrollTo(0, output.scrollHeight), 100);\n    };\n}\n\n});\n\n\n//# sourceMappingURL=index.950b969f.js.map\n","export * from './src/problem/problem';\nexport * from './src/problem/problem-crisp';\n\nexport * from './src/problem/element';\n\nexport * from './src/problem/variable';\nexport * from './src/problem/variables';\n\nexport * from './src/problem/domain';\nexport * from './src/problem/domain-arbitrary';\nexport * from './src/problem/domain-ranged';\n\nexport * from './src/problem/constraint';\nexport * from './src/problem/constraint-1';\nexport * from './src/problem/constraint-2';\nexport * from './src/problem/constraint-3';\nexport * from './src/problem/constraint-n';\n\nexport * from './src/problem/relation';\n\n// -----------------------------------------------------------------------------\n\nexport * from './src/solver/solver';\nexport * from './src/solver/solver-factory-static';\n\nexport * from './src/solver/fuzzy/flexible-local-changes';\nexport * from './src/solver/fuzzy/flexible-local-changes-ex';\nexport * from './src/solver/fuzzy/fuzzy-breakout';\nexport * from './src/solver/fuzzy/fuzzy-forward-checking';\nexport * from './src/solver/fuzzy/fuzzy-forward-checking-bc';\nexport * from './src/solver/fuzzy/fuzzy-genet';\nexport * from './src/solver/fuzzy/srs3';\nexport * from './src/solver/fuzzy/srs3-pf';\n\nexport * from './src/solver/crisp/breakout';\nexport * from './src/solver/crisp/crisp-srs3';\nexport * from './src/solver/crisp/forward-checking';\nexport * from './src/solver/crisp/genet';\nexport * from './src/solver/crisp/local-changes';\nexport * from './src/solver/crisp/local-changes-ex';\nexport * from './src/solver/crisp/max-forward-checking';\n\nexport * from './src/solver/filter/ac3';\nexport * from './src/solver/filter/node-consistency';\nexport * from './src/solver/filter/post-stabilization';\n\n// -----------------------------------------------------------------------------\n\nexport * from './src/util/problems';\nexport * from './src/util/assignment';\nexport * from './src/util/assignment-list';\nexport * from './src/util/domain-pruner';\nexport * from './src/util/loop-detector';\n","/**\n * The class represents a constraint satisfaction problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Variable } from './variable';\nimport { Domain } from './domain';\nimport { DomainRanged } from './domain-ranged';\nimport { DomainArbitrary } from './domain-arbitrary';\nimport { Constraint } from './constraint';\nimport { Constraint1 } from './constraint-1';\nimport { Constraint2 } from './constraint-2';\nimport { Constraint3 } from './constraint-3';\nimport { ConstraintN } from './constraint-n';\nimport { Relation } from './relation';\n\nexport class Problem {\n\n\t#fv: (o: Problem, d: Domain) => Variable = (o: Problem, d: Domain): Variable => new Variable(o, d);\n\t#fc: (r: Relation, xs: Variable[]) => Constraint = (r: Relation, xs: Variable[]): Constraint => {\n\t\tif (xs.length === 1) {\n\t\t\treturn new Constraint1(r, xs[0]);\n\t\t}\n\t\tif (xs.length === 2) {\n\t\t\treturn new Constraint2(r, xs[0], xs[1]);\n\t\t}\n\t\tif (xs.length === 3) {\n\t\t\treturn new Constraint3(r, xs[0], xs[1], xs[2]);\n\t\t}\n\t\treturn new ConstraintN(r, ...xs);\n\t};\n\n\t#isFuzzy: boolean = false;\n\t#xs: Variable[] = [];\n\t#cs: Constraint[] = [];\n\n\t// Methods for Modifying Factories --------\n\n\t/**\n\t * Sets a variable factory.\n\t */\n\tsetVariableFactory(fn: (o: Problem, d: Domain) => Variable): void {\n\t\tthis.#fv = fn;\n\t}\n\n\t/**\n\t * Sets a variable factory.\n\t */\n\tsetConstraintFactory(fn: (r: Relation, xs: Variable[]) => Constraint): void {\n\t\tthis.#fc = fn;\n\t}\n\n\t// Generation Methods --------\n\n\t/**\n\t * Adds a variable to this problem.\n\t * @param Variable v A variable.\n\t */\n\taddVariable(x: Variable): void {\n\t\tx.setIndex(this.#xs.length);\n\t\tthis.#xs.push(x);\n\t}\n\n\t/**\n\t * Generates a domain.\n\t * @param args {\n\t *   @type Array 'values' Multiple values.\n\t *\n\t *   @type Number 'min' Minimum value.\n\t *   @type Number 'max' Maximum value.\n\t * }\n\t * @return A domain.\n\t */\n\tcreateDomain(args: { values: number[]; } | { min: number, max: number; }): Domain | null {\n\t\tif ('values' in args) {\n\t\t\treturn new DomainArbitrary(args.values);\n\t\t} else if ('min' in args && 'max' in args) {\n\t\t\treturn new DomainRanged(args.min, args.max);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Generates a variable.\n\t * @param Array args {\n\t *   @type string 'name'   Display name.\n\t *   @type Domain 'domain' A domain.\n\t *   @type *      'value'  A value.\n\t * }\n\t * @return A variable.\n\t */\n\tcreateVariable(args: { name: string, domain: Domain, value?: number; } | { variable: Variable; }): Variable {\n\t\tif ('variable' in args) {\n\t\t\tconst x: Variable = this.#fv(this, args.variable.domain());\n\t\t\tthis.addVariable(x);\n\t\t\tx.setName(x.name());\n\t\t\tx.assign(x.value());\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (args.value !== undefined && !args.domain.contains(args.value)) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t\tconst x: Variable = this.#fv(this, args.domain);\n\t\t\tthis.addVariable(x);\n\t\t\tif (args.name) {\n\t\t\t\tx.setName(args.name);\n\t\t\t}\n\t\t\tif (args.value) {\n\t\t\t\tx.assign(args.value);\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\t}\n\n\t/**\n\t * Generates a constraint.\n\t * @param Array args {\n\t *   @type string   'name'      Display name.\n\t *   @type Array    'variables' Variables.\n\t *   @type Relation 'relation'  A relation.\n\t * }\n\t * @return A constraint.\n\t */\n\tcreateConstraint(args: { name?: string, variables: Variable[], relation: Relation; }): Constraint | null {\n\t\tfor (const x of args.variables) {\n\t\t\tif (x.owner() !== this) return null;\n\t\t}\n\t\tconst c: Constraint = this.#fc(args.relation, args.variables);\n\t\tc.setIndex(this.#cs.length);\n\t\tthis.#cs.push(c);\n\t\tfor (const x of args.variables) {\n\t\t\tx.connect(c);\n\t\t}\n\t\tif (c.isFuzzy()) {\n\t\t\tthis.#isFuzzy = true;\n\t\t}\n\t\tif ('name' in args) {\n\t\t\tc.setName(args.name as string);\n\t\t}\n\t\treturn c;\n\t}\n\n\t//  Modification Methods --------\n\n\t/**\n\t * Remove the constraint.\n\t * @param c Constraints to be removed.\n\t */\n\tremoveConstraint(c: Constraint): void {\n\t\tconst index: number = this.#cs.indexOf(c);\n\t\tthis.#cs.splice(index, 1);\n\t\tfor (let i: number = index; i < this.#cs.length; ++i) {\n\t\t\tthis.#cs[i].setIndex(i);\n\t\t}\n\t\tfor (const x of c) {\n\t\t\tx.disconnect(c);\n\t\t}\n\t\tthis.#isFuzzy = false;\n\t\tfor (const c of this.#cs) {\n\t\t\tif (c.isFuzzy()) {\n\t\t\t\tthis.#isFuzzy = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Changes the status of all variables to unassigned.\n\t */\n\tclearAllVariables(): void {\n\t\tfor (const x of this.#xs) {\n\t\t\tx.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the order of variables.\n\t * The index of each variable is reassigned.\n\t */\n\treverseVariables(): void {\n\t\tthis.#xs.reverse();\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tthis.#xs[i].setIndex(i);\n\t\t}\n\t}\n\n\t/**\n\t * Sorts variables using a specified comparator.\n\t * The index of each variable is reassigned.\n\t * @param comparator A comparator.\n\t */\n\tsortVariables(comparator: (a: Variable, b: Variable) => number): void {\n\t\tthis.#xs.sort(comparator);\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tthis.#xs[i].setIndex(i);\n\t\t}\n\t}\n\n\t// Methods for Variables --------\n\n\t/**\n\t * Returns the number of variables in the problem.\n\t * @return Number of variables\n\t */\n\tvariableSize(): number {\n\t\treturn this.#xs.length;\n\t}\n\n\t/**\n\t * Returns a variable by index.\n\t * @param index Index (0 <= index < getVariableSize()).\n\t * @return A variable\n\t */\n\tvariableAt(index: number): Variable {\n\t\treturn this.#xs[index];\n\t}\n\n\t/**\n\t * Returns a variable by name.\n\t * @param name Name.\n\t * @return A variable.\n\t */\n\tvariableOf(name: string): Variable | null {\n\t\tfor (const x of this.#xs) {\n\t\t\tif (x.name() === name) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns whether the variable is contained or not.\n\t * @param x A variable.\n\t * @return True if contained.\n\t */\n\thasVariable(x: Variable): boolean {\n\t\treturn this.#xs.includes(x);\n\t}\n\n\t/**\n\t * Returns the list of variables.\n\t * The returned list is not allowed to be modified.\n\t * @return The variable list.\n\t */\n\tvariables(): Variable[] {\n\t\treturn this.#xs;\n\t}\n\n\t// Methods for Constraints --------\n\n\t/**\n\t * Gets the number of constraints in the problem.\n\t * @return Number of constraints\n\t */\n\tconstraintSize(): number {\n\t\treturn this.#cs.length;\n\t}\n\n\t/**\n\t * Returns a constraint with an index.\n\t * @param index Index (0 <= index < constraintSize()).\n\t * @return A constraint.\n\t */\n\tconstraintAt(index: number): Constraint {\n\t\treturn this.#cs[index];\n\t}\n\n\t/**\n\t * Returns a constraint by name.\n\t * @param name Name.\n\t * @return A constraint.\n\t */\n\tconstraintOf(name: string): Constraint | null {\n\t\tfor (const c of this.#cs) {\n\t\t\tif (c.name() === name) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns whether the constraint is contained or not.\n\t * @param c A constraint\n\t * @return True if contained.\n\t */\n\thasConstraint(c: Constraint): boolean {\n\t\treturn this.#cs.includes(c);\n\t}\n\n\t/**\n\t * Returns the list of constraint.\n\t * The returned list is not allowed to be modified.\n\t * @return The constraint list.\n\t */\n\tconstraints(): Constraint[] {\n\t\treturn this.#cs;\n\t}\n\n\t/**\n\t * Gets the constraints that exist between the specified variables.\n\t * Returns an empty array if no constraints exist.\n\t * If there are multiple constraints between two variables (including the case of n-ary constraints (2 < n)), they will be included in the return array.\n\t * @param v1 Variable 1\n\t * @param v2 Variable 2\n\t * @return Constraints.\n\t */\n\tconstraintsBetween(v1: Variable, v2: Variable): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\t\tfor (const c of v1) {\n\t\t\tif (c.has(v2)) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\t/**\n\t * Finds the set of worst satisfiable constraints in a fuzzy constraint satisfaction problem.\n\t * @return Array of constraints and worst satisfaction degree.\n\t */\n\tconstraintsWithWorstSatisfactionDegree(): [Constraint[], number] {\n\t\tconst cs: Constraint[] = [];\n\t\tlet cur: number = 1;\n\t\tfor (const c of this.#cs) {\n\t\t\tconst s: number = c.satisfactionDegree();\n\t\t\tif (s < cur) {\n\t\t\t\tcur = s;\n\t\t\t\tcs.length = 0;\n\t\t\t\tcs.push(c);\n\t\t\t} else if (s - cur < Number.MIN_VALUE * 10) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn [cs, cur];\n\t}\n\n\t// State acquisition methods --------\n\n\t/**\n\t * Returns the worst satisfaction degree for the constraints contained in the fuzzy constraint satisfaction problem.\n\t * If the degree cannot be determined because the variable has not yet been assigned a value or for some other reason, -1 is returned.\n\t * @return Worst satisfaction degree.\n\t */\n\tworstSatisfactionDegree(): number {\n\t\tlet cs: number = 1;\n\t\tfor (const c of this.#cs) {\n\t\t\tconst s: number = c.satisfactionDegree();\n\t\t\tif (s === Constraint.UNDEFINED) return Constraint.UNDEFINED;\n\t\t\tif (s < cs) cs = s;\n\t\t}\n\t\treturn cs;\n\t}\n\n\t/**\n\t * Gets the average of satisfaction degrees of the fuzzy constraints.\n\t * @return Average of satisfaction degrees.\n\t */\n\taverageSatisfactionDegree(): number {\n\t\tlet ave: number = 0;\n\t\tfor (const c of this.#cs) {\n\t\t\tave += c.satisfactionDegree();\n\t\t}\n\t\tave = ave / this.#cs.length;\n\t\treturn ave;\n\t}\n\n\t/**\n\t * Returns the number of variables in the problem that have not been assigned a value.\n\t * @return Number of variables with no value assigned.\n\t */\n\temptyVariableSize(): number {\n\t\tlet n: number = 0;\n\n\t\tfor (const x of this.#xs) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\t/**\n\t * Gets the constraint density (number of constraints/number of variables).\n\t * @return Constraint density.\n\t */\n\tconstraintDensity(): number {\n\t\treturn this.constraintSize() / this.variableSize();\n\t}\n\n\t/**\n\t * Returns whether the constraint satisfaction problem has any variables with empty domain.\n\t * @return True if it exists.\n\t */\n\thasEmptyDomain(): boolean {\n\t\tfor (const x of this.#xs) {\n\t\t\tif (x.domain().size() === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns whether the problem is a fuzzy constraint satisfaction problem, i.e., whether it contains fuzzy constraints.\n\t * @return True if it is a fuzzy constraint satisfaction problem.\n\t */\n\tisFuzzy(): boolean {\n\t\treturn this.#isFuzzy;\n\t}\n\n}\n","/**\n * Class that represents a variable.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Problem } from './problem';\nimport { Element } from './element';\nimport { Constraint } from './constraint';\nimport { Domain } from './domain';\n\nexport class Variable extends Element {\n\n\tstatic readonly #INVALID: number = Number.MIN_VALUE;\n\n\t#owner: Problem;\n\n\t#d: Domain;\n\t#v: number = Variable.#INVALID;\n\t#cs: Constraint[] = [];\n\n\t// Called only from Problem.\n\tconstructor(owner: Problem, d: Domain) {\n\t\tsuper();\n\t\tthis.#owner = owner;\n\t\tthis.#d = d;\n\t}\n\n\t/**\n\t * Gets a string representation.\n\t * @return A string representation.\n\t */\n\ttoString(): string {\n\t\tconst n = this.name();\n\t\tconst np = n ? `(${n})` : '';\n\t\tconst v = this.isEmpty() ? '<empty>' : ('' + this.value());\n\n\t\treturn `x${this.index()}${np} = ${v}`;\n\t}\n\n\t/**\n\t * Gets the number of associated constraints.\n\t * @return Number of constraints.\n\t */\n\tsize(): number {\n\t\treturn this.#cs.length;\n\t}\n\n\t/**\n\t * Gets the associated constraints by specifying their indices.\n\t * @param index Index.\n\t * @return A constraint.\n\t */\n\tat(index: number): Constraint | undefined {\n\t\treturn this.#cs.at(index);\n\t}\n\n\t/**\n\t * Checks whether or not the variable is associated with the specified constraint.\n\t * @param c A constraint.\n\t * @return True if associated.\n\t */\n\thas(c: Constraint): boolean {\n\t\treturn this.#cs.includes(c);\n\t}\n\n\t/**\n\t * Gets the index of a specified constraint.\n\t * If not found, returns -1.\n\t * @param c A constraint.\n\t * @return Index.\n\t */\n\tindexOf(c: Constraint): number {\n\t\treturn this.#cs.indexOf(c);\n\t}\n\n\t/**\n\t * Collects the variables connected via the associated constraints.\n\t * @return An array of variables\n\t */\n\tneighbors(): Variable[] {\n\t\tconst xs: Variable[] = [];\n\n\t\tfor (const c of this.#cs) {\n\t\t\tfor (const x of c) {\n\t\t\t\tif (x !== this) {\n\t\t\t\t\txs.push(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn xs;\n\t}\n\n\t/**\n\t * Gets the iterator of the associated constraints.\n\t */\n\t[Symbol.iterator](): Iterator<Constraint> {\n\t\treturn this.#cs[Symbol.iterator]();\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Gets the problem that owns this variable.\n\t * @return Owner.\n\t */\n\towner(): Problem {\n\t\treturn this.#owner;\n\t}\n\n\t// Called only from Problem.\n\tconnect(c: Constraint): void {\n\t\tif (this.#cs.includes(c)) {\n\t\t\tthrow new RangeError();\n\t\t}\n\t\tthis.#cs.push(c);\n\t}\n\n\t// Called only from Problem.\n\tdisconnect(c: Constraint): void {\n\t\tif (!this.#cs.includes(c)) {\n\t\t\tthrow new RangeError();\n\t\t}\n\t\tthis.#cs = this.#cs.filter(\n\t\t\t(i: Constraint): boolean => i !== c\n\t\t);\n\t}\n\n\t/**\n\t * Gets the domain of the variable.\n\t * @return The domain.\n\t */\n\tdomain(): Domain;\n\n\t/**\n\t * Sets a new domain to the variable.\n\t * The variable will be in unassigned state.\n\t * @param d Domain to be assigned.\n\t */\n\tdomain(d: Domain): void;\n\n\tdomain(d?: Domain): Domain | void {\n\t\tif (d === undefined) {\n\t\t\treturn this.#d;\n\t\t} else {\n\t\t\tthis.#d = d;\n\t\t\tthis.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Assign a value.\n\t * @param value Value.\n\t */\n\tassign(value: number): void {\n\t\tthis.#v = value;  // Do not change #val except here.\n\t}\n\n\t/**\n\t * Sets the state of the variable to unassigned.\n\t */\n\tclear(): void {\n\t\t// Do not use the invalid value except here and below (isEmpty).\n\t\tthis.assign(Variable.#INVALID);\n\t}\n\n\t/**\n\t * Gets the value of the variable.\n\t * @returnThe value of the variable.\n\t */\n\tvalue(): number {\n\t\treturn this.#v;\n\t}\n\n\t/**\n\t * Checks whether the value is unassigned or not.\n\t * @return True if unassigned.\n\t */\n\tisEmpty(): boolean {\n\t\treturn this.value() === Variable.#INVALID;\n\t}\n\n}\n","/**\n * The common class of variables and constraints.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nexport class Element {\n\n\t#index: number = -1;\n\t#name: string = '';\n\n\t/**\n\t * It is used when the user wishes to associate an arbitrary object with each element.\n\t */\n\tuserObject: any = null;\n\n\t/**\n\t * Used when the solver wants to associate an arbitrary object with each element.\n\t */\n\tsolverObject: any = null;\n\n\t// Called only from Problem.\n\tsetIndex(index: number): void {\n\t\tthis.#index = index;\n\t}\n\n\t/**\n\t * Sets the name.\n\t *\n\t * @param name string representing the name.\n\t */\n\tsetName(name: string): void {\n\t\tthis.#name = name;\n\t}\n\n\t/**\n\t * Get the index on the owned problem.\n\t * Each variable and constraint is assigned a serial number as an index, which is used to access it through the problem.\n\t *\n\t * @return Integer value representing the index.\n\t */\n\tindex(): number {\n\t\treturn this.#index;\n\t}\n\n\t/**\n\t * Gets the name.\n\t *\n\t * @return String representing the name.\n\t */\n\tname(): string {\n\t\treturn this.#name;\n\t}\n\n}\n","/**\n * A variable domain with contiguous integer elements.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Domain } from './domain';\n\nexport class DomainRanged extends Domain {\n\n\t#min: number;\n\t#max: number;\n\n\tconstructor(min: number, max: number) {\n\t\tsuper();\n\t\tthis.#min = min | 0;\n\t\tthis.#max = max | 0;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tcontains(v: number): boolean {\n\t\treturn this.#min <= v && v <= this.#max;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tindexOf(v: number): number {\n\t\treturn (this.#min <= v && v <= this.#max) ? (v - this.#min) : -1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsize(): number {\n\t\treturn this.#max - this.#min + 1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tat(index: number): number {\n\t\treturn this.#min + index;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t[Symbol.iterator](): Iterator<number> {\n\t\tlet v: number = this.#min;\n\t\tconst max: number = this.#max;\n\t\treturn {\n\t\t\tnext(): IteratorResult<number> {\n\t\t\t\tif (v <= max) {\n\t\t\t\t\treturn { value: v++, done: false };\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: null, done: true };\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n\n}\n","/**\n * An abstract class that represents a variable domain.\n * The domain is immutable.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nexport abstract class Domain {\n\n\t/**\n\t * Checks whether the specified value is included as an element of the domain.\n\t *\n\t * @param v A value.\n\t * @return True if the value is included.\n\t */\n\tabstract contains(v: number): boolean;\n\n\t/**\n\t * Gets the index of the specified value. If it does not exist, -1 is returned.\n\t *\n\t * @param v A value.\n\t * @return The index.\n\t */\n\tabstract indexOf(v: number): number;\n\n\t/**\n\t * Gets the size of the domain, including the pruned elements.\n\t *\n\t * @return The size.\n\t */\n\tabstract size(): number;\n\n\t/**\n\t * Gets the value at the specified index. The retrieved value may have been pruned.\n\t *\n\t * @param index An index.\n\t * @return The value.\n\t */\n\tabstract at(index: number): number;\n\n\t/**\n\t * Gets the iterator of the values of the domain.\n\t */\n\tabstract [Symbol.iterator](): Iterator<number>;\n\n\t/**\n\t * Gets an arbitrary value, regardless of whether it has been pruned or not.\n\t *\n\t * @return A value.\n\t */\n\trandom(): number {\n\t\treturn this.at(Math.floor(Math.random() * this.size()));\n\t}\n\n}\n","/**\n * A variable domain with arbitrary elements.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Domain } from './domain';\n\nexport class DomainArbitrary extends Domain {\n\n\t#vs: number[];\n\n\tconstructor(vs: number[]) {\n\t\tsuper();\n\t\tthis.#vs = [...vs];\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tcontains(v: number): boolean {\n\t\treturn this.#vs.includes(v);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tindexOf(v: number): number {\n\t\treturn this.#vs.indexOf(v);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsize(): number {\n\t\treturn this.#vs.length;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tat(index: number): number {\n\t\treturn this.#vs[index];\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t[Symbol.iterator](): Iterator<number> {\n\t\treturn this.#vs[Symbol.iterator]();\n\t}\n\n}\n","/**\n * The class represents a constraint.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Element } from './element';\nimport { Variable } from './variable';\nimport { Relation } from './relation';\nimport { CrispRelation, FuzzyRelation } from './relation';\n\nexport abstract class Constraint extends Element {\n\n\t/**\n\t * The constant indicating that the satisfaction degree is not defined.\n\t */\n\tstatic UNDEFINED: -1 = -1;\n\n\trel: Relation;\n\n\t// Called only from Problem.\n\tconstructor(r: Relation) {\n\t\tsuper();\n\t\tthis.rel = r;\n\t}\n\n\t/**\n\t * Returns the crisp relation between variables.\n\t * @return Relation.\n\t */\n\tcrispRelation(): CrispRelation {\n\t\treturn this.rel as CrispRelation;\n\t}\n\n\t/**\n\t * Returns the fuzzy relation between variables.\n\t * @return Relation.\n\t */\n\tfuzzyRelation(): FuzzyRelation {\n\t\treturn this.rel as FuzzyRelation;\n\t}\n\n\t/**\n\t * Returns whether this is a fuzzy constraint.\n\t * @return True if it is fuzzy constraint.\n\t */\n\tisFuzzy(): boolean {\n\t\treturn 'satisfactionDegree' in this.rel;\n\t}\n\n\t/**\n\t * Returns a string representation.\n\t * @return A string representation.\n\t */\n\ttoString(): string {\n\t\tconst n = this.name();\n\t\tconst np = n ? `(${n})` : '';\n\t\tconst s = this.satisfactionDegree();\n\t\tconst sn = s === Constraint.UNDEFINED ? 'UNDEFINED' : ('' + s);\n\n\t\treturn `c${this.index()}${np} = ${sn}`;\n\t}\n\n\t/**\n\t * Returns the order of the constraint, i.e., the number of (associated) variables in the scope.\n\t * @return Order.\n\t */\n\tabstract size(): number;\n\n\t/**\n\t * Gets the associated variable by specifying its index.\n\t * @param index Index.\n\t * @return A variable.\n\t */\n\tabstract at(index: number): Variable | undefined;\n\n\t/**\n\t * Returns whether the specified variable is associated or not.\n\t * @param x A variable.\n\t * @return True if it is associated.\n\t */\n\tabstract has(x: Variable): boolean;\n\n\t/**\n\t * Gets the index of a specified variable.\n\t * If not found, returns -1.\n\t * @param x A variable.\n\t * @return Index.\n\t */\n\tabstract indexOf(x: Variable): number;\n\n\t/**\n\t * Returns the set of constraints connected via the associated variables.\n\t * @return A set of constraints.\n\t */\n\tabstract neighbors(): Constraint[];\n\n\t/**\n\t * Gets the iterator of the associated variables.\n\t */\n\tabstract [Symbol.iterator](): Iterator<Variable>;\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Returns the number of scope variables that have not been assigned a value.\n\t * @return Number of variables\n\t */\n\tabstract emptyVariableSize(): number;\n\n\t/**\n\t * Returns whether or not the satisfaction (degree) is defined.\n\t * Satisfaction (degree) is defined when all associated variables have values assigned to them.\n\t * @return True if it is defined.\n\t */\n\tabstract isDefined(): boolean;\n\n\t/**\n\t * Returns whether or not this constraint is satisfied.\n\t * @return 1 if satisfied, 0 if not, UNDEFINED if undefined\n\t */\n\tabstract isSatisfied(): -1 | 0 | 1;\n\n\t/**\n\t * Gets the current satisfaction degree.\n\t * @return Degree 0 - 1, UNDEFINED if undefined.\n\t */\n\tabstract satisfactionDegree(): number;\n\n\t/**\n\t * Calculates the highest consistency degree.\n\t * That is, it seeks the highest satisfaction degree of the possible combinations of variable assignments for a given constraint.\n\t * When all associated variables have been assigned values, it returns the same value as getSatisfactionDegree().\n\t * @return The highest consistency degree.\n\t */\n\tabstract highestConsistencyDegree(): number;\n\n\t/**\n\t * Calculates the lowest consistency degree.\n\t * That is, it seeks the lowest satisfaction degree of the possible combinations of variable assignments for a given constraint.\n\t * When all associated variables have been assigned values, it returns the same value as getSatisfactionDegree().\n\t * @return The lowest consistency degree.\n\t */\n\tabstract lowestConsistencyDegree(): number;\n\n}\n","/**\n * The class represents an unary constraint.\n * The constructor is not called directly, since it is created by the Problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Constraint } from './constraint';\nimport { Variable } from './variable';\nimport { Relation } from './relation';\n\nexport class Constraint1 extends Constraint {\n\n\t#xs: [Variable] = [] as unknown as [Variable];\n\n\t// Called only from Problem.\n\tconstructor(r: Relation, x: Variable) {\n\t\tsuper(r);\n\t\tthis.#xs = [x];\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsize(): number {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tat(index: number): Variable | undefined {\n\t\treturn this.#xs.at(index);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\thas(x: Variable) {\n\t\treturn x === this.#xs[0];\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tindexOf(x: Variable): number {\n\t\treturn (x === this.#xs[0]) ? 0 : -1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tneighbors(): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\n\t\tfor (const c of this.#xs[0]) {\n\t\t\tif (c !== this) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t[Symbol.iterator](): Iterator<Variable> {\n\t\treturn this.#xs[Symbol.iterator]();\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\temptyVariableSize(): number {\n\t\treturn this.#xs[0].isEmpty() ? 1 : 0;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tisDefined(): boolean {\n\t\treturn !this.#xs[0].isEmpty();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tisSatisfied(): -1 | 0 | 1 {\n\t\tif (this.#xs[0].isEmpty()) {\n\t\t\treturn Constraint.UNDEFINED;\n\t\t}\n\t\treturn this.crispRelation().isSatisfied(this.#xs[0].value()) ? 1 : 0;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsatisfactionDegree(): number {\n\t\tif (this.#xs[0].isEmpty()) {\n\t\t\treturn Constraint.UNDEFINED;\n\t\t}\n\t\treturn this.fuzzyRelation().satisfactionDegree(this.#xs[0].value());\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\thighestConsistencyDegree(): number {\n\t\tconst sd: number = this.satisfactionDegree();\n\t\tif (sd !== Constraint.UNDEFINED) {\n\t\t\treturn sd;\n\t\t}\n\t\tlet cd: number = 0;\n\n\t\tfor (const v of this.#xs[0].domain()) {\n\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v);\n\t\t\tif (s > cd) {\n\t\t\t\tcd = s;\n\t\t\t}\n\t\t\tif (cd === 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tlowestConsistencyDegree(): number {\n\t\tconst sd: number = this.satisfactionDegree();\n\t\tif (sd !== Constraint.UNDEFINED) {\n\t\t\treturn sd;\n\t\t}\n\t\tlet cd: number = 1;\n\n\t\tfor (const v of this.#xs[0].domain()) {\n\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v);\n\t\t\tif (s < cd) {\n\t\t\t\tcd = s;\n\t\t\t}\n\t\t\tif (cd === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n}\n","/**\n * The class represents an binary constraint.\n * The constructor is not called directly, since it is created by the Problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Constraint } from './constraint';\nimport { Variable } from './variable';\nimport { Domain } from './domain';\nimport { Relation } from './relation';\n\nexport class Constraint2 extends Constraint {\n\n\t#xs: [Variable, Variable] = [] as unknown as [Variable, Variable];\n\n\t// Called only from Problem.\n\tconstructor(r: Relation, x1: Variable, x2: Variable) {\n\t\tsuper(r);\n\t\tthis.#xs = [x1, x2];\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsize(): number {\n\t\treturn 2;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tat(index: number): Variable | undefined {\n\t\treturn this.#xs.at(index);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\thas(x: Variable): boolean {\n\t\treturn this.#xs[0] === x || this.#xs[1] === x;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tindexOf(x: Variable): number {\n\t\tif (x === this.#xs[0]) return 0;\n\t\tif (x === this.#xs[1]) return 1;\n\t\treturn -1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tneighbors(): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\n\t\tfor (const c of this.#xs[0]) {\n\t\t\tif (c !== this) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\tfor (const c of this.#xs[1]) {\n\t\t\tif (c !== this) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t[Symbol.iterator](): Iterator<Variable> {\n\t\treturn this.#xs[Symbol.iterator]();\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\temptyVariableSize(): number {\n\t\tlet n: number = 0;\n\n\t\tif (this.#xs[0].isEmpty()) ++n;\n\t\tif (this.#xs[1].isEmpty()) ++n;\n\t\treturn n;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tisDefined(): boolean {\n\t\treturn !this.#xs[0].isEmpty() && !this.#xs[1].isEmpty();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tisSatisfied(): -1 | 0 | 1 {\n\t\tif (this.#xs[0].isEmpty() || this.#xs[1].isEmpty()) {\n\t\t\treturn Constraint.UNDEFINED;\n\t\t}\n\t\treturn this.crispRelation().isSatisfied(this.#xs[0].value(), this.#xs[1].value()) ? 1 : 0;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsatisfactionDegree(): number {\n\t\tif (this.#xs[0].isEmpty() || this.#xs[1].isEmpty()) {\n\t\t\treturn Constraint.UNDEFINED;\n\t\t}\n\t\treturn this.fuzzyRelation().satisfactionDegree(this.#xs[0].value(), this.#xs[1].value());\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\thighestConsistencyDegree(): number {\n\t\tconst sd: number = this.satisfactionDegree();\n\t\tif (sd !== Constraint.UNDEFINED) {\n\t\t\treturn sd;\n\t\t}\n\t\tlet cd: number = 0;\n\t\tconst v1: number = this.#xs[0].value();\n\t\tconst v2: number = this.#xs[1].value();\n\t\tconst d1: Domain = this.#xs[0].domain();\n\t\tconst d2: Domain = this.#xs[1].domain();\n\n\t\tif (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty()) {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2);\n\t\t\t\tif (s > cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty()) {\n\t\t\tfor (const v2 of d2) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2);\n\t\t\t\tif (s > cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tfor (const v2 of d2) {\n\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2);\n\t\t\t\t\tif (s > cd) {\n\t\t\t\t\t\tcd = s;\n\t\t\t\t\t}\n\t\t\t\t\tif (cd === 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tlowestConsistencyDegree(): number {\n\t\tconst sd: number = this.satisfactionDegree();\n\t\tif (sd !== Constraint.UNDEFINED) {\n\t\t\treturn sd;\n\t\t}\n\t\tlet cd: number = 1;\n\t\tconst v1: number = this.#xs[0].value();\n\t\tconst v2: number = this.#xs[1].value();\n\t\tconst d1: Domain = this.#xs[0].domain();\n\t\tconst d2: Domain = this.#xs[1].domain();\n\n\t\tif (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty()) {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2);\n\t\t\t\tif (s < cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty()) {\n\t\t\tfor (const v2 of d2) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2);\n\t\t\t\tif (s < cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tfor (const v2 of d2) {\n\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2);\n\t\t\t\t\tif (s < cd) {\n\t\t\t\t\t\tcd = s;\n\t\t\t\t\t}\n\t\t\t\t\tif (cd === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n}\n","/**\n * The class represents an 3-ary constraint.\n * The constructor is not called directly, since it is created by the Problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Constraint } from './constraint';\nimport { Variable } from './variable';\nimport { Domain } from './domain';\nimport { Relation } from './relation';\n\nexport class Constraint3 extends Constraint {\n\n\t#xs: [Variable, Variable, Variable] = [] as unknown as [Variable, Variable, Variable];\n\n\t// Called only from Problem.\n\tconstructor(r: Relation, x1: Variable, x2: Variable, x3: Variable) {\n\t\tsuper(r);\n\t\tthis.#xs = [x1, x2, x3];\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsize(): number {\n\t\treturn 3;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tat(index: number): Variable | undefined {\n\t\treturn this.#xs.at(index);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\thas(x: Variable): boolean {\n\t\treturn this.#xs[0] === x || this.#xs[1] === x || this.#xs[2] === x;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tindexOf(x: Variable): number {\n\t\tif (x === this.#xs[0]) return 0;\n\t\tif (x === this.#xs[1]) return 1;\n\t\tif (x === this.#xs[2]) return 2;\n\t\treturn -1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tneighbors(): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\n\t\tfor (const c of this.#xs[0]) {\n\t\t\tif (c !== this) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\tfor (const c of this.#xs[1]) {\n\t\t\tif (c !== this) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\tfor (const c of this.#xs[2]) {\n\t\t\tif (c !== this) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t[Symbol.iterator](): Iterator<Variable> {\n\t\treturn this.#xs[Symbol.iterator]();\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\temptyVariableSize(): number {\n\t\tlet n: number = 0;\n\n\t\tif (this.#xs[0].isEmpty()) ++n;\n\t\tif (this.#xs[1].isEmpty()) ++n;\n\t\tif (this.#xs[2].isEmpty()) ++n;\n\t\treturn n;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tisDefined(): boolean {\n\t\treturn !this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && !this.#xs[2].isEmpty();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tisSatisfied(): -1 | 0 | 1 {\n\t\tif (this.#xs[0].isEmpty() || this.#xs[1].isEmpty() || this.#xs[2].isEmpty()) {\n\t\t\treturn Constraint.UNDEFINED;\n\t\t}\n\t\treturn this.crispRelation().isSatisfied(this.#xs[0].value(), this.#xs[1].value(), this.#xs[2].value()) ? 1 : 0;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsatisfactionDegree(): number {\n\t\tif (this.#xs[0].isEmpty() || this.#xs[1].isEmpty() || this.#xs[2].isEmpty()) {\n\t\t\treturn Constraint.UNDEFINED;\n\t\t}\n\t\treturn this.fuzzyRelation().satisfactionDegree(this.#xs[0].value(), this.#xs[1].value(), this.#xs[2].value());\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\thighestConsistencyDegree(): number {\n\t\tconst sd: number = this.satisfactionDegree();\n\t\tif (sd !== Constraint.UNDEFINED) {\n\t\t\treturn sd;\n\t\t}\n\t\tlet cd: number = 1;\n\t\tconst v1: number = this.#xs[0].value();\n\t\tconst v2: number = this.#xs[1].value();\n\t\tconst v3: number = this.#xs[2].value();\n\t\tconst d1: Domain = this.#xs[0].domain();\n\t\tconst d2: Domain = this.#xs[1].domain();\n\t\tconst d3: Domain = this.#xs[2].domain();\n\n\t\tif (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\tif (s > cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\n\t\t\tfor (const v2 of d2) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\tif (s > cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n\t\t\tfor (const v3 of d3) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\tif (s > cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if (this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tfor (const v2 of d2) {\n\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\t\tif (s > cd) {\n\t\t\t\t\t\tcd = s;\n\t\t\t\t\t}\n\t\t\t\t\tif (cd === 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tfor (const v3 of d3) {\n\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\t\tif (s > cd) {\n\t\t\t\t\t\tcd = s;\n\t\t\t\t\t}\n\t\t\t\t\tif (cd === 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n\t\t\tfor (const v2 of d2) {\n\t\t\t\tfor (const v3 of d3) {\n\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\t\tif (s > cd) {\n\t\t\t\t\t\tcd = s;\n\t\t\t\t\t}\n\t\t\t\t\tif (cd === 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tfor (const v2 of d2) {\n\t\t\t\t\tfor (const v3 of d3) {\n\t\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\t\t\tif (s > cd) {\n\t\t\t\t\t\t\tcd = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cd === 1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tlowestConsistencyDegree(): number {\n\t\tconst sd: number = this.satisfactionDegree();\n\t\tif (sd !== Constraint.UNDEFINED) {\n\t\t\treturn sd;\n\t\t}\n\t\tlet cd: number = 1;\n\t\tconst v1: number = this.#xs[0].value();\n\t\tconst v2: number = this.#xs[1].value();\n\t\tconst v3: number = this.#xs[2].value();\n\t\tconst d1: Domain = this.#xs[0].domain();\n\t\tconst d2: Domain = this.#xs[1].domain();\n\t\tconst d3: Domain = this.#xs[2].domain();\n\n\t\tif (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\tif (s < cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\n\t\t\tfor (const v2 of d2) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\tif (s < cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n\t\t\tfor (const v3 of d3) {\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\tif (s < cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tfor (const v2 of d2) {\n\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\t\tif (s < cd) {\n\t\t\t\t\t\tcd = s;\n\t\t\t\t\t}\n\t\t\t\t\tif (cd === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tfor (const v3 of d3) {\n\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\t\tif (s < cd) {\n\t\t\t\t\t\tcd = s;\n\t\t\t\t\t}\n\t\t\t\t\tif (cd === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\n\t\t\tfor (const v2 of d2) {\n\t\t\t\tfor (const v3 of d3) {\n\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\t\tif (s < cd) {\n\t\t\t\t\t\tcd = s;\n\t\t\t\t\t}\n\t\t\t\t\tif (cd === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const v1 of d1) {\n\t\t\t\tfor (const v2 of d2) {\n\t\t\t\t\tfor (const v3 of d3) {\n\t\t\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(v1, v2, v3);\n\t\t\t\t\t\tif (s < cd) {\n\t\t\t\t\t\t\tcd = s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cd === 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n}\n","/**\n * The class represents an n-ary constraint.\n * The constructor is not called directly, since it is created by the Problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Constraint } from './constraint';\nimport { Variable } from './variable';\nimport { Domain } from './domain';\nimport { Relation } from './relation';\n\nexport class ConstraintN extends Constraint {\n\n\t#xs: Variable[];\n\t#vs: number[];  // For reuse.\n\n\t// Called only from Problem.\n\tconstructor(r: Relation, ...xs: Variable[]) {\n\t\tsuper(r);\n\t\tthis.#xs = [...xs];\n\t\tthis.#vs = new Array(this.#xs.length);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsize(): number {\n\t\treturn this.#xs.length;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tat(index: number): Variable | undefined {\n\t\treturn this.#xs.at(index);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\thas(x: Variable): boolean {\n\t\treturn this.#xs.includes(x);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tindexOf(x: Variable): number {\n\t\treturn this.#xs.indexOf(x);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tneighbors(): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\n\t\tfor (const x of this.#xs) {\n\t\t\tfor (const c of x) {\n\t\t\t\tif (c !== this) {\n\t\t\t\t\tcs.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t[Symbol.iterator](): Iterator<Variable> {\n\t\treturn this.#xs[Symbol.iterator]();\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\temptyVariableSize(): number {\n\t\tlet n: number = 0;\n\n\t\tfor (const x of this.#xs) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tisDefined(): boolean {\n\t\tfor (const x of this.#xs) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tisSatisfied(): -1 | 0 | 1 {\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tconst x: Variable = this.#xs[i];\n\t\t\tif (x.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tthis.#vs[i] = x.value();\n\t\t}\n\t\treturn this.crispRelation().isSatisfied(...this.#vs) ? 1 : 0;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tsatisfactionDegree(): number {\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tconst x: Variable = this.#xs[i];\n\t\t\tif (x.isEmpty()) {\n\t\t\t\treturn Constraint.UNDEFINED;\n\t\t\t}\n\t\t\tthis.#vs[i] = x.value();\n\t\t}\n\t\treturn this.fuzzyRelation().satisfactionDegree(...this.#vs);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\thighestConsistencyDegree(): number {\n\t\tconst sd: number = this.satisfactionDegree();\n\t\tif (sd !== Constraint.UNDEFINED) {\n\t\t\treturn sd;\n\t\t}\n\t\tconst emptyIndices = new Array(this.emptyVariableSize());\n\t\tlet c: number = 0;\n\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tconst x: Variable = this.#xs[i];\n\t\t\tif (x.isEmpty()) {\n\t\t\t\temptyIndices[c++] = i;\n\t\t\t} else {\n\t\t\t\tthis.#vs[i] = x.value();\n\t\t\t}\n\t\t}\n\t\treturn this.checkHCD(emptyIndices, 0, 0);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tlowestConsistencyDegree(): number {\n\t\tconst sd: number = this.satisfactionDegree();\n\t\tif (sd !== Constraint.UNDEFINED) {\n\t\t\treturn sd;\n\t\t}\n\t\tconst emptyIndices = new Array(this.emptyVariableSize());\n\t\tlet c: number = 0;\n\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tconst x: Variable = this.#xs[i];\n\t\t\tif (x.isEmpty()) {\n\t\t\t\temptyIndices[c++] = i;\n\t\t\t} else {\n\t\t\t\tthis.#vs[i] = x.value();\n\t\t\t}\n\t\t}\n\t\treturn this.checkLCD(emptyIndices, 0, 1);\n\t}\n\n\tcheckHCD(emptyIndices: number[], currentStep: number, cd: number): number {\n\t\tconst index: number = emptyIndices[currentStep];\n\t\tconst d: Domain = this.#xs[index].domain();\n\n\t\tif (currentStep === emptyIndices.length - 1) {\n\t\t\tfor (const v of d) {\n\t\t\t\tthis.#vs[index] = v;\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(...this.#vs);\n\t\t\t\tif (s > cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const v of d) {\n\t\t\t\tthis.#vs[index] = v;\n\t\t\t\tcd = this.checkLCD(emptyIndices, currentStep + 1, cd);\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n\tcheckLCD(emptyIndices: number[], currentStep: number, cd: number): number {\n\t\tconst index: number = emptyIndices[currentStep];\n\t\tconst d: Domain = this.#xs[index].domain();\n\n\t\tif (currentStep === emptyIndices.length - 1) {\n\t\t\tfor (const v of d) {\n\t\t\t\tthis.#vs[index] = v;\n\t\t\t\tconst s: number = this.fuzzyRelation().satisfactionDegree(...this.#vs);\n\t\t\t\tif (s < cd) {\n\t\t\t\t\tcd = s;\n\t\t\t\t}\n\t\t\t\tif (cd === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const v of d) {\n\t\t\t\tthis.#vs[index] = v;\n\t\t\t\tcd = this.checkLCD(emptyIndices, currentStep + 1, cd);\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n}\n","/**\n * The class represents a crisp constraint satisfaction problem.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from './problem';\nimport { Variable } from './variable';\nimport { Constraint } from './constraint';\nimport { Relation } from './relation';\n\nexport class CrispProblem extends Problem {\n\n\t/**\n\t * Generates a crisp constraint.\n\t * @param Array args {\n\t *   @type string   'name'      Display name.\n\t *   @type Array    'variables' Variables.\n\t *   @type Relation 'relation'  A relation.\n\t * }\n\t * @return A constraint.\n\t */\n\tcreateConstraint(args: { name?: string, variables: Variable[], relation: Relation; }): Constraint | null {\n\t\tif ('satisfactionDegree' in args.relation) throw new Error();\n\t\treturn super.createConstraint(args);\n\t}\n\n\t/**\n\t * Returns whether the problem is a fuzzy constraint satisfaction problem, i.e., whether it contains fuzzy constraints.\n\t * @return Always returns false.\n\t */\n\tisFuzzy(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns the rate of constraints that are satisfied out of all constraints.\n\t * @return Rate of satisfied constraints.\n\t */\n\tsatisfiedConstraintRate(): number {\n\t\treturn this.satisfiedConstraintSize() / this.constraintSize();\n\t}\n\n\t/**\n\t * Returns the number of satisfied constraints.\n\t * Undefined constraints are ignored.\n\t * @return Number of satisfied constraints.\n\t */\n\tsatisfiedConstraintSize(): number {\n\t\tlet count: number = 0;\n\n\t\tfor (const c of this.constraints()) {\n\t\t\tif (c.isSatisfied() === 1) {\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Returns a list of violating constraints.\n\t * Undefined constraints are ignored.\n\t * @return Array of constraints.\n\t */\n\tviolatingConstraints(): Constraint[] {\n\t\tconst cs: Constraint[] = [];\n\n\t\tfor (const c of this.constraints()) {\n\t\t\tif (c.isSatisfied() === 0) {\n\t\t\t\tcs.push(c);\n\t\t\t}\n\t\t}\n\t\treturn cs;\n\t}\n\n\t/**\n\t * Returns the number of violating constraints.\n\t * Undefined constraints are ignored.\n\t * @return Number of violating constraints.\n\t */\n\tviolatingConstraintSize(): number {\n\t\tlet size: number = 0;\n\n\t\tfor (const c of this.constraints()) {\n\t\t\tif (c.isSatisfied() === 0) {\n\t\t\t\t++size;\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\n\n}\n","/**\n * Classes of utility variables.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Problem } from './problem';\nimport { Variable } from './variable';\nimport { Domain } from './domain';\n\n/**\n * Class that represents an observable variable.\n */\nexport class ObservableVariable extends Variable {\n\n\t#observer: ((x: Variable, v: number) => void) | null;\n\n\t// Called only from Problem.\n\tconstructor(owner: Problem, d: Domain, observer: (x: Variable, v: number) => void) {\n\t\tsuper(owner, d);\n\t\tthis.#observer = observer;\n\t}\n\n\t/**\n\t * Assign a value.\n\t * @param v Value.\n\t */\n\tassign(v: number): void {\n\t\tsuper.assign(v);\n\t\tif (this.#observer) {\n\t\t\tthis.#observer(this, v);\n\t\t}\n\t}\n\n}\n\n/**\n * Class that represents an imaginary variable.\n */\nexport class ImaginaryVariable extends Variable {\n\n\t#orig: Variable;\n\n\tconstructor(x: Variable) {\n\t\tsuper(x.owner(), x.domain());\n\t\tthis.#orig = x;\n\t\tthis.setName(x.name());\n\t\tthis.assign(x.value());\n\t}\n\n\tassign(v: number): void {\n\t\tthis.#orig.assign(v);\n\t}\n\n\tdomain(): Domain;\n\n\tdomain(d: Domain): void;\n\n\tdomain(d?: Domain): Domain | void {\n\t\tif (d === undefined) {\n\t\t\treturn this.#orig.domain();\n\t\t} else {\n\t\t\tthis.#orig.domain(d);\n\t\t}\n\t}\n\n\tvalue(): number {\n\t\treturn this.#orig.value();\n\t}\n\n}\n","/**\n * Interfaces that represents the relationship between variables.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\n/**\n * An interface that represents the relationship between variables.\n */\nexport interface Relation {\n}\n\n/**\n * The class represents crisp relationships between variables.\n */\nexport interface CrispRelation extends Relation {\n\n\t/**\n\t * Gets whether or not the relation is satisfied in this crisp relation.\n\t * @param vs Values of each variable\n\t * @return Whether or not it is satisfied.\n\t */\n\tisSatisfied(...vs: number[]): -1 | 0 | 1;\n\n}\n\n/**\n * The class represents fuzzy relationships between variables.\n */\nexport interface FuzzyRelation extends Relation {\n\n\t/**\n\t * Gets the satisfaction degree in this fuzzy relation.\n\t * @param vs Values of each variable\n\t * @return A satisfaction degree d (0 <= d <= 1).\n\t */\n\tsatisfactionDegree(...vs: number[]): number;\n\n}\n","/**\n * The class for solvers for finding solutions to constraint satisfaction problems.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../problem/problem';\nimport { AssignmentList } from '../util/assignment-list';\n\nexport class Solver {\n\n\t_debug: boolean = true;\n\n\t#debugOutput: (e: any) => void = (e: any): void => console.log(e);\n\n\t/**\n\t * The crisp/fuzzy constraint satisfaction problem solved by the solver.\n\t */\n\t_pro: Problem;\n\n\t/**\n\t *  Limit number of iterations.\n\t */\n\t_iterLimit: number|null = null;\n\n\t/**\n\t * Time limit.\n\t */\n\t_timeLimit: number|null = null;\n\n\t/**\n\t * Target 'satisfied constraint rate' or 'constraint satisfaction degree'.\n\t */\n\t_targetDeg: number|null = 0.8;\n\n\t/**\n\t * Listeners of this solver.\n\t */\n\t#listener: { foundSolution: ((as: AssignmentList, wd: number) => boolean) }[] = [];\n\n\t/**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param pro A constraint satisfaction problem.\n\t */\n\tconstructor(pro: Problem) {\n\t\tthis._pro = pro;\n\t}\n\n\t/**\n\t * Returns the name of the solver.\n\t * @return The name.\n\t */\n\tname(): string {\n\t\treturn '';\n\t}\n\n\t/**\n\t * Placeholder for implementing an algorithm.\n\t * The solve method calls this method and returns the return value of this method.\n\t * @return True if the algorithm succeeds,\n\t */\n\texec(): boolean {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Sets and limits the maximum number of iterations for the solver's behavior.\n\t * After the specified number of iterations, the solver stops as a failure. The specific behavior depends on the solver.\n\t * @param count Maximum value; null means not set.\n\t */\n\tsetIterationLimit(count: number|null = null): void {\n\t\tthis._iterLimit = count;\n\t}\n\n\t/**\n\t * Sets a time limit on the solver's behavior.\n\t * If the specified time is exceeded, the solver stops as a failure. The specific behavior depends on the solver.\n\t * @param msec Time limit. null means not set.\n\t */\n\tsetTimeLimit(msec: number|null = null): void {\n\t\tthis._timeLimit = msec;\n\t}\n\n\t/**\n\t * The goal to be achieved, which is the condition for stopping the solver, is set as the constraint satisfaction degree (fuzzy) or the percentage of constraints satisfied (crisp).\n\t * The solver stops as success if the specified percentage is reached or exceeded. The specific behavior depends on the solver.\n\t * @param rate Degree or rate. null indicates not set.\n\t */\n\tsetTargetRate(rate: number|null = null): void {\n\t\tthis._targetDeg = rate;\n\t}\n\n\t/**\n\t * Computes the solution to a constraint satisfaction problem.\n\t * The specific meaning of the return value depends on the implementation of the algorithm.\n\t * @return True if the algorithm succeeds\n\t */\n\tsolve(): boolean {\n\t\treturn this.exec();\n\t}\n\n\taddListener(l: { foundSolution: (solution: AssignmentList, worstDegree: number) => boolean; }): void {\n\t\tthis.#listener.push(l);\n\t}\n\n\tremoveListener(l: { foundSolution: (solution: AssignmentList, worstDegree: number) => boolean; }): void {\n\t\tthis.#listener.splice(this.#listener.indexOf(l), 1);\n\t}\n\n\tfoundSolution(solution: AssignmentList, worstDegree: number): boolean {\n\t\tlet finish: boolean = false;\n\n\t\tfor (const l of this.#listener) {\n\t\t\tif (l.foundSolution(solution, worstDegree)) {\n\t\t\t\tfinish = true;\n\t\t\t}\n\t\t}\n\t\treturn finish;\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Sets whether to output debug strings.\n\t * @param boolean flag Do output if true.\n\t */\n\tsetDebugMode(flag: boolean): void {\n\t\tthis._debug = flag;\n\t}\n\n\t/**\n\t * Sets a function that used for outputting debug strings.\n\t * @param function fn Function called when debug output.\n\t */\n\tsetDebugOutput(fn: (e: any) => void): void {\n\t\tthis.#debugOutput = fn;\n\t}\n\n\t_debugOutput(str: any): void {\n\t\tif (this._debug) this.#debugOutput(str);\n\t}\n\n}\n","/**\n * Solver factory class.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Solver } from './solver';\nimport { Problem } from '../problem/problem';\nimport { CrispProblem } from '../problem/problem-crisp';\n\nimport { ForwardChecking } from './crisp/forward-checking';\nimport { MaxForwardChecking } from './crisp/max-forward-checking';\nimport { LocalChanges } from './crisp/local-changes';\nimport { LocalChangesEx } from './crisp/local-changes-ex';\nimport { Breakout } from './crisp/breakout';\nimport { GENET } from './crisp/genet';\nimport { CrispSRS3 } from './crisp/crisp-srs3';\nimport { FuzzyForwardChecking } from './fuzzy/fuzzy-forward-checking';\nimport { FuzzyForwardCheckingBc } from './fuzzy/fuzzy-forward-checking-bc';\nimport { FlexibleLocalChanges } from './fuzzy/flexible-local-changes';\nimport { FlexibleLocalChangesEx } from './fuzzy/flexible-local-changes-ex';\nimport { FuzzyBreakout } from './fuzzy/fuzzy-breakout';\nimport { FuzzyGENET } from './fuzzy/fuzzy-genet';\nimport { SRS3 } from './fuzzy/srs3';\nimport { SRS3_PF } from './fuzzy/srs3-pf';\n\nexport class SolverFactory {\n\n\tstatic crispSolverNames(): string[] {\n\t\treturn [\n\t\t\t/* 0 */ 'Forward Checking',\n\t\t\t/* 1 */ 'Max Forward Checking',\n\t\t\t/* 2 */ 'Local Changes',\n\t\t\t/* 3 */ 'Local Changes Ex',\n\t\t\t/* 4 */ 'Breakout',\n\t\t\t/* 5 */ 'GENET',\n\t\t\t/* 6 */ 'Crisp SRS 3',\n\t\t];\n\t}\n\n\tstatic fuzzySolverNames(): string[] {\n\t\treturn [\n\t\t\t/* 0 */ 'Fuzzy Forward Checking',\n\t\t\t/* 1 */ 'Fuzzy Forward Checking Bc',\n\t\t\t/* 2 */ 'Flexible Local Changes',\n\t\t\t/* 3 */ 'Flexible Local Changes Ex',\n\t\t\t/* 4 */ 'Fuzzy Breakout',\n\t\t\t/* 5 */ 'Fuzzy GENET',\n\t\t\t/* 6 */ 'SRS 3',\n\t\t\t/* 7 */ 'SRS 3 PF',\n\t\t];\n\t}\n\n\tstatic async createSolver(type: string, p: Problem): Promise<Solver | null> {\n\t\tconst cs: Solver | null = await SolverFactory.createCrispSolver(type, p as CrispProblem);\n\t\tif (cs) {\n\t\t\treturn cs;\n\t\t}\n\t\tconst fs: Solver | null = await SolverFactory.createFuzzySolver(type, p);\n\t\tif (fs) {\n\t\t\treturn fs;\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic async createCrispSolver(type: string, p: CrispProblem): Promise<Solver | null> {\n\t\tswitch (type.replaceAll(' ', '')) {\n\t\t\tcase 'ForwardChecking':\n\t\t\tcase 'forward-checking':\n\t\t\t\treturn new ForwardChecking(p);\n\t\t\tcase 'MaxForwardChecking':\n\t\t\tcase 'max-forward-checking':\n\t\t\t\treturn new MaxForwardChecking(p);\n\t\t\tcase 'LocalChanges':\n\t\t\tcase 'local-changes':\n\t\t\t\treturn new LocalChanges(p);\n\t\t\tcase 'LocalChangesEx':\n\t\t\tcase 'local-changes-ex':\n\t\t\t\treturn new LocalChangesEx(p);\n\t\t\tcase 'Breakout':\n\t\t\tcase 'breakout':\n\t\t\t\treturn new Breakout(p);\n\t\t\tcase 'GENET':\n\t\t\tcase 'genet':\n\t\t\t\treturn new GENET(p);\n\t\t\tcase 'CrispSRS3':\n\t\t\tcase 'crisp-srs3':\n\t\t\t\treturn new CrispSRS3(p);\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic async createFuzzySolver(type: string, p: Problem): Promise<Solver | null> {\n\t\tswitch (type.replaceAll(' ', '')) {\n\t\t\tcase 'FuzzyForwardChecking':\n\t\t\tcase 'fuzzy-forward-checking':\n\t\t\t\treturn new FuzzyForwardChecking(p);\n\t\t\tcase 'FuzzyForwardCheckingBc':\n\t\t\tcase 'fuzzy-forward-checking-bc':\n\t\t\t\treturn new FuzzyForwardCheckingBc(p);\n\t\t\tcase 'FlexibleLocalChanges':\n\t\t\tcase 'flexible-local-changes':\n\t\t\t\treturn new FlexibleLocalChanges(p);\n\t\t\tcase 'FlexibleLocalChangesEx':\n\t\t\tcase 'flexible-local-changes-ex':\n\t\t\t\treturn new FlexibleLocalChangesEx(p);\n\t\t\tcase 'FuzzyBreakout':\n\t\t\tcase 'fuzzy-breakout':\n\t\t\t\treturn new FuzzyBreakout(p);\n\t\t\tcase 'FuzzyGENET':\n\t\t\tcase 'fuzzy-genet':\n\t\t\t\treturn new FuzzyGENET(p);\n\t\t\tcase 'SRS3':\n\t\t\tcase 'srs3':\n\t\t\t\treturn new SRS3(p);\n\t\t\tcase 'SRS3PF':\n\t\t\tcase 'SRS3_PF':\n\t\t\tcase 'srs3-pf':\n\t\t\t\treturn new SRS3_PF(p);\n\t\t}\n\t\treturn null;\n\t}\n\n}\n","/**\n * This class that implements the forward checking method.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n * Searches for variable assignments that satisfy all constraints and fails if none are found.\n * Each variable must have its own domain because it hides domain elements as branch pruning.\n * Forward checking is also performed for problems with polynomial constraints.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../../problem/problem';\nimport { CrispProblem } from '../../problem/problem-crisp';\nimport { Variable } from '../../problem/variable';\nimport { Domain } from '../../problem/domain';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { DomainPruner } from '../../util/domain-pruner';\nimport { Solver } from '../solver';\n\nexport class ForwardChecking extends Solver {\n\n\t#xs: Variable[];\n\t#sol: AssignmentList = new AssignmentList();\n\t#relCs: Constraint[][][] = [];  // Table to cache constraints between two variables.\n\n\t#useMRV: boolean = false;\n\n\t#iterCount: number = 0;\n\t#endTime: number = 0;\n\n\t/**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */\n\tconstructor(p: CrispProblem) {\n\t\tsuper(p as Problem);\n\n\t\tthis.#xs = [...this._pro.variables()];\n\t\tfor (const x of this.#xs) {\n\t\t\tx.solverObject = new DomainPruner(x.domain().size());\n\t\t}\n\t\tthis.#initializeRelatedConstraintTable();\n\t}\n\n\tname(): string {\n\t\treturn 'Forward Checking';\n\t}\n\n\t/**\n\t * The settings made by this method are invalid.\n\t */\n\tsetTargetRate(): void {\n\t\t// Do nothing.\n\t}\n\n\t/**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\n\t\tthis.#useMRV = flag;\n\t}\n\n\t// Initializes a table that caches constraints between two variables.\n\t#initializeRelatedConstraintTable(): void {\n\t\tthis.#relCs = [];\n\n\t\tfor (let j: number = 0; j < this.#xs.length; ++j) {\n\t\t\tthis.#relCs.push(new Array(this.#xs.length));\n\n\t\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\t\tif (i < j) {\n\t\t\t\t\tthis.#relCs[j][i] = this._pro.constraintsBetween(this.#xs[i], this.#xs[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\n\t#getConstraintsBetween(i: number, j: number): Constraint[] {\n\t\tif (i < j) {\n\t\t\treturn this.#relCs[j][i];\n\t\t}\n\t\treturn this.#relCs[i][j];\n\t}\n\n\t// Checks for possible assignment to a future variable from the current variable assignment.\n\t#checkForward(level: number, currentIndex: number): boolean {\n\t\tfor (const x_i of this.#xs) {\n\t\t\tif (!x_i.isEmpty()) {\n\t\t\t\tcontinue;  // If it is a past or present variable.\n\t\t\t}\n\t\t\tconst d_i: Domain = x_i.domain();\n\t\t\tconst dp_i: DomainPruner = x_i.solverObject as DomainPruner;\n\t\t\tconst cs: Constraint[] = this.#getConstraintsBetween(currentIndex, x_i.index());\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tif (c.emptyVariableSize() !== 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (let k: number = 0, n: number = d_i.size(); k < n; ++k) {\n\t\t\t\t\tif (dp_i.isValueHidden(k)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tx_i.assign(d_i.at(k));\n\n\t\t\t\t\tif (c.isSatisfied() === 0) {  // Do hide when in violation (not even undefined).\n\t\t\t\t\t\tdp_i.hide(k, level);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx_i.clear();\n\t\t\t\tif (dp_i.isEmpty()) return false;  // Failure if the domain of one of the future variables is empty.\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Returns the index of the smallest domain variable.\n\t#indexOfVariableWithMRV(): number {\n\t\tlet index: number = 0;\n\t\tlet size: number = Number.MAX_VALUE;\n\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tconst x: Variable = this.#xs[i];\n\t\t\tif (!x.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst d: Domain = x.domain();\n\t\t\tconst s: number = d.size() - (x.solverObject as DomainPruner).hiddenSize();\n\t\t\tif (s < size) {\n\t\t\t\tsize = s;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Searches for one variable at a time.\n\t#branch(level: number): boolean {\n\t\t// Failure if repeated a specified number.\n\t\tif (this._iterLimit && this._iterLimit < this.#iterCount++) {\n\t\t\treturn false;\n\t\t}\n\t\t// Failure if time limit is exceeded.\n\t\tif (this.#endTime < Date.now()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (level === this._pro.variableSize()) {\n\t\t\tthis.#sol.setProblem(this._pro);\n\t\t\treturn true;\n\t\t}\n\t\tconst xc_index: number = this.#useMRV ? this.#indexOfVariableWithMRV() : level;\n\n\t\tconst xc: Variable = this.#xs[xc_index];\n\t\tconst d: Domain = xc.domain();\n\t\tconst dp: DomainPruner = xc.solverObject as DomainPruner;\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isValueHidden(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\txc.assign(d.at(i));\n\t\t\tif (this.#checkForward(level, xc_index) && this.#branch(level + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const x of this.#xs) {\n\t\t\t\t(x.solverObject as DomainPruner).reveal(level);\n\t\t\t}\n\t\t}\n\t\txc.clear();\n\t\treturn false;\n\t}\n\n\t// Do search.\n\texec(): boolean {\n\t\tthis.#endTime = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tthis.#iterCount = 0;\n\n\t\tthis._pro.clearAllVariables();\n\t\tconst r: boolean = this.#branch(0);\n\t\tif (r) {\n\t\t} else {\n\t\t\tif (this._iterLimit && this._iterLimit < this.#iterCount) {\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t}\n\t\t\tif (this.#endTime < Date.now()) {\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t}\n\t\t}\n\n\t\tfor (const a of this.#sol) {\n\t\t\ta.apply();\n\t\t\t(a.variable().solverObject as DomainPruner).revealAll();\n\t\t}\n\t\treturn r;\n\t}\n\n}\n","/**\n * The class represents multiple variables and their assignments.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Assignment } from './assignment';\nimport { Variable } from '../problem/variable';\nimport { Problem } from '../problem/problem';\n\nexport class AssignmentList {\n\n\tstatic fromVariables(xs: Iterable<Variable>): AssignmentList {\n\t\tconst al = new AssignmentList();\n\t\tal.setVariables(xs);\n\t\treturn al;\n\t}\n\n\t#as: Assignment[] = [];\n\n\tconstructor() {\n\t}\n\n\tsetProblem(p: Problem): void {\n\t\tthis.#as.length = 0;\n\t\tfor (const x of p.variables()) {\n\t\t\tthis.#as.push(new Assignment({ variable: x, value: x.value() }));\n\t\t}\n\t}\n\n\tsetAssignmentList(al: AssignmentList): void {\n\t\tthis.#as.length = 0;\n\t\tfor (const a of al) {\n\t\t\tthis.#as.push(new Assignment({ variable: a.variable(), value: a.value() }));\n\t\t}\n\t}\n\n\tsetVariables(xs: Iterable<Variable>): void {\n\t\tthis.#as.length = 0;\n\t\tfor (const x of xs) {\n\t\t\tthis.#as.push(new Assignment({ variable: x, value: x.value() }));\n\t\t}\n\t}\n\n\taddVariable(variable: Variable, value: number | null = null): void {\n\t\tthis.#as.push(new Assignment({ variable, value }));\n\t}\n\n\tapply(): void {\n\t\tfor (const a of this.#as) a.apply();\n\t}\n\n\t/**\n\t * Remove all assignments.\n\t */\n\tclear(): void {\n\t\tthis.#as.length = 0;\n\t}\n\n\t/**\n\t * Checks whether the list is empty or not.\n\t * @return True if empty.\n\t */\n\tisEmpty(): boolean {\n\t\treturn this.#as.length === 0;\n\t}\n\n\t/**\n\t * Gets the number of assignments.\n\t * @return Number of assignments.\n\t */\n\tsize(): number {\n\t\treturn this.#as.length;\n\t}\n\n\tdifferenceSize(): number {\n\t\tlet diff: number = 0;\n\n\t\tfor (const a of this.#as) {\n\t\t\tif (a.variable().value() !== a.value()) {\n\t\t\t\t++diff;\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n\n\t/**\n\t * Gets the assignments by specifying their indices.\n\t * @param index Index.\n\t * @return An assignment.\n\t */\n\tat(index: number): Assignment {\n\t\treturn this.#as[index];\n\t}\n\n\t/**\n\t * Gets the iterator of the assignments.\n\t */\n\t[Symbol.iterator](): Iterator<Assignment> {\n\t\treturn this.#as[Symbol.iterator]();\n\t}\n\n\t/**\n\t * Gets an arbitrary assignment.\n\t *\n\t * @return An assignment.\n\t */\n\trandom(): Assignment {\n\t\treturn this.#as[Math.floor(Math.random() * this.#as.length)];\n\t}\n\n}\n","/**\n * The class represents a pair of variables and the values to be assigned to them.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Variable } from '../problem/variable';\n\nexport class Assignment {\n\n\t#x: Variable;\n\t#v: number;\n\n\tconstructor(args: { assignment: Assignment; } | { variable: Variable; value?: number|null }) {\n\t\tif ('assignment' in args) {\n\t\t\tthis.#x = args.assignment.variable();\n\t\t\tthis.#v = args.assignment.value();\n\t\t} else if ('variable' in args) {\n\t\t\tthis.#x = args.variable;\n\t\t\tthis.#v = args.value ?? args.variable.value();\n\t\t} else {\n\t\t\tthrow new RangeError();\n\t\t}\n\t}\n\n\t/**\n\t * Assigns a value to a stored variable.\n\t */\n\tapply(): void {\n\t\tthis.#x.assign(this.#v);\n\t}\n\n\t/**\n\t * Returns a string representation.\n\t * @return A string representation.\n\t */\n\ttoString(): string {\n\t\treturn `v${this.#x.index()} <- ${this.#v}`;\n\t}\n\n\t/**\n\t * Gets the value.\n\t * @return Value.\n\t */\n\tvalue(): number {\n\t\treturn this.#v;\n\t}\n\n\t/**\n\t * Gets the variable.\n\t * @return Variable.\n\t */\n\tvariable(): Variable {\n\t\treturn this.#x;\n\t}\n\n}\n","/**\n * This class holds the branch pruning states for a domain.\n *\n * @author Takuto Yanagida\n * @version 2023-03-25\n */\n\nexport class DomainPruner {\n\n\tstatic #UNHIDDEN: number = -1;\n\n\t#hiddenLevels: number[];\n\t#hiddenSize: number = 0;\n\n\t/**\n\t * Generates a class that holds branch pruning states for a domain.\n\t * @param size Size of the corresponding domain\n\t */\n\tconstructor(size: number) {\n\t\tthis.#hiddenLevels = new Array(size);\n\t\tthis.#hiddenLevels.fill(DomainPruner.#UNHIDDEN);\n\t}\n\n\t/**\n\t * Returns the size of the erased element.\n\t * @return Size of the erased element.\n\t */\n\thiddenSize(): number {\n\t\treturn this.#hiddenSize;\n\t}\n\n\t/**\n\t * Erases the element at the specified index.\n\t * @param index Index.\n\t * @param level Level.\n\t */\n\thide(index: number, level: number): void {\n\t\tif (this.#hiddenLevels[index] === DomainPruner.#UNHIDDEN) {\n\t\t\t++this.#hiddenSize;\n\t\t}\n\t\tthis.#hiddenLevels[index] = level;\n\t}\n\n\t/**\n\t * Returns whether the element is empty or not.\n\t * Returns true if all elements have been erased.\n\t * @return True if empty.\n\t */\n\tisEmpty(): boolean {\n\t\treturn this.#hiddenLevels.length === this.#hiddenSize;\n\t}\n\n\t/**\n\t * Returns whether or not the element at the specified index has been erased.\n\t * @param index Index.\n\t * @return True if erased.\n\t */\n\tisValueHidden(index: number): boolean {\n\t\treturn this.#hiddenLevels[index] !== DomainPruner.#UNHIDDEN;\n\t}\n\n\t/**\n\t * Restores the value that had been erased, by specifying a level.\n\t * @param level Level\n\t */\n\treveal(level: number): void {\n\t\tfor (let i = 0; i < this.#hiddenLevels.length; ++i) {\n\t\t\tif (this.#hiddenLevels[i] === level) {\n\t\t\t\tthis.#hiddenLevels[i] = DomainPruner.#UNHIDDEN;\n\t\t\t\t--this.#hiddenSize;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Restores all erased values.\n\t */\n\trevealAll(): void {\n\t\tthis.#hiddenLevels.fill(DomainPruner.#UNHIDDEN);\n\t\tthis.#hiddenSize = 0;\n\t}\n\n}\n","/**\n * This class that implements the forward checking method.\n * Find the solution to the problem as the maximum CSP.\n * Each variable must have its own domain because it hides domain elements as branch pruning.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../../problem/problem';\nimport { CrispProblem } from '../../problem/problem-crisp';\nimport { Variable } from '../../problem/variable';\nimport { Domain } from '../../problem/domain';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { DomainPruner } from '../../util/domain-pruner';\nimport { Solver } from '../solver';\n\nexport class MaxForwardChecking extends Solver {\n\n\t#xs: Variable[];\n\t#sol: AssignmentList = new AssignmentList();\n\n\t#maxVioCount: number;\n\t#vioCount: number = 0;\n\t#checkedCs: Set<Constraint> = new Set();\n\t#cs: Constraint[] = [];\n\n\t#iterCount: number = 0;\n\t#endTime: number = 0;\n\n\t/**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */\n\tconstructor(p: CrispProblem) {\n\t\tsuper(p as Problem);\n\n\t\tthis.#xs = [...this._pro.variables()];\n\t\tfor (const x of this.#xs) {\n\t\t\tx.solverObject = new DomainPruner(x.domain().size());\n\t\t}\n\t\tthis.#maxVioCount = this._pro.constraintSize();\n\t}\n\n\tname(): string {\n\t\treturn 'Forward Checking for Max CSPs';\n\t}\n\n\t#branch(level: number, vioCount: number): boolean {\n\t\t// Failure if repeated a specified number.\n\t\tif (this._iterLimit && this._iterLimit < this.#iterCount++) {\n\t\t\treturn false;\n\t\t}\n\t\t// Failure if time limit is exceeded.\n\t\tif (this.#endTime < Date.now()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst p = this._pro as CrispProblem;\n\n\t\tif (level === p.variableSize()) {\n\t\t\tconst vcs: number = p.violatingConstraintSize();\n\n\t\t\tif (vcs < this.#maxVioCount) {\n\t\t\t\tthis.#maxVioCount = vcs;\n\t\t\t\tthis.#sol.setProblem(this._pro);\n\t\t\t\tthis._debugOutput(`   refreshed ${this.#maxVioCount}`);\n\t\t\t\tif ((this._targetDeg ?? 1) <= p.satisfiedConstraintRate()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tconst xc: Variable = this.#xs[level];\n\t\tconst d: Domain = xc.domain();\n\t\tconst dp: DomainPruner = xc.solverObject as DomainPruner;\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isValueHidden(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\txc.assign(d.at(i));\n\n\t\t\tthis.#vioCount = vioCount + this.#getAdditionalViolationCount(level, xc);  // for max begin\n\t\t\tif (this.#vioCount > this.#maxVioCount) {\n\t\t\t\tcontinue;  // for max end\n\t\t\t}\n\n\t\t\tif (this.#checkForward(level) && this.#branch(level + 1, this.#vioCount)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const x of this.#xs) {\n\t\t\t\t(x.solverObject as DomainPruner).reveal(level);\n\t\t\t}\n\t\t}\n\t\txc.clear();\n\t\treturn false;\n\t}\n\n\t// Checks for possible assignment to a future variable from the current variable assignment.\n\t#checkForward(level: number): boolean {\n\t\tconst xc: Variable = this.#xs[level];\n\n\t\tfor (let i: number = level + 1; i < this.#xs.length; ++i) {\n\t\t\tconst future: Variable = this.#xs[i];\n\t\t\tthis.#cs = this._pro.constraintsBetween(xc, future);\n\n\t\t\tfor (const c of this.#cs) {\n\t\t\t\tif (c.emptyVariableSize() !== 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (this.#revise(future, c, level)) {\n\t\t\t\t\tif ((future.solverObject as DomainPruner).isEmpty()) {\n\t\t\t\t\t\treturn false;  // Failure if the domain of one of the future variables is empty.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Find the number of constraint violations that have increased due to the current value of the variable vc.\n\t#getAdditionalViolationCount(level: number, xc: Variable): number {\n\t\tlet avc: number = 0;\n\t\tthis.#checkedCs.clear();  // Reuse.\n\n\t\tfor (let i: number = 0; i < level; ++i) {\n\t\t\tthis.#cs = this._pro.constraintsBetween(xc, this.#xs[i]);\n\n\t\t\tfor (const c of this.#cs) {\n\t\t\t\tif (this.#checkedCs.has(c)) {\n\t\t\t\t\t// Because of the possibility of duplication in polynomial constraints\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c.isSatisfied() === 0) {\n\t\t\t\t\t// Neither satisfied nor undefined.\n\t\t\t\t\t++avc;\n\t\t\t\t}\n\t\t\t\tthis.#checkedCs.add(c);\n\t\t\t}\n\t\t}\n\t\treturn avc;\n\t}\n\n\t// Remove values from the domain of v1 that do not correspond to v2. That is, match v1 with v2.\n\t#revise(x1: Variable, c: Constraint, level: number): boolean {\n\t\tlet deleted: boolean = false;\n\n\t\tconst d: Domain = x1.domain();\n\t\tconst dp: DomainPruner = x1.solverObject as DomainPruner;\n\n\t\tfor (let k: number = 0, n: number = d.size(); k < n; ++k) {\n\t\t\tif (dp.isValueHidden(k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx1.assign(d.at(k));\n\n\t\t\tif (c.isSatisfied() === 0 && this.#vioCount + 1 > this.#maxVioCount) {\n\t\t\t\tdp.hide(k, level);\n\t\t\t\tdeleted = true;\n\t\t\t}\n\t\t}\n\t\treturn deleted;\n\t}\n\n\texec(): boolean {\n\t\tthis.#endTime = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tthis.#iterCount = 0;\n\n\t\tthis._pro.clearAllVariables();\n\t\tconst r: boolean = this.#branch(0, 0);\n\t\tif (r) {\n\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t} else {\n\t\t\tif (this._iterLimit && this._iterLimit < this.#iterCount) {\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t}\n\t\t\tif (this.#endTime < Date.now()) {\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t}\n\t\t}\n\n\t\tfor (const a of this.#sol) {\n\t\t\ta.apply();\n\t\t\t(a.variable().solverObject as DomainPruner).revealAll();\n\t\t}\n\t\treturn r;\n\t}\n\n}\n","/**\n * Class implements the local changes method.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../../problem/problem';\nimport { CrispProblem } from '../../problem/problem-crisp';\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\n\nexport class LocalChanges extends Solver {\n\n\tstatic #setPlusElement<T>(s: Set<T>, e: T): Set<T> {\n\t\treturn new Set(s).add(e);\n\t}\n\n\tstatic #setMinusElement<T>(s: Set<T>, e: T): Set<T> {\n\t\tconst sn = new Set(s);\n\t\tsn.delete(e);\n\t\treturn sn;\n\t}\n\n\t#iterCount: number = 0;\n\t#endTime: number = 0;\n\t#globalReturn: boolean = false;\n\n\tconstructor(p: Problem, unassignAll: boolean = false) {\n\t\tsuper(p);\n\t\tif (unassignAll) {\n\t\t\tthis._pro.clearAllVariables();\n\t\t}\n\t}\n\n\tname(): string {\n\t\treturn 'Local Changes';\n\t}\n\n\t#createNewV3(X1_X2: Set<Variable>, x: Variable, v: number): Set<Variable> {\n\t\tconst newX3 = new Set<Variable>();\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const xa of X1_X2) {\n\t\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xa);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tconst origV: number = x.value();  // Save the value.\n\t\tx.assign(v);\n\n\t\tfor (const c of cs) {\n\t\t\tif (c.isSatisfied() === 0) {\n\t\t\t\tfor (const xi of c) {\n\t\t\t\t\tnewX3.add(xi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx.assign(origV);  // Restore the value.\n\t\tnewX3.delete(x);\n\t\treturn newX3;\n\t}\n\n\t#isConsistent(A: Set<Variable>, x: Variable, v: number): boolean {\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const xa of A) {\n\t\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xa);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tconst origV: number = x.value();  // Save the value.\n\t\tx.assign(v);\n\n\t\tfor (const c of cs) {\n\t\t\tif (c.isSatisfied() === 0) {\n\t\t\t\tx.assign(origV);  // Restore the value.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tx.assign(origV);  // Restore the value.\n\t\treturn true;\n\t}\n\n\t#lcValue(X1: Set<Variable>, X2: Set<Variable>, x: Variable, v: number): boolean {\n\t\tif (!this.#isConsistent(X1, x, v)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst X1_X2: Set<Variable> = X1.union(X2);\n\t\tif (this.#isConsistent(X1_X2, x, v)) {\n\t\t\treturn true;\n\t\t}\n\t\tconst X3: Set<Variable> = this.#createNewV3(X1_X2, x, v);\n\n\t\tconst T: Set<Variable> = X1_X2.difference(X3);\n\t\tif (!this.#isConsistent(T, x, v)) {\n\t\t\tthis._debugOutput('bug');\n\t\t}\n\t\tfor (const xx of X3) {\n\t\t\txx.clear();\n\t\t}\n\n\t\tX1 = LocalChanges.#setPlusElement(X1, x);\n\t\tX2 = X2.difference(X3);\n\t\treturn this.#lcVariables(X1, X2, X3);\n\t}\n\n\t#lcVariable(X1: Set<Variable>, X2: Set<Variable>, x: Variable, d: Set<number>): boolean {\n\t\tif (d.size === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst v = d.values().next().value as number;\n\t\tconst al: AssignmentList = AssignmentList.fromVariables(X2);\n\t\tx.assign(v);\n\n\t\tconst ret: boolean = this.#lcValue(X1, X2, x, v);\n\t\tif (ret || this.#globalReturn) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tx.clear();\n\t\tal.apply();\n\n\t\treturn this.#lcVariable(X1, X2, x, LocalChanges.#setMinusElement(d, v));\n\t}\n\n\t#lcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>): boolean {\n\t\tthis._debugOutput(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n\n\t\t// Success if violation rate improves from specified\n\t\tif ((this._targetDeg ?? 1) <= (this._pro as CrispProblem).satisfiedConstraintRate()) {\n\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\tthis.#globalReturn = true;\n\t\t\treturn true;\n\t\t}\n\t\t// Failure if repeated a specified number\n\t\tif (this._iterLimit && this._iterLimit < this.#iterCount++) {\n\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\tthis.#globalReturn = true;\n\t\t\treturn false;\n\t\t}\n\t\t// Failure if time limit is exceeded\n\t\tif (this.#endTime < Date.now()) {\n\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\tthis.#globalReturn = true;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (X3.size === 0) {\n\t\t\treturn true;\n\t\t}\n\t\tconst x = X3.values().next().value as Variable;\n\t\tconst d = new Set<number>();\n\t\tfor (const v of x.domain()) {\n\t\t\td.add(v);\n\t\t}\n\n\t\tconst ret: boolean = this.#lcVariable(X1, X2, x, d);\n\t\tif (!ret || this.#globalReturn) {\n\t\t\treturn ret;\n\t\t}\n\t\tX2 = LocalChanges.#setPlusElement(X2, x);\n\t\tX3 = LocalChanges.#setMinusElement(X3, x);\n\t\treturn this.#lcVariables(X1, X2, X3);\n\t}\n\n\texec(): boolean {\n\t\tthis.#endTime = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tthis.#iterCount = 0;\n\t\tthis.#globalReturn = false;\n\n\t\tif (this._pro.emptyVariableSize() === 0) {\n\t\t\tthis._pro.clearAllVariables();\n\t\t}\n\t\tconst notFixed = new Set<Variable>();\n\t\tconst unassigned = new Set<Variable>();\n\t\tfor (const x of this._pro.variables()) {\n\t\t\t(!x.isEmpty() ? notFixed : unassigned).add(x);\n\t\t}\n\t\treturn this.#lcVariables(new Set(), notFixed, unassigned);\n\t}\n\n}\n","/**\n * Class implements the local changes method.\n * The implementation is optimized by converting recursive calls to loops.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../../problem/problem';\nimport { CrispProblem } from '../../problem/problem-crisp';\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\n\nexport class LocalChangesEx extends Solver {\n\n\tstatic #setPlusElement<T>(s: Set<T>, e: T): Set<T> {\n\t\treturn new Set(s).add(e);\n\t}\n\n\t#iterCount: number = 0;\n\t#endTime: number = 0;\n\t#globalReturn: boolean = false;\n\n\tconstructor(p: Problem, unassignAll: boolean = false) {\n\t\tsuper(p);\n\t\tif (unassignAll) {\n\t\t\tthis._pro.clearAllVariables();\n\t\t}\n\t}\n\n\tname(): string {\n\t\treturn 'Local Changes Ex';\n\t}\n\n\t#createNewV3(X1_X2: Set<Variable>, x: Variable, v: number): Set<Variable> {\n\t\tconst newX3 = new Set<Variable>();\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const xa of X1_X2) {\n\t\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xa);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tconst origV: number = x.value();  // Save the value.\n\t\tx.assign(v);\n\n\t\tfor (const c of cs) {\n\t\t\tif (c.isSatisfied() === 0) {\n\t\t\t\tfor (const xi of c) {\n\t\t\t\t\tnewX3.add(xi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx.assign(origV);  // Restore the value.\n\t\tnewX3.delete(x);\n\t\treturn newX3;\n\t}\n\n\t#isConsistent(A: Set<Variable>, x: Variable, v: number): boolean {\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const xa of A) {\n\t\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xa);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tconst origV: number = x.value();  // Save the value.\n\t\tx.assign(v);\n\n\t\tfor (const c of cs) {\n\t\t\tif (c.isSatisfied() === 0) {\n\t\t\t\tx.assign(origV);  // Restore the value.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tx.assign(origV);  // Restore the value.\n\t\treturn true;\n\t}\n\n\t#lcValue(X1: Set<Variable>, X2: Set<Variable>, x: Variable): boolean {\n\t\tif (!this.#isConsistent(X1, x, x.value())) {\n\t\t\treturn false;\n\t\t}\n\t\tconst X1_X2: Set<Variable> = X1.union(X2);\n\t\tif (this.#isConsistent(X1_X2, x, x.value())) {\n\t\t\treturn true;\n\t\t}\n\t\tconst X3: Set<Variable> = this.#createNewV3(X1_X2, x, x.value());\n\n\t\tX1 = LocalChangesEx.#setPlusElement(X1, x);\n\t\tX2 = X2.difference(X3);\n\t\treturn this.#lcVariables(X1, X2, X3);\n\t}\n\n\t#lcVariable(X1: Set<Variable>, X2: Set<Variable>, x: Variable): boolean {\n\t\tfor (const v of x.domain()) {\n\t\t\tconst al: AssignmentList = AssignmentList.fromVariables(X2);\n\t\t\tx.assign(v);\n\n\t\t\tconst ret: boolean = this.#lcValue(X1, X2, x);\n\t\t\tif (ret || this.#globalReturn) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tx.clear();\n\t\t\tal.apply();\n\t\t}\n\t\treturn false;\n\t}\n\n\t#lcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>): boolean {\n\t\tX2 = new Set(X2);  // Clone\n\t\tX3 = new Set(X3);  // Clone\n\n\t\twhile (true) {\n\t\t\tthis._debugOutput(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n\n\t\t\t// Success if violation rate improves from specified\n\t\t\tif ((this._targetDeg ?? 1) <= (this._pro as CrispProblem).satisfiedConstraintRate()) {\n\t\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\t\tthis.#globalReturn = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Failure if repeated a specified number\n\t\t\tif (this._iterLimit && this._iterLimit < this.#iterCount++) {\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\tthis.#globalReturn = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Failure if time limit is exceeded\n\t\t\tif (this.#endTime < Date.now()) {\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\tthis.#globalReturn = true;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (X3.size === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst x = X3.values().next().value as Variable;\n\t\t\tconst ret: boolean = this.#lcVariable(X1, X2, x);\n\n\t\t\tif (!ret || this.#globalReturn) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tX2.add(x);\n\t\t\tX3.delete(x);\n\t\t}\n\t}\n\n\texec(): boolean {\n\t\tthis.#endTime = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tthis.#iterCount = 0;\n\t\tthis.#globalReturn = false;\n\n\t\tif (this._pro.emptyVariableSize() === 0) {\n\t\t\tthis._pro.clearAllVariables();\n\t\t}\n\t\tconst notFixed = new Set<Variable>();\n\t\tconst unassigned = new Set<Variable>();\n\t\tfor (const x of this._pro.variables()) {\n\t\t\t(!x.isEmpty() ? notFixed : unassigned).add(x);\n\t\t}\n\t\treturn this.#lcVariables(new Set(), notFixed, unassigned);\n\t}\n\n}\n","/**\n * Class implements a solver using the breakout method.\n * Solves a problem as a maximum CSP.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../../problem/problem';\nimport { CrispProblem } from '../../problem/problem-crisp';\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { Assignment } from '../../util/assignment';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\n\nexport class Breakout extends Solver {\n\n\t#isRandom: boolean = true;\n\n\t#ws: number[];\n\n\t/**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */\n\tconstructor(p: CrispProblem) {\n\t\tsuper(p as Problem);\n\n\t\tthis.#ws = new Array(this._pro.constraintSize());\n\t\tthis.#ws.fill(1);\n\t}\n\n\tname(): string {\n\t\treturn 'Breakout';\n\t}\n\n\t/**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of local solutions, but makes the solution unrepeatable.\n\t * @param flag Whether the randomness is enabled.\n\t */\n\tsetRandomness(flag: boolean): void {\n\t\tthis.#isRandom = flag;\n\t}\n\n\t#findCandidates(vioXs: Variable[], canList: AssignmentList): void {\n\t\tlet maxDiff: number = 0;\n\n\t\tfor (const x of vioXs) {\n\t\t\tconst x_v: number = x.value();  // Save the value\n\n\t\t\tlet nowVio: number = 0;\n\t\t\tfor (const c of x) {\n\t\t\t\tnowVio += (1 - c.isSatisfied()) * this.#ws[c.index()];\n\t\t\t}\n\t\t\tout: for (const v of x.domain()) {\n\t\t\t\tif (x_v === v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx.assign(v);\n\t\t\t\tlet diff: number = nowVio;\n\n\t\t\t\tfor (const c of x) {\n\t\t\t\t\tdiff -= (1 - c.isSatisfied()) * this.#ws[c.index()];\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\n\t\t\t\t\tif (diff < maxDiff) {\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (diff > maxDiff) {  // Found assignments that are better than ever before.\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tcanList.clear();\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t} else if (maxDiff !== 0) {  // Found assignments that can be improved to the same level as before.\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.assign(x_v);  // Restore the value.\n\t\t}\n\t}\n\n\t#listViolatingVariables(vioCs: Constraint[]): Variable[] {\n\t\tconst xs = new Set<Variable>();\n\n\t\tfor (const c of vioCs) {\n\t\t\tfor (const x of c) {\n\t\t\t\txs.add(x);\n\t\t\t}\n\t\t}\n\t\treturn Array.from<Variable>(xs);\n\t}\n\n\texec(): boolean {\n\t\tconst endTime: number = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tlet iterCount: number = 0;\n\n\t\tfor (const x of this._pro.variables()) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\tx.assign(x.domain().at(0));\n\t\t\t}\n\t\t}\n\n\t\tconst canList = new AssignmentList();\n\t\tconst p = this._pro as CrispProblem;\n\n\t\twhile (true) {\n\t\t\tconst vcs: Constraint[] = p.violatingConstraints();\n\t\t\t// Success if violation rate improves from specified\n\t\t\tif ((this._targetDeg ?? 1) <= p.satisfiedConstraintRate()) {\n\t\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Failure if repeated a specified number\n\t\t\tif (this._iterLimit && this._iterLimit < iterCount++) {\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Failure if time limit is exceeded\n\t\t\tif (endTime < Date.now()) {\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis._debugOutput(vcs.length + ' violations');\n\t\t\tthis.#findCandidates(this.#listViolatingVariables(vcs), canList);\n\n\t\t\tif (0 < canList.size()) {\n\t\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\n\t\t\t\ta.apply();\n\t\t\t\tcanList.clear();\n\t\t\t\tthis._debugOutput('\\t' + a);\n\t\t\t} else {\n\t\t\t\tfor (const c of vcs) {\n\t\t\t\t\tthis.#ws[c.index()] += 1;\n\t\t\t\t}\n\t\t\t\tthis._debugOutput('breakout');\n\t\t\t}\n\t\t}\n\t}\n\n}\n","/**\n * This class implements GENET.\n * CSP (but only Binary CSP) is supported.\n * Find the solution to the problem as the maximum CSP.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\nimport { Problem } from '../../problem/problem';\nimport { CrispProblem } from '../../problem/problem-crisp';\nimport { Variable } from '../../problem/variable';\n\nexport class GENET extends Solver {\n\n\tstatic nextInt(max: number): number {\n\t\treturn Math.floor(Math.random() * Math.floor(max));\n\t}\n\n\t#clusters: Cluster[] = [];\n\t#connections: Connection[] = [];\n\n\t/**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */\n\tconstructor(p: CrispProblem) {\n\t\tsuper(p as Problem);\n\t}\n\n\tname(): string {\n\t\treturn 'GENET';\n\t}\n\n\t#createNetwork(): boolean {\n\t\tthis._debugOutput('network creation start');\n\t\tconst cons: Connection[] = [];\n\n\t\tfor (const x of this._pro.variables()) {\n\t\t\tif (x.domain().size() === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.#clusters.push(new Cluster(x));\n\t\t}\n\t\tfor (const c of this._pro.constraints()) {\n\t\t\tif (c.size() === 1) {  // In the case of unary constraints.\n\t\t\t\tconst x = c.at(0) as Variable;\n\t\t\t\tconst cl: Cluster = this.#clusters[x.index()];\n\n\t\t\t\tfor (let i: number = 0; i < cl.size(); ++i) {\n\t\t\t\t\tconst origV: number = x.value();  // Save the value.\n\t\t\t\t\tx.assign(cl.get(i)._value);\n\n\t\t\t\t\tif (c.isSatisfied() === 0) {\n\t\t\t\t\t\tcons.push(new Connection(cl.get(i)));\n\t\t\t\t\t}\n\t\t\t\t\tx.assign(origV);  // Restore the value.\n\t\t\t\t}\n\t\t\t} else {  // In the case of binary constraints.\n\t\t\t\tconst x1 = c.at(0) as Variable;\n\t\t\t\tconst x2 = c.at(1) as Variable;\n\t\t\t\tconst cl_f: Cluster = this.#clusters[x1.index()];\n\t\t\t\tconst cl_s: Cluster = this.#clusters[x2.index()];\n\n\t\t\t\tfor (let i: number = 0; i < cl_f.size(); ++i) {\n\t\t\t\t\tconst origV1: number = x1.value();  // Save the value.\n\t\t\t\t\tx1.assign(cl_f.get(i)._value);\n\n\t\t\t\t\tfor (let j: number = 0; j < cl_s.size(); ++j) {\n\t\t\t\t\t\tconst origV2: number = x2.value();  // Save the value.\n\t\t\t\t\t\tx2.assign(cl_s.get(j)._value);\n\n\t\t\t\t\t\tif (c.isSatisfied() === 0) {\n\t\t\t\t\t\t\tcons.push(new Connection(cl_f.get(i), cl_s.get(j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx2.assign(origV2);  // Restore the value.\n\t\t\t\t\t}\n\t\t\t\t\tx1.assign(origV1);  // Restore the value.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const cl of this.#clusters) {\n\t\t\tfor (const n of cl._neurons) {\n\t\t\t\tn.lockConnections();\n\t\t\t}\n\t\t}\n\t\tthis.#connections = cons;\n\t\tthis._debugOutput('network creation complete');\n\t\treturn true;\n\t}\n\n\t#shuffle(is: number[]): number[] {\n\t\tfor (let i: number = is.length; i > 1; --i) {\n\t\t\tconst j: number = GENET.nextInt(i);\n\t\t\tconst temp: number = is[i - 1];\n\t\t\tis[i - 1] = is[j];\n\t\t\tis[j] = temp;\n\t\t}\n\t\treturn is;\n\t}\n\n\texec(): boolean {\n\t\tif (!this.#createNetwork()) {\n\t\t\tthrow new Error();\n\t\t}\n\t\tconst endTime: number = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tlet iterCount: number = 0;\n\n\t\tconst sol = new AssignmentList();\n\t\tconst order: number[] = [];\n\t\tfor (let i: number = 0; i < this.#clusters.length; ++i) {\n\t\t\torder.push(i);\n\t\t}\n\n\t\tconst p = this._pro as CrispProblem;\n\t\tlet cur: number = p.satisfiedConstraintRate();\n\t\tlet success: boolean = false;\n\n\t\twhile (true) {\n\t\t\tif (this._iterLimit && this._iterLimit < iterCount++) {  // Failure if repeated a specified number\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (endTime < Date.now()) {  // Failure if time limit is exceeded\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet modified: boolean = false;\n\t\t\tfor (const i of this.#shuffle(order)) {\n\t\t\t\tif (this.#clusters[i].setActivityMaximumInput()) {\n\t\t\t\t\tmodified = true;  // Turn on the node with the largest input in each cluster\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!modified) {  // When the local minimum solution is reached.\n\t\t\t\tfor (const con of this.#connections) {\n\t\t\t\t\tcon.refreshWeight();  // Update weights for all connections\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const clu of this.#clusters) {\n\t\t\t\t\tclu.applyToVariable();  // Apply to variable\n\t\t\t\t}\n\t\t\t\tconst rate: number = p.satisfiedConstraintRate();\n\t\t\t\tif (cur < rate) {  // If it's a better assignment than ever, save it.\n\t\t\t\t\tcur = rate;\n\t\t\t\t\tthis._debugOutput(`satisfied constraint rate: ${rate}`);\n\t\t\t\t\tsol.setProblem(this._pro);\n\t\t\t\t\tif (this.foundSolution(sol, rate)) {  // Call hook\n\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._targetDeg ?? 1 <= cur) {  // Success if violation rate improves from specified\n\t\t\t\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsol.apply();  // Despite the failures, the best assignment so far is applied for now.\n\t\treturn success;\n\t}\n\n}\n\nclass Cluster {\n\n\tstatic nextInt(max: number): number {\n\t\treturn Math.floor(Math.random() * Math.floor(max));\n\t}\n\n\t#x: Variable;  // For avoiding a bug(?) of parcel.\n\t#index: number = 0;\n\t#maxNeurons: number[] = [];\n\t_neurons: Neuron[] = [];\n\n\tconstructor(x: Variable) {\n\t\tthis.#x = x;\n\n\t\tfor (const v of x.domain()) {\n\t\t\tthis._neurons.push(new Neuron(v));\n\t\t}\n\t\tthis.#setActivity(Cluster.nextInt(this._neurons.length));\n\t}\n\n\t#setActivity(index: number): void {\n\t\tfor (const n of this._neurons) {\n\t\t\tn._isActive = false;\n\t\t}\n\t\tthis._neurons[index]._isActive = true;\n\t\tthis.#index = index;\n\t}\n\n\tapplyToVariable(): void {\n\t\tthis.#x.assign(this._neurons[this.#index]._value);\n\t}\n\n\tget(index: number): Neuron {\n\t\treturn this._neurons[index];\n\t}\n\n\tneurons(): Neuron[] {\n\t\treturn this._neurons;\n\t}\n\n\t// Turn on the node with the largest input.\n\tsetActivityMaximumInput(): boolean {\n\t\tthis.#maxNeurons.length = 0;\n\n\t\tlet max: number = Number.NEGATIVE_INFINITY;\n\t\tlet alreadyOn: boolean = false;\n\n\t\tfor (let i: number = 0; i < this._neurons.length; ++i) {\n\t\t\tconst input: number = this._neurons[i].getInput();\n\n\t\t\tif (max <= input) {\n\t\t\t\tif (max < input) {\n\t\t\t\t\tmax = input;\n\t\t\t\t\tthis.#maxNeurons.length = 0;\n\t\t\t\t\talreadyOn = false;\n\t\t\t\t}\n\t\t\t\tthis.#maxNeurons.push(i);\n\t\t\t\tif (this.#index === i) {\n\t\t\t\t\talreadyOn = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (alreadyOn || this.#maxNeurons.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.#setActivity(this.#maxNeurons[Cluster.nextInt(this.#maxNeurons.length)]);\n\t\treturn true;\n\t}\n\n\tsize(): number {\n\t\treturn this._neurons.length;\n\t}\n\n}\n\nclass Connection {\n\n\t#first: Neuron;\n\t#second: Neuron | null;\n\t_weight: number;  // Direct reference (read) allowed.\n\n\t// Order of neurons must be the same as the order of variables that the constraint has.\n\tconstructor(first: Neuron, second: Neuron | null = null) {\n\t\tthis._weight = -1;\n\n\t\tthis.#first = first;\n\t\tthis.#first.addConnection(this);\n\t\tthis.#second = second;\n\t\tif (this.#second) {\n\t\t\tthis.#second.addConnection(this);\n\t\t}\n\t}\n\n\tgetNeuron(self: Neuron): Neuron | null {\n\t\tif (self === this.#first) return this.#second;\n\t\tif (self === this.#second) return this.#first;\n\t\treturn null;\n\t}\n\n\trefreshWeight(): void {\n\t\tif (!this.#first._isActive || (this.#second !== null && !this.#second._isActive)) {\n\t\t\treturn;\n\t\t}\n\t\tthis._weight += -1;\n\t}\n\n}\n\nclass Neuron {\n\n\t#conTemp: Connection[] | null = [];\n\t#connections: Connection[] = [];\n\n\t_value: number;  // Direct reference (read) allowed.\n\t_isActive: boolean = false;  // Direct reference (read, write) allowed.\n\n\tconstructor(value: number) {\n\t\tthis._value = value;\n\t}\n\n\taddConnection(c: Connection): void {\n\t\t(this.#conTemp as Connection[]).push(c);\n\t}\n\n\tlockConnections(): void {\n\t\tthis.#connections = [...this.#conTemp as Connection[]];\n\t\tthis.#conTemp = null;  // No longer being used.\n\t}\n\n\tgetInput(): number {\n\t\tlet ret: number = 0;\n\n\t\tfor (const c of this.#connections) {\n\t\t\tconst n: Neuron | null = c.getNeuron(this);  // If n is null, then the unary constraint.\n\t\t\tret += c._weight * ((n === null || n._isActive) ? 1 : 0);\n\t\t}\n\t\treturn ret;\n\t}\n\n}\n","/**\n * This class implements the SRS algorithm for crisp CSP.\n * The given crisp CSP is treated as the maximum CSP.\n * Similar to SRS 3, the repair algorithm searches for an assignment that\n * satisfies itself without reducing the number of satisfactions of its neighbors.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../../problem/problem';\nimport { CrispProblem } from '../../problem/problem-crisp';\nimport { Constraint } from '../../problem/constraint';\nimport { Assignment } from '../../util/assignment';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\n\nexport class CrispSRS3 extends Solver {\n\n\t#isRandom: boolean = true;\n\n\t#closedList: Set<TreeNode> = new Set();\n\t#openList: Set<TreeNode> = new Set();  // LinkedHashSet is used in the original implementation.\n\t#nodes: TreeNode[] = [];\n\t#neighborConstraints: (Constraint[] | null)[] = [];  // Cache\n\n\t/**\n\t * Generates a solver given a constraint satisfaction problem.\n\t * @param p A crisp problem.\n\t */\n\tconstructor(p: CrispProblem) {\n\t\tsuper(p as Problem);\n\n\t\tfor (const c of this._pro.constraints()) {\n\t\t\tthis.#nodes.push(new TreeNode(c));\n\t\t\tthis.#neighborConstraints.push(null);\n\t\t}\n\t}\n\n\tname(): string {\n\t\treturn 'SRS 3 for Crisp CSPs';\n\t}\n\n\t/**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of falling into a local solution, but makes the solution unrepeatable.\n\t * @param flag If true, randomness is enabled.\n\t */\n\tsetRandomness(flag: boolean): void {\n\t\tthis.#isRandom = flag;\n\t}\n\n\t#getNeighborConstraints(c: Constraint): Constraint[] {\n\t\tconst i: number = c.index();\n\n\t\tif (this.#neighborConstraints[i] === null) {\n\t\t\tthis.#neighborConstraints[i] = c.neighbors();\n\t\t}\n\t\treturn this.#neighborConstraints[i];\n\t}\n\n\t#repair(c0: Constraint): boolean {\n\t\tthis._debugOutput('repair');\n\n\t\tconst canList = new AssignmentList();\n\t\tlet maxDiff: number = 0;\n\n\t\tfor (const x of c0) {\n\t\t\tconst x_v: number = x.value();  // Save the value\n\n\t\t\tlet nowVio: number = 0;\n\t\t\tfor (const c of x) {\n\t\t\t\tnowVio += (1 - c.isSatisfied());\n\t\t\t}\n\t\t\tout: for (const v of x.domain()) {\n\t\t\t\tif (x_v === v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx.assign(v);\n\t\t\t\tif (c0.isSatisfied() !== 1) {\n\t\t\t\t\tcontinue;  // Assuming c0 improvement\n\t\t\t\t}\n\t\t\t\tlet diff: number = nowVio;\n\t\t\t\tfor (const c of x) {\n\t\t\t\t\tdiff -= (1 - c.isSatisfied());\n\t\t\t\t\tif (diff < maxDiff) {\n\t\t\t\t\t\tcontinue out;  // If the improvement is less than the previous improvement, try the next variable.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (diff > maxDiff) {  // An assignment that are better than ever before is found.\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tcanList.clear();\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t} else if (maxDiff !== 0) {  // An assignments that can be improved to the same level as before is found.\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.assign(x_v);  // Restore the value\n\t\t}\n\t\tif (canList.size() > 0) {\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\n\t\t\ta.apply();\n\t\t\tthis._debugOutput('\\t' + a);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t#shrink(node: TreeNode, c_stars: Set<TreeNode>): void {\n\t\tconst temp: TreeNode[] = [];\n\t\tlet cur: TreeNode = node;\n\n\t\twhile (true) {  // This procedure is originally a recursive call, but converted to a loop\n\t\t\tcur = cur.parent() as TreeNode;\n\t\t\ttemp.length = 0;\n\t\t\tcur.getDescendants(temp);\n\t\t\tcur.clear();\n\n\t\t\tfor (const n of c_stars) {\n\t\t\t\tthis.#openList.delete(n);\n\t\t\t\tthis.#closedList.delete(n);\n\t\t\t}\n\n\t\t\tif (c_stars.delete(cur)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.#openList.add(cur);\n\t\t\tif (cur.parent() !== null && !this.#repair((cur.parent() as TreeNode).getObject())) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t#spread(n: TreeNode): void {\n\t\tthis._debugOutput('spread');\n\t\tthis.#closedList.add(n);\n\n\t\tfor (const c of this.#getNeighborConstraints(n.getObject())) {\n\t\t\tconst tnc: TreeNode = this.#nodes[c.index()];\n\n\t\t\tif (!this.#closedList.has(tnc) && !this.#openList.has(tnc)) {  // For constraints that are not included in Open or Closed\n\t\t\t\ttnc.clear();  // Because of its reuse, it may have had children when it was used before.\n\t\t\t\tn.add(tnc);\n\t\t\t\tthis.#openList.add(tnc);\n\t\t\t}\n\t\t}\n\t}\n\n\t#srs(c_stars: Set<TreeNode>): boolean {\n\t\tthis._debugOutput('srs');\n\t\tconst endTime: number = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tlet iterCount: number = 0;\n\n\t\tthis.#closedList.clear();\n\t\tthis.#openList.clear();\n\t\tfor (const n of c_stars) {\n\t\t\tthis.#openList.add(n);\n\t\t}\n\t\tconst p = this._pro as CrispProblem;\n\n\t\twhile (c_stars.size && this.#openList.size) {\n\t\t\tif ((this._targetDeg ?? 1) <= p.satisfiedConstraintRate()) {  // Success if violation rate improves from specified\n\t\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this._iterLimit && this._iterLimit < iterCount++) {  // Failure if repeated a specified number\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (endTime < Date.now()) {  // Failure if time limit is exceeded\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst node: TreeNode = this.#openList.values().next().value as TreeNode;\n\t\t\tthis.#openList.delete(node);\n\n\t\t\tif (this.#repair(node.getObject())) {\n\t\t\t\tif (!c_stars.delete(node)) {  // If the repaired node is included in C* (to be deleted)\n\t\t\t\t\tif (node.parent() !== null && this.#repair((node.parent() as TreeNode).getObject() as Constraint)) {  // When its improvement leads to the improvement of its parents\n\t\t\t\t\t\tthis.#shrink(node, c_stars);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.#spread(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {  // In case of repair failure\n\t\t\t\tthis.#spread(node);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texec(): boolean {\n\t\tconst vcs: Constraint[] = (this._pro as CrispProblem).violatingConstraints();\n\t\tconst c_stars = new Set<TreeNode>();\n\n\t\tfor (const c of vcs) {\n\t\t\tconst tnc: TreeNode = this.#nodes[c.index()];\n\t\t\tc_stars.add(tnc);\n\t\t}\n\t\tif (this.#srs(c_stars)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn c_stars.size === 0;\n\t}\n\n}\n\nclass TreeNode {\n\n\t#children: TreeNode[] = [];\n\t#parent: TreeNode | null;\n\t#obj: any;\n\n\tconstructor(obj: any) {\n\t\tthis.#parent = null;\n\t\tthis.#obj = obj;\n\t}\n\n\tadd(tn: TreeNode): void {\n\t\ttn.#parent = this;\n\t\tthis.#children.push(tn);\n\t}\n\n\tclear(): void {\n\t\tfor (const tn of this.#children) {\n\t\t\ttn.#parent = null;\n\t\t}\n\t\tthis.#children.length = 0;\n\t}\n\n\tgetDescendants(tns: TreeNode[]): void {\n\t\ttns.push(this);\n\n\t\tfor (const tn of this.#children) {\n\t\t\ttn.getDescendants(tns);\n\t\t}\n\t}\n\n\tgetObject(): any {\n\t\treturn this.#obj;\n\t}\n\n\tparent(): TreeNode | null {\n\t\treturn this.#parent;\n\t}\n\n}\n","/**\n * This class implements the forward checking method for fuzzy CSP.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n * Each variable must have its own domain because it hides domain elements as branch pruning.\n * Forward checking is also performed for problems with polynomial constraints.\n *\n * @author Takuto Yanagida\n * @version 2024-10-23\n */\n\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\nimport { Domain } from '../../problem/domain';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { DomainPruner } from '../../util/domain-pruner';\nimport { Solver } from '../solver';\n\nexport class FuzzyForwardChecking extends Solver {\n\n\tstatic CONTINUE: number = 0;\n\tstatic TERMINATE: number = 1;\n\n\t#xs: Variable[];\n\t#sol: AssignmentList = new AssignmentList();\n\t#relCons: Constraint[][][] = [];  // Table to cache constraints between two variables.\n\n\t#solWorstDeg: number = 0;  // Degree of existing solutions (no need to find a solution less than this).\n\n\t#iterCount: number = 0;\n\t#endTime: number = 0;\n\t#useMRV: boolean = false;\n\t#degInc: number = 0;\n\n\t#sequence: Variable[];\n\t#unaryCons: Constraint[];\n\t#checkedCons: boolean[];\n\t#pruneIntensively: boolean = false;\n\n\t/**\n\t * Generates the solver given a fuzzy constraint satisfaction problem.\n\t * @param p A fuzzy problem.\n\t * @param worstSatisfactionDegree Worst satisfaction degree.\n\t */\n\tconstructor(p: Problem, worstSatisfactionDegree: number | null = null) {\n\t\tsuper(p);\n\t\tthis.#xs = [...this._pro.variables()];\n\t\tthis.#sequence = new Array(this._pro.variableSize());\n\t\tthis.#initializeRelatedConstraintTable();\n\t\tthis.#checkedCons = new Array(this._pro.constraintSize());\n\n\t\tconst temp: Constraint[] = [];\n\t\tfor (const c of this._pro.constraints()) {\n\t\t\tif (c.size() === 1) temp.push(c);\n\t\t}\n\t\tthis.#unaryCons = [...temp];  // To make it even if it is empty.\n\t\tif (worstSatisfactionDegree) {\n\t\t\tthis.#solWorstDeg = worstSatisfactionDegree;\n\t\t}\n\t}\n\n\tname(): string {\n\t\treturn 'Forward Checking for Fuzzy CSPs';\n\t}\n\n\t/**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\n\t\tthis.#useMRV = flag;\n\t}\n\n\t/**\n\t * If a solution is found and the search continues, it specifies how much the worst constraint satisfaction degree should be increased.\n\t * @param degree Increasing constraint satisfaction degree.\n\t */\n\tsetIncrementStepOfWorstSatisfactionDegree(degree: number): void {\n\t\tthis.#degInc = degree;\n\t}\n\n\t/**\n\t * Specifies whether or not to intensively prune branches when the problem contains 3- or n-ary constraints.\n\t * Depending on the problem, intensive pruning may increase processing time.\n\t * Default is false.\n\t * @param flag Whether or not to intensively prune branches.\n\t */\n\tsetIntensivePruning(flag: boolean): void {\n\t\tthis.#pruneIntensively = flag;\n\t}\n\n\t/**\n\t * Constraint satisfaction degree is set as an achievement goal that serves as a condition for stopping the solver.\n\t * The solver stops as successful when the specified degree is reached or exceeded.\n\t * The default (unset) is 0.8.\n\t * @param rate Degree. null indicates not set.\n\t */\n\tsetTargetRate(rate: number | null = null): void {\n\t\tthis._targetDeg = rate;\n\t\tif (this._targetDeg === null) {\n\t\t\tthis.#solWorstDeg = 0;\n\t\t} else {\n\t\t\t// Find the worstSatisfactionDegree_ that is slightly smaller than the targetDegree_.\n\t\t\tlet e: number = Number.MIN_VALUE;\n\t\t\tthis.#solWorstDeg = this._targetDeg - e;\n\t\t\twhile (this.#solWorstDeg >= this._targetDeg) {\n\t\t\t\te *= 10;\n\t\t\t\tthis.#solWorstDeg = this._targetDeg - e;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Initializes a table that caches constraints between two variables.\n\t#initializeRelatedConstraintTable(): void {\n\t\tthis.#relCons = [];\n\n\t\tfor (let j: number = 0; j < this.#xs.length; ++j) {\n\t\t\tthis.#relCons.push(new Array(this.#xs.length));\n\n\t\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\t\tif (i < j) {\n\t\t\t\t\tthis.#relCons[j][i] = this._pro.constraintsBetween(this.#xs[i], this.#xs[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\n\t#getConstraintsBetween(vi_index: number, vj_index: number): Constraint[] {\n\t\tif (vi_index < vj_index) {\n\t\t\treturn this.#relCons[vj_index][vi_index];\n\t\t}\n\t\treturn this.#relCons[vi_index][vj_index];\n\t}\n\n\t// Prune elements of the domain that make the unary constraint worse than the current worst degree.\n\t#pruneUnaryConstraints(): boolean {\n\t\tfor (const c of this.#unaryCons) {\n\t\t\tconst x = c.at(0) as Variable;\n\t\t\tconst orgVal: number = x.value();  // Save the value.\n\t\t\tconst d: Domain = x.domain();\n\t\t\tconst dp: DomainPruner = x.solverObject;\n\n\t\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\t\tx.assign(d.at(i));\n\t\t\t\tif (c.satisfactionDegree() <= this.#solWorstDeg) {\n\t\t\t\t\tdp.hide(i, -1);  // Here's a branch pruning!\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.assign(orgVal);  // Restore the value.\n\t\t\tif (dp.isEmpty()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\n\t#checkForwardConsistency(level: number, vi: Variable, c: Constraint): boolean {\n\t\tconst d_i: Domain = vi.domain();\n\t\tconst dp_i: DomainPruner = vi.solverObject;\n\n\t\tfor (let i: number = 0, n: number = d_i.size(); i < n; ++i) {\n\t\t\tif (dp_i.isValueHidden(i)) continue;\n\t\t\tvi.assign(d_i.at(i));\n\t\t\tif (c.satisfactionDegree() <= this.#solWorstDeg) {  // It is not a solution when it is 'smaller than or equals'.\n\t\t\t\tdp_i.hide(i, level);  // Here's a branch pruning!\n\t\t\t}\n\t\t}\n\t\tvi.clear();\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable vi is not empty.\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there are two unassigned variables in the scope of the constraint).\n\t#checkForwardConsistency2(level: number, vi: Variable, c: Constraint) {\n\t\tconst d_i: Domain = vi.domain();\n\t\tconst dp_i: DomainPruner = vi.solverObject;\n\n\t\tlet vj: Variable | null = null;\n\n\t\tfor (const x of c) {\n\t\t\tif (x.isEmpty() && x !== vi) {\n\t\t\t\tvj = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst d_j: Domain = (vj as Variable).domain();\n\t\tconst dp_j: DomainPruner = (vj as Variable).solverObject;\n\t\tloop_i: for (let i: number = 0, ni: number = d_i.size(); i < ni; ++i) {\n\t\t\tif (dp_i.isValueHidden(i)) continue;\n\t\t\tvi.assign(d_i.at(i));  // Tentative assignment to vi\n\t\t\tfor (let j: number = 0, nj: number = d_j.size(); j < nj; ++j) {\n\t\t\t\tif (dp_j.isValueHidden(j)) continue;\n\t\t\t\t(vj as Variable).assign(d_j.at(j));  // Tentative assignment to vj\n\t\t\t\tconst s: number = c.satisfactionDegree();\n\t\t\t\tif (s > this.#solWorstDeg) continue loop_i;  // Tentative assignment to vi was OK -> next tentative assignment.\n\t\t\t}\n\t\t\tdp_i.hide(i, level);  // It is not a solution when it is 'smaller than or equals'.\n\t\t}\n\t\t(vj as Variable).clear();\n\t\tvi.clear();\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable vi is not empty.\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there are three unassigned variables in the scope of the constraint).\n\t#checkForwardConsistency3(level: number, vi: Variable, c: Constraint): boolean {\n\t\tconst d_i: Domain = vi.domain();\n\t\tconst dp_i: DomainPruner = vi.solverObject;\n\n\t\tlet vj: Variable | null = null;\n\t\tlet vk: Variable | null = null;\n\n\t\tfor (const x of c) {\n\t\t\tif (x.isEmpty() && x !== vi) {\n\t\t\t\tif (vj === null) {\n\t\t\t\t\tvj = x;\n\t\t\t\t} else {\n\t\t\t\t\tvk = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst d_j: Domain = (vj as Variable).domain();\n\t\tconst d_k: Domain = (vk as Variable).domain();\n\t\tconst dp_j: DomainPruner = (vj as Variable).solverObject;\n\t\tconst dp_k: DomainPruner = (vk as Variable).solverObject;\n\n\t\tloop_i: for (let i: number = 0, ni: number = d_i.size(); i < ni; ++i) {\n\t\t\tif (dp_i.isValueHidden(i)) continue;\n\t\t\tvi.assign(d_i.at(i));  // Tentative assignment to vi\n\t\t\tfor (let j: number = 0, nj: number = d_j.size(); j < nj; ++j) {\n\t\t\t\tif (dp_j.isValueHidden(j)) continue;\n\t\t\t\t(vj as Variable).assign(d_j.at(j));  // Tentative assignment to vj\n\t\t\t\tfor (let k: number = 0, nk: number = d_k.size(); k < nk; ++k) {\n\t\t\t\t\tif (dp_k.isValueHidden(k)) continue;\n\t\t\t\t\t(vk as Variable).assign(d_k.at(k));  // Tentative assignment to vk\n\t\t\t\t\tconst s: number = c.satisfactionDegree();\n\t\t\t\t\tif (s > this.#solWorstDeg) continue loop_i;  // Tentative assignment to vi was OK -> next tentative assignment.\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp_i.hide(i, level);  // It is not a solution when it is 'smaller than or equals'.\n\t\t}\n\t\t(vk as Variable).clear();\n\t\t(vj as Variable).clear();\n\t\tvi.clear();\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable vi is not empty.\n\t}\n\n\t// In the case of polynomial constraints and when there are four or more unassigned variables, all combinations of assignments of unassigned variables are examined and pruned.\n\t#checkForwardConsistencyN(level: number, v_i: Variable, c: Constraint, emptySize: number): boolean {\n\t\tconst d_i: Domain = v_i.domain();\n\t\tconst dp_i: DomainPruner = v_i.solverObject;\n\t\tconst emp = new Array(emptySize - 1);\n\t\tlet j: number = 0;\n\n\t\tfor (const x of c) {\n\t\t\tif (x.isEmpty() && x !== v_i) {\n\t\t\t\temp[j++] = x;\n\t\t\t}\n\t\t}\n\t\tconst indexes = new Array(emp.length);\n\n\t\tloop_i: for (let i: number = 0, n: number = d_i.size(); i < n; ++i) {\n\t\t\tif (dp_i.isValueHidden(i)) continue;\n\t\t\tv_i.assign(d_i.at(i));  // Tentative assignment to vi\n\t\t\tindexes.fill(0);\n\n\t\t\tcomLoop: while (true) {\n\t\t\t\tlet hidden: boolean = false;\n\t\t\t\tfor (let k: number = 0; k < emp.length; ++k) {\n\t\t\t\t\tconst d_k: Domain = emp[k].domain();\n\t\t\t\t\tconst dp_k: DomainPruner = emp[k].solverObject;\n\t\t\t\t\tif (dp_k.isValueHidden(indexes[k])) {\n\t\t\t\t\t\thidden = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\temp[k].assign(d_k.at(indexes[k]));\n\t\t\t\t}\n\t\t\t\tif (!hidden) {\n\t\t\t\t\tconst s: number = c.satisfactionDegree();\n\t\t\t\t\tif (s > this.#solWorstDeg) continue loop_i;  // Tentative assignment to vi was OK -> next tentative assignment.\n\t\t\t\t}\n\t\t\t\tfor (let k: number = 0; k < emp.length; ++k) {\n\t\t\t\t\tindexes[k] += 1;\n\t\t\t\t\tif (indexes[k] < emp[k].domain().size()) break;\n\t\t\t\t\tindexes[k] = 0;\n\t\t\t\t\tif (k === emp.length - 1) break comLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp_i.hide(i, level);\n\t\t}\n\t\tfor (const x of emp) {\n\t\t\tx.clear();\n\t\t}\n\t\tv_i.clear();\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable vi is not empty.\n\t}\n\n\t// Checks for possible assignment to a future variable from the current variable assignment.\n\t#checkForward(level: number, index: number): boolean {\n\t\tfor (const x_i of this.#xs) {\n\t\t\tif (!x_i.isEmpty()) continue;  // If it is a past or present variable.\n\n\t\t\tconst cs: Constraint[] = this.#getConstraintsBetween(index, x_i.index());\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tconst emptySize: number = c.emptyVariableSize();\n\t\t\t\tif (emptySize === 1) {\n\t\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, c)) return false;\n\t\t\t\t} else if (this.#pruneIntensively) {  // Depends on options\n\t\t\t\t\tif (emptySize === 2) {\n\t\t\t\t\t\tif (!this.#checkForwardConsistency2(level, x_i, c)) return false;\n\t\t\t\t\t} else if (emptySize === 3) {\n\t\t\t\t\t\tif (!this.#checkForwardConsistency3(level, x_i, c)) return false;\n\t\t\t\t\t} else if (emptySize > 3) {\n\t\t\t\t\t\tif (!this.#checkForwardConsistencyN(level, x_i, c, emptySize)) return false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Checks to see if the current variable assignment makes the degree of the past variable worse than the current worst degree.\n\t#checkBackwardConsistency(vc: Variable): boolean {\n\t\tthis.#checkedCons.fill(false);  // Reuse.\n\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {  // Find past variables.\n\t\t\tconst x_i: Variable = this.#xs[i];\n\t\t\tif (x_i === vc || x_i.isEmpty()) continue;  // If it is a future variable or a present variable.\n\t\t\tconst cs: Constraint[] = this.#getConstraintsBetween(vc.index(), i);\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tif (this.#checkedCons[c.index()]) continue;  // Because of the possibility of duplication in polynomial constraints\n\t\t\t\tconst s: number = c.satisfactionDegree();\n\t\t\t\tif (s !== Constraint.UNDEFINED && s <= this.#solWorstDeg) {  // It is not a solution when it is 'smaller than or equals'.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.#checkedCons[c.index()] = true;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t#refresh(): void {\n\t\tfor (let i: number = 0; i < this.#sequence.length; ++i) {\n\t\t\tconst index_x_i: number = this.#sequence[i].index();\n\n\t\t\tfor (let j: number = i + 1; j < this.#sequence.length; ++j) {\n\t\t\t\tconst x_j: Variable = this.#sequence[j];\n\t\t\t\tconst cs: Constraint[] = this.#getConstraintsBetween(index_x_i, x_j.index());\n\n\t\t\t\tfor (const c of cs) {\n\t\t\t\t\tconst orgVal: number = x_j.value();\n\t\t\t\t\tconst d_j: Domain = x_j.domain();\n\t\t\t\t\tconst dp_j: DomainPruner = x_j.solverObject;\n\n\t\t\t\t\tfor (let k: number = 0, n: number = d_j.size(); k < n; ++k) {\n\t\t\t\t\t\tif (dp_j.isValueHidden(k)) continue;\n\t\t\t\t\t\tx_j.assign(d_j.at(k));\n\t\t\t\t\t\tif (c.satisfactionDegree() <= this.#solWorstDeg) {\n\t\t\t\t\t\t\tdp_j.hide(k, i);  // Here's a branch pruning!\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx_j.assign(orgVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Returns the index of the smallest domain variable.\n\t#indexOfVariableWithMRV(): number {\n\t\tlet index: number = 0;\n\t\tlet size: number = Number.MAX_VALUE;\n\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tconst x: Variable = this.#xs[i];\n\t\t\tif (!x.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst d: Domain = x.domain();\n\t\t\tconst s: number = d.size() - x.solverObject.hiddenSize();\n\t\t\tif (s < size) {\n\t\t\t\tsize = s;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Performs search one variable at a time.\n\t#branch(level: number): number {\n\t\tlet bc: number = FuzzyForwardChecking.CONTINUE;\n\t\tconst xc_index: number = this.#useMRV ? this.#indexOfVariableWithMRV() : level;\n\t\tconst xc: Variable = this.#xs[xc_index];\n\t\tconst d: Domain = xc.domain();\n\t\tconst dp: DomainPruner = xc.solverObject;\n\t\tthis.#sequence[level] = xc;\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isValueHidden(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((this._iterLimit && this._iterLimit < this.#iterCount++) || this.#endTime < Date.now()) {\n\t\t\t\tbc = FuzzyForwardChecking.TERMINATE;  // Search terminated due to restrictions.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txc.assign(d.at(i));\n\n\t\t\tfor (const x of this.#xs) x.solverObject.reveal(level);\n\t\t\tif (!this.#checkBackwardConsistency(xc)) continue;\n\t\t\tif (!this.#checkForward(level, xc_index)) continue;\n\n\t\t\tconst nextLevel: number = level + 1;\n\t\t\tbc = (nextLevel === this.#xs.length - 1) ? this.#branchLast(nextLevel) : this.#branch(nextLevel);\n\t\t\tif (bc === FuzzyForwardChecking.TERMINATE) break;\n\t\t}\n\t\tif (bc === FuzzyForwardChecking.CONTINUE) {  // When searching back to the parent, undo the branch pruning here.\n\t\t\tfor (const x of this.#xs) x.solverObject.reveal(level);\n\t\t}\n\t\txc.clear();\n\t\treturn bc;\n\t}\n\n\t// Performs search on the last variable.\n\t#branchLast(level: number): number {\n\t\tlet bc: number = FuzzyForwardChecking.CONTINUE;\n\t\tconst xc: Variable = this.#xs[this.#useMRV ? this.#indexOfVariableWithMRV() : level];\n\t\tconst d: Domain = xc.domain();\n\t\tconst dp: DomainPruner = xc.solverObject;\n\t\tthis.#sequence[level] = xc;\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isValueHidden(i)) continue;\n\t\t\tif ((this._iterLimit && this._iterLimit < this.#iterCount++) || this.#endTime < Date.now()) {\n\t\t\t\tbc = FuzzyForwardChecking.TERMINATE;  // Search terminated due to restrictions.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txc.assign(d.at(i));\n\n\t\t\tconst deg: number = this._pro.worstSatisfactionDegree();\n\t\t\tif (deg > this.#solWorstDeg) {  // A new solution is assumed when 'greater than'.\n\t\t\t\tthis.#solWorstDeg = deg;\n\t\t\t\tthis.#sol.setProblem(this._pro);\n\t\t\t\tbc = FuzzyForwardChecking.TERMINATE;\n\t\t\t\tif (this._targetDeg !== null && this._targetDeg <= this.#solWorstDeg) {  // Search ends when target is reached\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.#pruneUnaryConstraints();\n\t\t\t\tthis.#refresh();\n\t\t\t}\n\t\t}\n\t\txc.clear();\n\t\treturn bc;\n\t}\n\n\t// Do search.\n\texec(): boolean {\n\t\tthis.#endTime = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tthis.#iterCount = 0;\n\n\t\tfor (const x of this.#xs) {\n\t\t\tx.solverObject = new DomainPruner(x.domain().size());  // Generation of domain pruners.\n\t\t}\n\t\tthis._pro.clearAllVariables();\n\t\tif (!this.#pruneUnaryConstraints()) return false;  // Since _worstSatisfactionDegree_ has been updated, call this function.\n\n\t\tlet success: boolean = false;\n\t\twhile (true) {\n\t\t\tconst bc: number = this.#branch(0);\n\t\t\tif (bc === FuzzyForwardChecking.TERMINATE) {\n\t\t\t\tif (this._iterLimit && this._iterLimit < this.#iterCount++) {\n\t\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this.#endTime < Date.now()) {\n\t\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.#sol.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._debugOutput(`\\tfound a solution: ${this.#solWorstDeg}`);\n\t\t\tif (this.foundSolution(this.#sol, this.#solWorstDeg)) {  // Call hook\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (this._targetDeg === null) {  // Degree not specified\n\t\t\t\tsuccess = true;\n\t\t\t\tthis.#solWorstDeg += this.#degInc;  // Find the next solution within the limit.\n\t\t\t} else if (this._targetDeg <= this.#solWorstDeg) {  // The current degree exceeded the specified degree.\n\t\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (const x of this.#xs) {\n\t\t\t\tx.solverObject.revealAll();\n\t\t\t}\n\t\t}\n\t\tthis.#sol.apply();\n\t\tfor (const x of this.#xs) {\n\t\t\tx.solverObject = null;  // Delete branch pruner\n\t\t}\n\t\treturn success;\n\t}\n\n}\n","/**\n * This class implements the forward checking method for fuzzy CSPs that contain only binary constraints.\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\n *\n * @author Takuto Yanagida\n * @version 2024-10-23\n */\n\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\nimport { Domain } from '../../problem/domain';\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { DomainPruner } from '../../util/domain-pruner';\nimport { Solver } from '../solver';\n\nexport class FuzzyForwardCheckingBc extends Solver {\n\n\tstatic CONTINUE: number = 0;\n\tstatic TERMINATE: number = 1;\n\n\t#xs: Variable[];\n\t#sol: AssignmentList = new AssignmentList();\n\t#relCons: Constraint[][][] = [];  // Table to cache constraints between two variables.\n\n\t#solWorstDeg: number = 0;  // Degree of existing solutions (no need to find a solution less than this).\n\n\t#iterCount: number = 0;\n\t#endTime: number = 0;\n\t#useMRV: boolean = false;\n\t#degInc: number = 0;\n\n\t/**\n\t * Generates the solver given a fuzzy constraint satisfaction problem.\n\t * @param p A fuzzy problem.\n\t * @param worstSatisfactionDegree Worst satisfaction degree.\n\t */\n\tconstructor(p: Problem, worstSatisfactionDegree: number | null = null) {\n\t\tsuper(p);\n\t\tthis.#xs = [...this._pro.variables()];\n\t\tthis.#initializeRelatedConstraintTable();\n\n\t\tthis.#solWorstDeg = Math.max(0, p.worstSatisfactionDegree());\n\t\tif (worstSatisfactionDegree) {\n\t\t\tthis.#solWorstDeg = worstSatisfactionDegree;\n\t\t}\n\t}\n\n\tname(): string {\n\t\treturn 'Forward Checking for Fuzzy CSPs of Binary Constraints';\n\t}\n\n\t/**\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\n\t * Use of MRV may increase processing time for some problems.\n\t * Default is false.\n\t * @param flag Use MRV if true.\n\t */\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\n\t\tthis.#useMRV = flag;\n\t}\n\n\t/**\n\t * If a solution is found and the search continues, it specifies how much the worst constraint satisfaction degree should be increased.\n\t * @param degree Increasing constraint satisfaction degree.\n\t */\n\tsetIncrementStepOfWorstSatisfactionDegree(degree: number): void {\n\t\tthis.#degInc = degree;\n\t}\n\n\t/**\n\t * Constraint satisfaction degree is set as an achievement goal that serves as a condition for stopping the solver.\n\t * The solver stops as successful when the specified degree is reached or exceeded.\n\t * The default (unset) is 0.8.\n\t * @param rate Degree. null indicates not set.\n\t */\n\tsetTargetRate(rate = null): void {\n\t\tthis._targetDeg = rate;\n\t\tif (this._targetDeg === null) {\n\t\t\tthis.#solWorstDeg = 0;\n\t\t} else {\n\t\t\t// Find the worstSatisfactionDegree_ that is slightly smaller than the targetDegree_.\n\t\t\tlet e: number = Number.MIN_VALUE;\n\t\t\tthis.#solWorstDeg = this._targetDeg - e;\n\t\t\twhile (this.#solWorstDeg >= this._targetDeg) {\n\t\t\t\te *= 10;\n\t\t\t\tthis.#solWorstDeg = this._targetDeg - e;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Initializes a table that caches constraints between two variables.\n\t#initializeRelatedConstraintTable(): void {\n\t\tthis.#relCons = [];\n\n\t\tfor (let j: number = 0; j < this.#xs.length; ++j) {\n\t\t\tthis.#relCons.push(new Array(this.#xs.length));\n\n\t\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\t\tif (i < j) {\n\t\t\t\t\tthis.#relCons[j][i] = this._pro.constraintsBetween(this.#xs[i], this.#xs[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\n\t#getConstraintsBetween(vi_index: number, vj_index: number): Constraint[] {\n\t\tif (vi_index < vj_index) {\n\t\t\treturn this.#relCons[vj_index][vi_index];\n\t\t}\n\t\treturn this.#relCons[vi_index][vj_index];\n\t}\n\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\n\t#checkForwardConsistency(level: number, vi: Variable, c: Constraint): boolean {\n\t\tconst d_i: Domain = vi.domain();\n\t\tconst dp_i: DomainPruner = vi.solverObject;\n\n\t\tfor (let i: number = 0, n: number = d_i.size(); i < n; ++i) {\n\t\t\tif (dp_i.isValueHidden(i)) continue;\n\t\t\tvi.assign(d_i.at(i));\n\t\t\tif (c.satisfactionDegree() <= this.#solWorstDeg) {  // It is not a solution when it is 'smaller than or equals'.\n\t\t\t\tdp_i.hide(i, level);  // Here's a branch pruning!\n\t\t\t}\n\t\t}\n\t\tvi.clear();\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable vi is not empty.\n\t}\n\n\t// Checks for possible assignment to a future variable from the current variable assignment.\n\t#checkForward(level: number, index: number): boolean {\n\t\tfor (const x_i of this.#xs) {\n\t\t\tif (!x_i.isEmpty()) continue;  // If it is a past or present variable.\n\n\t\t\tconst cs: Constraint[] = this.#getConstraintsBetween(index, x_i.index());\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tif (c.size() === 2) {  // If it is a binary constraint.\n\t\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, c)) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Returns the index of the smallest domain variable.\n\t#indexOfVariableWithMRV(): number {\n\t\tlet index: number = 0;\n\t\tlet size: number = Number.MAX_VALUE;\n\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\n\t\t\tconst x: Variable = this.#xs[i];\n\t\t\tif (!x.isEmpty()) continue;\n\t\t\tconst d: Domain = x.domain();\n\t\t\tconst s: number = d.size() - x.solverObject.hiddenSize();\n\t\t\tif (s < size) {\n\t\t\t\tsize = s;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Performs search one variable at a time.\n\t#branch(level: number): number {\n\t\tlet bc: number = FuzzyForwardCheckingBc.CONTINUE;\n\t\tconst xc_index: number = this.#useMRV ? this.#indexOfVariableWithMRV() : level;\n\t\tconst xc: Variable = this.#xs[xc_index];\n\t\tconst d: Domain = xc.domain();\n\t\tconst dp: DomainPruner = xc.solverObject;\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isValueHidden(i)) continue;\n\t\t\tif ((this._iterLimit && this._iterLimit < this.#iterCount++) || this.#endTime < Date.now()) {\n\t\t\t\tbc = FuzzyForwardCheckingBc.TERMINATE;  // Search terminated due to restrictions.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txc.assign(d.at(i));\n\n\t\t\tfor (const x of this.#xs) {\n\t\t\t\tx.solverObject.reveal(level);\n\t\t\t}\n\t\t\tif (!this.#checkForward(level, xc_index)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst nextLevel: number = level + 1;\n\t\t\tbc = (nextLevel === this.#xs.length - 1) ? this.#branchLast(nextLevel) : this.#branch(nextLevel);\n\t\t\tif (bc === FuzzyForwardCheckingBc.TERMINATE) break;\n\t\t}\n\t\tif (bc === FuzzyForwardCheckingBc.CONTINUE) {  // When searching back to the parent, undo the branch pruning here.\n\t\t\tfor (const v of this.#xs) v.solverObject.reveal(level);\n\t\t}\n\t\txc.clear();\n\t\treturn bc;\n\t}\n\n\t// Performs search on the last variable.\n\t#branchLast(level: number): number {\n\t\tlet bc: number = FuzzyForwardCheckingBc.CONTINUE;\n\t\tconst xc: Variable = this.#xs[this.#useMRV ? this.#indexOfVariableWithMRV() : level];\n\t\tconst d: Domain = xc.domain();\n\t\tconst dp: DomainPruner = xc.solverObject;\n\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\n\t\t\tif (dp.isValueHidden(i)) continue;\n\t\t\tif ((this._iterLimit && this._iterLimit < this.#iterCount++) || this.#endTime < Date.now()) {\n\t\t\t\tbc = FuzzyForwardCheckingBc.TERMINATE;  // Search terminated due to restrictions.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txc.assign(d.at(i));\n\n\t\t\tconst deg: number = this._pro.worstSatisfactionDegree();\n\t\t\tif (deg > this.#solWorstDeg) {  // A new solution is assumed when 'greater than'.\n\t\t\t\tthis.#solWorstDeg = deg;\n\t\t\t\tthis.#sol.setProblem(this._pro);\n\t\t\t\tbc = FuzzyForwardCheckingBc.TERMINATE;  // Search terminated due to restrictions.\n\t\t\t\tif (this._targetDeg !== null && this._targetDeg <= this.#solWorstDeg) {  // Search ends when target is reached\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txc.clear();\n\t\treturn bc;\n\t}\n\n\t// Do search.\n\texec(): boolean {\n\t\tthis.#endTime = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tthis.#iterCount = 0;\n\n\t\tfor (const x of this.#xs) {\n\t\t\tx.solverObject = new DomainPruner(x.domain().size());  // Generation of domain pruners.\n\t\t}\n\t\tthis._pro.clearAllVariables();\n\n\t\tconst sol = new AssignmentList();\n\n\t\tlet success: boolean = false;\n\t\twhile (true) {\n\t\t\tconst bc: number = this.#branch(0);\n\t\t\tif (bc === FuzzyForwardCheckingBc.TERMINATE) {\n\t\t\t\tif (this._iterLimit && this._iterLimit < this.#iterCount++) {\n\t\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this.#endTime < Date.now()) {\n\t\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.#sol.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsol.setAssignmentList(this.#sol);\n\t\t\tthis.#sol.clear();  // Clear it so that if the solution is not found in the next search, it will be known.\n\n\t\t\tthis._debugOutput(`\\tfound a solution: ${this.#solWorstDeg}`);\n\t\t\tif (this.foundSolution(sol, this.#solWorstDeg)) {  // Call hook\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (this._targetDeg === null) {  // Degree not specified\n\t\t\t\tsuccess = true;\n\t\t\t\tif (this.#solWorstDeg + this.#degInc > 1) break;\n\t\t\t\tthis.#solWorstDeg += ((this.#solWorstDeg + this.#degInc > 1) ? 0 : this.#degInc);  // Find the next solution within the limit.\n\t\t\t} else if (this._targetDeg <= this.#solWorstDeg) {  // The current degree exceeded the specified degree.\n\t\t\t\tthis._debugOutput(`stop: current degree is above the target`);\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (const x of this.#xs) {\n\t\t\t\tx.solverObject.revealAll();\n\t\t\t}\n\t\t}\n\t\tsol.apply();\n\t\tfor (const x of this.#xs) {\n\t\t\tx.solverObject = null;  // Delete branch pruner\n\t\t}\n\t\treturn success;\n\t}\n\n}\n","/**\n * A class that implements the flexible local changes method.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\n\nexport class FlexibleLocalChanges extends Solver {\n\n\tstatic #setPlusElement<T>(s: Set<T>, e: T): Set<T> {\n\t\tconst sn = new Set<T>(s);\n\t\tsn.add(e);\n\t\treturn sn;\n\t}\n\n\tstatic #setMinusElement<T>(s: Set<T>, e: T): Set<T> {\n\t\tconst sn = new Set<T>(s);\n\t\tsn.delete(e);\n\t\treturn sn;\n\t}\n\n\t#lt: number = 0;\n\t#lb: number = 0;\n\n\t#iterCount: number = 0;\n\t#endTime: number = 0;\n\t#globalReturn: number = 0;\n\n\tconstructor(p: Problem) {\n\t\tsuper(p);\n\t\tthis.#computeHighestAndLowestConsistencyDegree();\n\t}\n\n\tname(): string {\n\t\treturn 'Flexible Local Changes';\n\t}\n\n\t#choose(x2: Set<Variable>, cr: Set<Constraint>): Set<Variable> {\n\t\tconst res = new Map<Variable, number>();\n\n\t\tfor (const c of cr) {\n\t\t\tif (!c.isDefined()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (const x of c) {\n\t\t\t\tif (!res.has(x)) {\n\t\t\t\t\tres.set(x, 1);\n\t\t\t\t} else {\n\t\t\t\t\tres.set(x, (res.get(x) ?? 0) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst xs: Variable[] = [...x2];\n\t\txs.sort((o1: Variable, o2: Variable): -1 | 0 | 1 => {\n\t\t\tlet res1: number = 0;\n\t\t\tlet res2: number = 0;\n\t\t\tif (res.has(o1)) res1 = res.get(o1) ?? 0;\n\t\t\tif (res.has(o2)) res2 = res.get(o2) ?? 0;\n\n\t\t\tif (res1 < res2) return 1;\n\t\t\tif (res1 > res2) return -1;\n\t\t\treturn 0;\n\t\t});\n\n\t\tconst ret = new Set<Variable>();\n\n\t\tfor (const x of xs) {\n\t\t\tlet remain: boolean = false;\n\t\t\tfor (const c of cr) {\n\t\t\t\tif (c.isDefined()) {\n\t\t\t\t\tremain = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!remain) break;\n\t\t\tx.clear();\n\t\t\tret.add(x);\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#computeHighestAndLowestConsistencyDegree(): void {\n\t\tlet low: number = 1;\n\t\tlet high: number = 0;\n\n\t\tfor (const x of this._pro.variables()) {\n\t\t\tfor (const c of x) {\n\t\t\t\tconst l: number = c.lowestConsistencyDegree();\n\t\t\t\tconst h: number = c.highestConsistencyDegree();\n\t\t\t\tif (l < low) low = l;\n\t\t\t\tif (h > high) high = h;\n\t\t\t}\n\t\t}\n\t\tthis.#lb = low;\n\t\tthis.#lt = high;\n\t}\n\n\t#flcRepair(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>, rc: number): number {\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr);\n\t\tconst X1p: Set<Variable> = FlexibleLocalChanges.#setPlusElement(X1, xi);\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\n\t\treturn this.#flcVariables(X1p, X2p, X3p, consX1xi, Math.min(consX12, consX1xi), rc);\n\t}\n\n\t#flcVariable(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1: number, consX12: number, rc: number): number {\n\t\tlet bestCons: number = this.#lb;\n\t\tif (xi.domain().size() === 0) {\n\t\t\treturn bestCons;\n\t\t}\n\t\tlet bestX2: AssignmentList = AssignmentList.fromVariables(X2);\n\t\tlet bestDij: number = xi.domain().at(0);\n\n\t\tconst x2Store: AssignmentList = AssignmentList.fromVariables(X2);\n\n\t\tfor (let j: number = 0; j < xi.domain().size() && bestCons < consX12; ++j) {\n\t\t\tconst dij: number = xi.domain().at(j);\n\t\t\txi.assign(dij);\n\t\t\tconst consX1_xi: number = Math.min(consX1, this.#testX1(X1, xi, bestCons, rc));\n\n\t\t\tif (consX1_xi > Math.max(bestCons, rc)) {\n\t\t\t\tconst crNew = new Set<Constraint>();\n\t\t\t\tconst consX12_xi: number = Math.min(Math.min(consX1_xi, consX12), this.#testX12(X1, X2, xi, consX1_xi, consX12, crNew));\n\n\t\t\t\tif (consX12_xi > bestCons) {\n\t\t\t\t\tbestCons = consX12_xi;\n\t\t\t\t\tbestDij = dij;\n\t\t\t\t\tbestX2 = AssignmentList.fromVariables(X2);\n\t\t\t\t}\n\t\t\t\tif (crNew.size) {\n\t\t\t\t\tconst repairCons: number = this.#flcRepair(X1, X2, xi, consX1_xi, consX12, crNew, Math.max(rc, bestCons));\n\t\t\t\t\tif (this.#globalReturn !== -1) {\n\t\t\t\t\t\treturn bestCons;\n\t\t\t\t\t}\n\t\t\t\t\tif (repairCons > bestCons) {\n\t\t\t\t\t\tbestCons = repairCons;\n\t\t\t\t\t\tbestDij = dij;\n\t\t\t\t\t\tbestX2 = AssignmentList.fromVariables(X2);\n\t\t\t\t\t}\n\t\t\t\t\tx2Store.apply();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbestX2.apply();\n\t\txi.assign(bestDij);\n\t\treturn bestCons;\n\t}\n\n\t#flcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>, consX1: number, consX12: number, rc: number): number {\n\t\tthis._debugOutput(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n\n\t\t// Success if the degree improves from specified\n\t\tif (this._targetDeg !== null && this._targetDeg <= this._pro.worstSatisfactionDegree()) {\n\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\tthis.#globalReturn = 1;\n\t\t\treturn consX12;\n\t\t}\n\t\t// Failure if repeated a specified number\n\t\tif (this._iterLimit && this._iterLimit < this.#iterCount++) {\n\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\tthis.#globalReturn = 0;\n\t\t\treturn consX12;\n\t\t}\n\t\t// Failure if time limit is exceeded\n\t\tif (this.#endTime < Date.now()) {\n\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\tthis.#globalReturn = 0;\n\t\t\treturn consX12;\n\t\t}\n\t\tif (X3.size === 0) {\n\t\t\treturn consX12;\n\t\t}\n\t\tconst xi = X3.values().next().value as Variable;\n\t\tconst consX12xi: number = this.#flcVariable(X1, X2, xi, consX1, consX12, rc);\n\n\t\tif (this.#globalReturn !== -1) {\n\t\t\treturn consX12;\n\t\t}\n\t\tif (consX12xi < rc) {\n\t\t\treturn this.#lb;\n\t\t}\n\t\tX2 = FlexibleLocalChanges.#setPlusElement(X2, xi);\n\t\tX3 = FlexibleLocalChanges.#setMinusElement(X3, xi);\n\t\treturn this.#flcVariables(X1, X2, X3, consX1, consX12xi, rc);\n\t}\n\n\t#initTest(X: Set<Variable>, cr: Set<Constraint>): number {\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const x of X) {\n\t\t\tfor (const c of x) {\n\t\t\t\tcs.add(c);  // All variables in X have been assigned.\n\t\t\t}\n\t\t}\n\t\tlet ret: number = 1;\n\t\tfor (const c of cs) {\n\t\t\tconst sd: number = c.satisfactionDegree();\n\t\t\tif (sd === Constraint.UNDEFINED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sd < ret) {\n\t\t\t\tret = sd;\n\t\t\t}\n\t\t}\n\t\tfor (const c of this._pro.constraints()) {\n\t\t\tconst cd: number = c.lowestConsistencyDegree();\n\t\t\tif (cd < this.#lt) {\n\t\t\t\tcr.add(c);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#testX1(X1: Set<Variable>, xi: Variable, bestCons: number, rc: number): number {\n\t\tlet cd: number = 1;\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const x of X1) {\n\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xi);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tfor (const c of cs) {\n\t\t\tconst d: number = c.satisfactionDegree();\n\t\t\tif (d === Constraint.UNDEFINED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (d < cd) {\n\t\t\t\tcd = d;\n\t\t\t}\n\t\t\t// If it is determined that a better solution than the current solution cannot be obtained\n\t\t\tif (cd <= bestCons || cd <= rc) {\n\t\t\t\treturn cd;\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n\t#testX12(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>): number {\n\t\tlet csd: number = 1;\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const x of X1) {\n\t\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xi);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tfor (const x of X2) {\n\t\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xi);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tfor (const c of cs) {\n\t\t\tconst sd: number = c.satisfactionDegree();\n\t\t\tif (sd === Constraint.UNDEFINED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sd < csd) {\n\t\t\t\tcsd = sd;\n\t\t\t}\n\t\t}\n\t\tfor (const c of cs) {\n\t\t\tconst sd: number = c.satisfactionDegree();\n\t\t\tif (sd === Constraint.UNDEFINED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sd < consX1xi || sd < consX12) {\n\t\t\t\tcr.add(c);\n\t\t\t}\n\t\t}\n\t\treturn csd;\n\t}\n\n\texec(): boolean {\n\t\tthis.#endTime = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tthis.#iterCount = 0;\n\t\tthis.#globalReturn = -1;\n\n\t\tconst wsd: number = this._pro.worstSatisfactionDegree();\n\t\tif (this._pro.emptyVariableSize() === 0) {\n\t\t\tthis._pro.clearAllVariables();\n\t\t}\n\t\tconst X1 = new Set<Variable>();\n\t\tconst X2 = new Set<Variable>();  // Currently assigned variables.\n\t\tconst X3 = new Set<Variable>();  // Currently unassigned variables.\n\t\tfor (const x of this._pro.variables()) {\n\t\t\t(!x.isEmpty() ? X2 : X3).add(x);\n\t\t}\n\n\t\tconst cr = new Set<Constraint>();\n\t\tconst initCons: number = this.#initTest(X2, cr);\n\t\tlet rc;\n\t\tlet initSol: AssignmentList | null = null;\n\n\t\tif (X3.size === 0) {\n\t\t\trc = initCons;\n\t\t\tinitSol = AssignmentList.fromVariables(X2);\n\t\t} else {\n\t\t\trc = this.#lb;\n\t\t}\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr).union(X3);\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\n\t\tlet result: number = this.#flcVariables(X1, X2p, X3p, this.#lt, this.#lt, rc);\n\t\tif (result < rc) {\n\t\t\tif (initSol !== null) {\n\t\t\t\tinitSol.apply();\n\t\t\t}\n\t\t}\n\t\tresult = this._pro.worstSatisfactionDegree();\n\t\treturn result > wsd && result > 0 && (this.#globalReturn !== 0 || this._targetDeg === null);\n\t}\n\n}\n","/**\n * A class that implements the flexible local changes method.\n * The implementation is optimized by converting recursive calls to loops.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Constraint } from '../../problem/constraint';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\n\nexport class FlexibleLocalChangesEx extends Solver {\n\n\tstatic #setPlusElement<T>(s: Set<T>, e: T): Set<T> {\n\t\tconst sn = new Set(s);\n\t\tsn.add(e);\n\t\treturn sn;\n\t}\n\n\t#lt: number = 0;\n\t#lb: number = 0;\n\n\t#iterCount: number = 0;\n\t#endTime: number = 0;\n\t#globalReturn: number = 0;\n\n\tconstructor(p: Problem) {\n\t\tsuper(p);\n\t\tthis.#computeHighestAndLowestConsistencyDegree();\n\t}\n\n\tname(): string {\n\t\treturn 'Flexible Local Changes Ex';\n\t}\n\n\t#choose(x2: Set<Variable>, cr: Set<Constraint>): Set<Variable> {\n\t\tconst res = new Map<Variable, number>();\n\n\t\tfor (const c of cr) {\n\t\t\tif (!c.isDefined()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (const x of c) {\n\t\t\t\tif (!res.has(x)) {\n\t\t\t\t\tres.set(x, 1);\n\t\t\t\t} else {\n\t\t\t\t\tres.set(x, (res.get(x) ?? 0) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst xs: Variable[] = [...x2];\n\t\txs.sort((o1: Variable, o2: Variable): -1 | 0 | 1 => {\n\t\t\tlet res1: number = 0;\n\t\t\tlet res2: number = 0;\n\t\t\tif (res.has(o1)) res1 = res.get(o1) ?? 0;\n\t\t\tif (res.has(o2)) res2 = res.get(o2) ?? 0;\n\n\t\t\tif (res1 < res2) return 1;\n\t\t\tif (res1 > res2) return -1;\n\t\t\treturn 0;\n\t\t});\n\n\t\tconst ret = new Set<Variable>();\n\n\t\tfor (const x of xs) {\n\t\t\tlet remain: boolean = false;\n\t\t\tfor (const c of cr) {\n\t\t\t\tif (c.isDefined()) {\n\t\t\t\t\tremain = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!remain) break;\n\t\t\tx.clear();\n\t\t\tret.add(x);\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#computeHighestAndLowestConsistencyDegree(): void {\n\t\tlet low: number = 1;\n\t\tlet high: number = 0;\n\n\t\tfor (const x of this._pro.variables()) {\n\t\t\tfor (const c of x) {\n\t\t\t\tconst l: number = c.lowestConsistencyDegree();\n\t\t\t\tconst h: number = c.highestConsistencyDegree();\n\t\t\t\tif (l < low) low = l;\n\t\t\t\tif (h > high) high = h;\n\t\t\t}\n\t\t}\n\t\tthis.#lb = low;\n\t\tthis.#lt = high;\n\t}\n\n\t#flcRepair(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>, rc: number): number {\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr);\n\t\tconst X1p: Set<Variable> = FlexibleLocalChangesEx.#setPlusElement(X1, xi);\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\n\t\treturn this.#flcVariables(X1p, X2p, X3p, consX1xi, Math.min(consX12, consX1xi), rc);\n\t}\n\n\t#flcVariable(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1: number, consX12: number, rc: number): number {\n\t\tlet bestCons: number = this.#lb;\n\t\tif (xi.domain().size() === 0) {\n\t\t\treturn bestCons;\n\t\t}\n\t\tlet bestX2: AssignmentList = AssignmentList.fromVariables(X2);\n\t\tlet bestDij: number = xi.domain().at(0);\n\n\t\tconst x2Store: AssignmentList = AssignmentList.fromVariables(X2);\n\n\t\tfor (let j: number = 0; j < xi.domain().size() && bestCons < consX12; ++j) {\n\t\t\tconst dij: number = xi.domain().at(j);\n\t\t\txi.assign(dij);\n\t\t\tconst consX1_xi: number = Math.min(consX1, this.#testX1(X1, xi, bestCons, rc));\n\n\t\t\tif (consX1_xi > Math.max(bestCons, rc)) {\n\t\t\t\tconst crNew = new Set<Constraint>();\n\t\t\t\tconst consX12_xi: number = Math.min(Math.min(consX1_xi, consX12), this.#testX12(X1, X2, xi, consX1_xi, consX12, crNew));\n\n\t\t\t\tif (consX12_xi > bestCons) {\n\t\t\t\t\tbestCons = consX12_xi;\n\t\t\t\t\tbestDij = dij;\n\t\t\t\t\tbestX2 = AssignmentList.fromVariables(X2);\n\t\t\t\t}\n\t\t\t\tif (crNew.size) {\n\t\t\t\t\tconst repairCons: number = this.#flcRepair(X1, X2, xi, consX1_xi, consX12, crNew, Math.max(rc, bestCons));\n\t\t\t\t\tif (this.#globalReturn !== -1) {\n\t\t\t\t\t\treturn bestCons;\n\t\t\t\t\t}\n\t\t\t\t\tif (repairCons > bestCons) {\n\t\t\t\t\t\tbestCons = repairCons;\n\t\t\t\t\t\tbestDij = dij;\n\t\t\t\t\t\tbestX2 = AssignmentList.fromVariables(X2);\n\t\t\t\t\t}\n\t\t\t\t\tx2Store.apply();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbestX2.apply();\n\t\txi.assign(bestDij);\n\t\treturn bestCons;\n\t}\n\n\t#flcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>, consX1: number, consX12: number, rc: number): number {\n\t\tX2 = new Set<Variable>(X2);  // Clone\n\t\tX3 = new Set<Variable>(X3);  // Clone\n\n\t\twhile (true) {\n\t\t\tthis._debugOutput(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\n\n\t\t\t// Success if the degree improves from specified\n\t\t\tif (this._targetDeg !== null && this._targetDeg <= this._pro.worstSatisfactionDegree()) {\n\t\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\t\tthis.#globalReturn = 1;\n\t\t\t\treturn consX12;\n\t\t\t}\n\t\t\t// Failure if repeated a specified number\n\t\t\tif (this._iterLimit && this._iterLimit < this.#iterCount++) {\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\tthis.#globalReturn = 0;\n\t\t\t\treturn consX12;\n\t\t\t}\n\t\t\t// Failure if time limit is exceeded\n\t\t\tif (this.#endTime < Date.now()) {\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\tthis.#globalReturn = 0;\n\t\t\t\treturn consX12;\n\t\t\t}\n\t\t\tif (X3.size === 0) {\n\t\t\t\treturn consX12;\n\t\t\t}\n\t\t\tconst xi = X3.values().next().value as Variable;\n\t\t\tconst consX12xi: number = this.#flcVariable(X1, X2, xi, consX1, consX12, rc);\n\n\t\t\tif (this.#globalReturn !== -1) {\n\t\t\t\treturn consX12;\n\t\t\t}\n\t\t\tif (consX12xi < rc) {\n\t\t\t\treturn this.#lb;\n\t\t\t}\n\t\t\tX2.add(xi);\n\t\t\tX3.delete(xi);\n\t\t\tconsX12 = consX12xi;\n\t\t}\n\t}\n\n\t#initTest(X: Set<Variable>, cr: Set<Constraint>): number {\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const x of X) {\n\t\t\tfor (const c of x) {\n\t\t\t\tcs.add(c);  // All variables in X have been assigned.\n\t\t\t}\n\t\t}\n\t\tlet ret: number = 1;\n\t\tfor (const c of cs) {\n\t\t\tconst sd: number = c.satisfactionDegree();\n\t\t\tif (sd === Constraint.UNDEFINED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sd < ret) {\n\t\t\t\tret = sd;\n\t\t\t}\n\t\t}\n\t\tfor (const c of this._pro.constraints()) {\n\t\t\tconst cd: number = c.lowestConsistencyDegree();\n\t\t\tif (cd < this.#lt) {\n\t\t\t\tcr.add(c);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t#testX1(X1: Set<Variable>, xi: Variable, bestCons: number, rc: number): number {\n\t\tlet cd: number = 1;\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const x of X1) {\n\t\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xi);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tfor (const c of cs) {\n\t\t\tconst d: number = c.satisfactionDegree();\n\t\t\tif (d === Constraint.UNDEFINED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (d < cd) {\n\t\t\t\tcd = d;\n\t\t\t}\n\t\t\t// If it is determined that a better solution than the current solution cannot be obtained\n\t\t\tif (cd <= bestCons || cd <= rc) {\n\t\t\t\treturn cd;\n\t\t\t}\n\t\t}\n\t\treturn cd;\n\t}\n\n\t#testX12(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>) {\n\t\tlet csd: number = 1;\n\t\tconst cs = new Set<Constraint>();\n\n\t\tfor (const x of X1) {\n\t\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xi);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tfor (const x of X2) {\n\t\t\tconst temp: Constraint[] = this._pro.constraintsBetween(x, xi);\n\t\t\tfor (const c of temp) {\n\t\t\t\tcs.add(c);\n\t\t\t}\n\t\t}\n\t\tfor (const c of cs) {\n\t\t\tconst sd: number = c.satisfactionDegree();\n\t\t\tif (sd === Constraint.UNDEFINED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sd < csd) {\n\t\t\t\tcsd = sd;\n\t\t\t}\n\t\t}\n\t\tfor (const c of cs) {\n\t\t\tconst sd: number = c.satisfactionDegree();\n\t\t\tif (sd === Constraint.UNDEFINED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sd < consX1xi || sd < consX12) {\n\t\t\t\tcr.add(c);\n\t\t\t}\n\t\t}\n\t\treturn csd;\n\t}\n\n\texec(): boolean {\n\t\tthis.#endTime = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tthis.#iterCount = 0;\n\t\tthis.#globalReturn = -1;\n\n\t\tconst wsd: number = this._pro.worstSatisfactionDegree();\n\t\tif (this._pro.emptyVariableSize() === 0) {\n\t\t\tthis._pro.clearAllVariables();\n\t\t}\n\t\tconst X1 = new Set<Variable>();\n\t\tconst X2 = new Set<Variable>();  // Currently assigned variables.\n\t\tconst X3 = new Set<Variable>();  // Currently unassigned variables.\n\t\tfor (const x of this._pro.variables()) {\n\t\t\t(!x.isEmpty() ? X2 : X3).add(x);\n\t\t}\n\n\t\tconst cr = new Set<Constraint>();\n\t\tconst initCons: number = this.#initTest(X2, cr);\n\t\tlet rc;\n\t\tlet initSol: AssignmentList | null = null;\n\n\t\tif (X3.size === 0) {\n\t\t\trc = initCons;\n\t\t\tinitSol = AssignmentList.fromVariables(X2);\n\t\t} else {\n\t\t\trc = this.#lb;\n\t\t}\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr).union(X3);\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\n\t\tlet result: number = this.#flcVariables(X1, X2p, X3p, this.#lt, this.#lt, rc);\n\t\tif (result < rc) {\n\t\t\tif (initSol !== null) {\n\t\t\t\tinitSol.apply();\n\t\t\t}\n\t\t}\n\t\tresult = this._pro.worstSatisfactionDegree();\n\t\treturn result > wsd && result > 0 && (this.#globalReturn !== 0 || this._targetDeg === null);\n\t}\n\n}\n","/**\n * Class implements a solver using the breakout method for fuzzy CSP.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { Assignment } from '../../util/assignment';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\n\nexport class FuzzyBreakout extends Solver {\n\n\t#isRandom: boolean = true;\n\n\t#ws: number[];\n\t#lastSolDeg: number = 0;\n\n\tconstructor(p: Problem) {\n\t\tsuper(p);\n\n\t\tthis.#ws = new Array(this._pro.constraintSize());\n\t\tthis.#ws.fill(1);\n\t}\n\n\tname(): string {\n\t\treturn 'Fuzzy Breakout';\n\t}\n\n\t/**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of local solutions, but makes the solution unrepeatable.\n\t * @param flag Whether the randomness is enabled.\n\t */\n\tsetRandomness(flag: boolean): void {\n\t\tthis.#isRandom = flag;\n\t}\n\n\t#findCandidates(worstXs: Iterable<Variable>, canList: AssignmentList): void {\n\t\tlet maxDiff: number = 0;\n\n\t\tfor (const x of worstXs) {\n\t\t\tconst x_v: number = x.value();  // Save the value\n\n\t\t\tlet nowVio: number = 0;\n\t\t\tfor (const c of x) {\n\t\t\t\tnowVio += (1 - c.satisfactionDegree()) * this.#ws[c.index()];\n\t\t\t}\n\t\t\tout: for (const v of x.domain()) {\n\t\t\t\tif (x_v === v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx.assign(v);\n\t\t\t\tlet diff: number = nowVio;\n\n\t\t\t\tfor (const c of x) {\n\t\t\t\t\tdiff -= (1 - c.satisfactionDegree()) * this.#ws[c.index()];\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\n\t\t\t\t\tif (diff < maxDiff) {\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (diff > maxDiff) {  // Found assignments that are better than ever before.\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tcanList.clear();\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t} else if (maxDiff !== 0) {  // Found assignments that can be improved to the same level as before.\n\t\t\t\t\tcanList.addVariable(x, v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.assign(x_v);  // Restore the value.\n\t\t}\n\t}\n\n\t#listWorstVariables(worstCs: Iterable<Constraint>): Iterable<Variable> {\n\t\tconst xs = new Set<Variable>();\n\n\t\tfor (const c of worstCs) {\n\t\t\tfor (const x of c) {\n\t\t\t\txs.add(x);\n\t\t\t}\n\t\t}\n\t\treturn Array.from<Variable>(xs);\n\t}\n\n\texec(): boolean {\n\t\tconst endTime: number = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tlet iterCount: number = 0;\n\n\t\tfor (const x of this._pro.variables()) {\n\t\t\tif (x.isEmpty()) {\n\t\t\t\tx.assign(x.domain().at(0));\n\t\t\t}\n\t\t}\n\n\t\tconst deg: number = this._pro.worstSatisfactionDegree();\n\t\tconst canList = new AssignmentList();\n\n\t\tconst sol = new AssignmentList();\n\n\t\twhile (true) {\n\t\t\tconst [vcs, wsd] = this._pro.constraintsWithWorstSatisfactionDegree();\n\t\t\t// Success if the degree improves from specified\n\t\t\tif (this._targetDeg !== null && this._targetDeg <= wsd) {\n\t\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Failure if repeated a specified number\n\t\t\tif (this._iterLimit && this._iterLimit < iterCount++) {\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Failure if time limit is exceeded\n\t\t\tif (endTime < Date.now()) {\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis._debugOutput('worst satisfaction degree: ' + wsd);\n\n\t\t\tif (this.#lastSolDeg < wsd) {\n\t\t\t\tsol.setProblem(this._pro);\n\t\t\t\tthis.#lastSolDeg = wsd;\n\n\t\t\t\tif (this.foundSolution(sol, this.#lastSolDeg)) {  // Call hook\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.#findCandidates(this.#listWorstVariables(vcs), canList);\n\n\t\t\tif (0 < canList.size()) {\n\t\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\n\t\t\t\ta.apply();\n\t\t\t\tcanList.clear();\n\t\t\t\tthis._debugOutput('\\t' + a);\n\t\t\t} else {\n\t\t\t\tfor (const c of vcs) {\n\t\t\t\t\tthis.#ws[c.index()] += 1;\n\t\t\t\t}\n\t\t\t\tthis._debugOutput('breakout');\n\t\t\t}\n\t\t}\n\t\tif (this._targetDeg === null && deg < this._pro.worstSatisfactionDegree()) return true;\n\t\treturn false;\n\t}\n\n}\n","/**\n * This class implements fuzzy GENET.\n * CSPs and FCSPs (but only Binary (F)CSPs) is supported.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\n\nexport class FuzzyGENET extends Solver {\n\n\tstatic nextInt(max: number): number {\n\t\treturn Math.floor(Math.random() * Math.floor(max));\n\t}\n\n\t#clusters: Cluster[] = [];\n\t#connections: Connection[] = [];\n\t#worstSatisfactionDegree: number;\n\n\tconstructor(p: Problem, worstSatisfactionDegree: number = 1) {\n\t\tsuper(p);\n\t\tthis.#worstSatisfactionDegree = worstSatisfactionDegree;\n\t}\n\n\tname(): string {\n\t\treturn 'Fuzzy GENET';\n\t}\n\n\t#createNetwork(worstDeg: number): boolean {\n\t\tthis._debugOutput('network creation start');\n\t\tconst cons: Connection[] = [];\n\n\t\tfor (const x of this._pro.variables()) {\n\t\t\tif (x.domain().size() === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.#clusters.push(new Cluster(x));\n\t\t}\n\t\tfor (const c of this._pro.constraints()) {\n\t\t\tif (c.size() === 1) {  // In the case of unary constraints.\n\t\t\t\tconst x = c.at(0) as Variable;\n\t\t\t\tconst cl: Cluster = this.#clusters[x.index()];\n\n\t\t\t\tfor (let i: number = 0; i < cl.size(); ++i) {\n\t\t\t\t\tconst origV: number = x.value();  // Save the value.\n\t\t\t\t\tx.assign(cl.get(i)._value);\n\n\t\t\t\t\tif (c.satisfactionDegree() <= worstDeg) {\n\t\t\t\t\t\tcons.push(new Connection(c, cl.get(i)));\n\t\t\t\t\t}\n\t\t\t\t\tx.assign(origV);  // Restore the value.\n\t\t\t\t}\n\t\t\t} else {  // In the case of binary constraints.\n\t\t\t\tconst x1 = c.at(0) as Variable;\n\t\t\t\tconst x2 = c.at(1) as Variable;\n\t\t\t\tconst cl_f: Cluster = this.#clusters[x1.index()];\n\t\t\t\tconst cl_s: Cluster = this.#clusters[x2.index()];\n\n\t\t\t\tfor (let i: number = 0; i < cl_f.size(); ++i) {\n\t\t\t\t\tconst origV1: number = x1.value();  // Save the value.\n\t\t\t\t\tx1.assign(cl_f.get(i)._value);\n\n\t\t\t\t\tfor (let j: number = 0; j < cl_s.size(); ++j) {\n\t\t\t\t\t\tconst origV2: number = x2.value();  // Save the value.\n\t\t\t\t\t\tx2.assign(cl_s.get(j)._value);\n\n\t\t\t\t\t\tif (c.satisfactionDegree() <= worstDeg) {\n\t\t\t\t\t\t\tcons.push(new Connection(c, cl_f.get(i), cl_s.get(j)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx2.assign(origV2);  // Restore the value.\n\t\t\t\t\t}\n\t\t\t\t\tx1.assign(origV1);  // Restore the value.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const cl of this.#clusters) {\n\t\t\tfor (const n of cl._neurons) {\n\t\t\t\tn.lockConnections();\n\t\t\t}\n\t\t}\n\t\tthis.#connections = cons;\n\t\tthis._debugOutput('network creation complete');\n\t\treturn true;\n\t}\n\n\t#shuffle(is: number[]): number[] {\n\t\tfor (let i: number = is.length; i > 1; --i) {\n\t\t\tconst j: number = FuzzyGENET.nextInt(i);\n\t\t\tconst temp: number = is[i - 1];\n\t\t\tis[i - 1] = is[j];\n\t\t\tis[j] = temp;\n\t\t}\n\t\treturn is;\n\t}\n\n\texec(): boolean {\n\t\tif (!this.#createNetwork(this.#worstSatisfactionDegree)) {\n\t\t\tthrow new Error();\n\t\t}\n\t\tconst endTime: number = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tlet iterCount: number = 0;\n\n\t\tconst sol = new AssignmentList();\n\t\tconst order: number[] = [];\n\t\tfor (let i: number = 0; i < this.#clusters.length; ++i) {\n\t\t\torder.push(i);\n\t\t}\n\n\t\tlet cur: number = this._pro.worstSatisfactionDegree();\n\t\tlet success: boolean = false;\n\n\t\twhile (true) {\n\t\t\tif (this._iterLimit && this._iterLimit < iterCount++) {  // Failure if repeated a specified number\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (endTime < Date.now()) {  // Failure if time limit is exceeded\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet modified: boolean = false;\n\t\t\tfor (const i of this.#shuffle(order)) {\n\t\t\t\tif (this.#clusters[i].setActivityMaximumInput()) {\n\t\t\t\t\tmodified = true;  // Turn on the node with the largest input in each cluster\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!modified) {  // When the local minimum solution is reached.\n\t\t\t\tfor (const con of this.#connections) {\n\t\t\t\t\tcon.refreshWeight();  // Update weights for all connections\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tfor (const clu of this.#clusters) {\n\t\t\t\t\tclu.applyToVariable();  // Apply to variable\n\t\t\t\t}\n\t\t\t\tconst d: number = this._pro.worstSatisfactionDegree();\n\t\t\t\tif (cur < d) {  // If it's a better assignment than ever, save it.\n\t\t\t\t\tcur = d;\n\t\t\t\t\tthis._debugOutput(`worst satisfaction degree: ${d}`);\n\t\t\t\t\tsol.setProblem(this._pro);\n\t\t\t\t\tif (this.foundSolution(sol, d)) {  // Call hook\n\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._targetDeg === null) {  // Satisfaction degree is not specified.\n\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t} else if (this._targetDeg <= cur) {  // Satisfaction degree is specified.\n\t\t\t\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsol.apply();\n\t\treturn success;\n\t}\n\n}\n\nclass Cluster {\n\n\tstatic nextInt(max: number): number {\n\t\treturn Math.floor(Math.random() * Math.floor(max));\n\t}\n\n\t#x: Variable;  // For avoiding a bug(?) of parcel.\n\t#index: number = 0;\n\t#maxNeurons: number[] = [];\n\t_neurons: Neuron[] = [];\n\n\tconstructor(x: Variable) {\n\t\tthis.#x = x;\n\n\t\tfor (const v of x.domain()) {\n\t\t\tthis._neurons.push(new Neuron(v));\n\t\t}\n\t\tthis.#setActivity(Cluster.nextInt(this._neurons.length));\n\t}\n\n\t#setActivity(index: number): void {\n\t\tfor (const n of this._neurons) {\n\t\t\tn._isActive = false;\n\t\t}\n\t\tthis._neurons[index]._isActive = true;\n\t\tthis.#index = index;\n\t}\n\n\tapplyToVariable(): void {\n\t\tthis.#x.assign(this._neurons[this.#index]._value);\n\t}\n\n\tget(index: number): Neuron {\n\t\treturn this._neurons[index];\n\t}\n\n\tneurons(): Neuron[] {\n\t\treturn this._neurons;\n\t}\n\n\t// Turn on the node with the largest input.\n\tsetActivityMaximumInput(): boolean {\n\t\tthis.#maxNeurons.length = 0;\n\n\t\tlet max: number = Number.NEGATIVE_INFINITY;\n\t\tlet alreadyOn: boolean = false;\n\n\t\tfor (let i: number = 0; i < this._neurons.length; ++i) {\n\t\t\tconst input: number = this._neurons[i].getInput();\n\n\t\t\tif (max <= input) {\n\t\t\t\tif (max < input) {\n\t\t\t\t\tmax = input;\n\t\t\t\t\tthis.#maxNeurons.length = 0;\n\t\t\t\t\talreadyOn = false;\n\t\t\t\t}\n\t\t\t\tthis.#maxNeurons.push(i);\n\t\t\t\tif (this.#index === i) {\n\t\t\t\t\talreadyOn = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (alreadyOn || this.#maxNeurons.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.#setActivity(this.#maxNeurons[Cluster.nextInt(this.#maxNeurons.length)]);\n\t\treturn true;\n\t}\n\n\tsize(): number {\n\t\treturn this._neurons.length;\n\t}\n\n}\n\nclass Connection {\n\n\t#c: Constraint;\n\t#first: Neuron;\n\t#second: Neuron | null;\n\t_weight: number;  // Direct reference (read) allowed.\n\n\t// Order of neurons must be the same as the order of variables that the constraint has.\n\tconstructor(c: Constraint, first: Neuron, second: Neuron | null = null) {\n\t\tthis._weight = c.satisfactionDegree() - 1;\n\t\tthis.#c = c;\n\n\t\tthis.#first = first;\n\t\tthis.#first.addConnection(this);\n\t\tthis.#second = second;\n\t\tif (this.#second !== null) {\n\t\t\tthis.#second.addConnection(this);\n\t\t}\n\t}\n\n\tgetNeuron(self: Neuron): Neuron | null {\n\t\tif (self === this.#first) return this.#second;\n\t\tif (self === this.#second) return this.#first;\n\t\treturn null;\n\t}\n\n\trefreshWeight(): void {\n\t\tif (!this.#first._isActive || (this.#second !== null && !this.#second._isActive)) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.#c.size() === 1) {\n\t\t\tthis._weight += (this.#c.fuzzyRelation().satisfactionDegree(this.#first._value) - 1);\n\t\t} else {\n\t\t\tthis._weight += (this.#c.fuzzyRelation().satisfactionDegree(this.#first._value, (this.#second as Neuron)._value) - 1);\n\t\t}\n\t}\n\n}\n\nclass Neuron {\n\n\t#conTemp: Connection[] | null = [];\n\t#connections: Connection[] = [];\n\n\t_value: number;  // Direct reference (read) allowed.\n\t_isActive: boolean = false;  // Direct reference (read, write) allowed.\n\n\tconstructor(value: number) {\n\t\tthis._value = value;\n\t}\n\n\taddConnection(c: Connection): void {\n\t\t(this.#conTemp as Connection[]).push(c);\n\t}\n\n\tlockConnections(): void {\n\t\tthis.#connections = [...this.#conTemp as Connection[]];\n\t\tthis.#conTemp = null;  // No longer being used.\n\t}\n\n\tgetInput(): number {\n\t\tlet ret: number = 0;\n\n\t\tfor (const c of this.#connections) {\n\t\t\tconst n: Neuron | null = c.getNeuron(this);  // If n is null, then the unary constraint.\n\t\t\tret += c._weight * ((n === null || n._isActive) ? 1 : 0);\n\t\t}\n\t\treturn ret;\n\t}\n\n}\n","/**\n * This class implements the SRS algorithm.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../../problem/problem';\nimport { Constraint } from '../../problem/constraint';\nimport { Assignment } from '../../util/assignment';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { Solver } from '../solver';\n\nexport class SRS3 extends Solver {\n\n\t// Threshold for adopting a candidate assignment at repair time (should be 0 if strictly following SRS 3)\n\tstatic REPAIR_THRESHOLD = 0;\n\n\t#closedList: Set<TreeNode> = new Set<TreeNode>();\n\t#openList: Set<TreeNode> = new Set<TreeNode>();  // LinkedHashSet is used in the original implementation.\n\t#nodes: TreeNode[] = [];\n\t#neighborConstraints: (Constraint[] | null)[] = [];  // Cache\n\n\t#c_stars: Set<TreeNode> = new Set<TreeNode>();  // ArrayList is used in the original implementation.\n\n\t#iterCount: number = 0;\n\t#endTime: number = 0;\n\t#isRandom: boolean = true;\n\n\tconstructor(p: Problem) {\n\t\tsuper(p);\n\n\t\tfor (const c of this._pro.constraints()) {\n\t\t\tthis.#nodes.push(new TreeNode(c));\n\t\t\tthis.#neighborConstraints.push(null);\n\t\t}\n\t}\n\n\tname(): string {\n\t\treturn 'SRS 3';\n\t}\n\n\t#getNeighborConstraints(c: Constraint): Constraint[] {\n\t\tconst i: number = c.index();\n\n\t\tif (this.#neighborConstraints[i] === null) {\n\t\t\tthis.#neighborConstraints[i] = c.neighbors();\n\t\t}\n\t\treturn this.#neighborConstraints[i];\n\t}\n\n\t#repair(c0: Constraint): boolean {\n\t\tthis._debugOutput('repair');\n\n\t\tconst canList = new AssignmentList();\n\t\tconst minDeg0: number = c0.satisfactionDegree();  // Target c0 should certainly be an improvement over this.\n\t\tconst min: number = this._pro.worstSatisfactionDegree();  // Lower bound of neighborhood constraints.\n\t\tlet maxDeg0: number = c0.satisfactionDegree();  // Satisfaction degree of target c0 for the most improvement so far.\n\n\t\t// If a candidate satisfying the condition is stronger than the previous candidates,\n\t\t// it is replaced, and if no candidate is found until the end, it fails.\n\t\tfor (const x of c0) {\n\t\t\tconst x_v: number = x.value();  // Save the value\n\n\t\t\tout: for (const v of x.domain()) {\n\t\t\t\tif (x_v === v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx.assign(v);\n\t\t\t\tconst deg0: number = c0.satisfactionDegree();\n\t\t\t\t// If target c0 cannot be improved, the assignment is rejected.\n\t\t\t\tif (minDeg0 > deg0 || maxDeg0 - deg0 > SRS3.REPAIR_THRESHOLD) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (const c of x) {\n\t\t\t\t\tif (c === c0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst deg: number = c.satisfactionDegree();\n\t\t\t\t\t// If one of the neighborhood constraints c is less than or equal to the worst, the assignment is rejected.\n\t\t\t\t\tif (deg !== Constraint.UNDEFINED && deg < min) {\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (deg0 > maxDeg0) {\n\t\t\t\t\tmaxDeg0 = deg0;\n\t\t\t\t\tcanList.clear();\n\t\t\t\t}\n\t\t\t\tcanList.addVariable(x, v);\n\t\t\t}\n\t\t\tx.assign(x_v);  // Restore the value\n\t\t}\n\t\tif (canList.size() > 0) {\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\n\t\t\ta.apply();\n\t\t\tthis._debugOutput('\\t' + a);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t#shrink(node: TreeNode): void {\n\t\tthis._debugOutput('shrink');\n\n\t\tlet removeCStar: boolean = false;\n\t\twhile (true) {\n\t\t\tnode = node.parent() as TreeNode;\n\t\t\tif (this.#c_stars.delete(node)) {\n\t\t\t\tremoveCStar = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!this.#repair((node.parent() as TreeNode).getObject())) break;\n\t\t}\n\t\tconst temp: TreeNode[] = [];\n\t\tnode.getDescendants(temp);  // temp contains node.\n\n\t\tfor (const n of temp) {\n\t\t\tn.clear();  // Prepare for reuse\n\t\t\tthis.#openList.delete(n);\n\t\t\tthis.#closedList.delete(n);\n\t\t}\n\n\t\tif (!removeCStar) {\n\t\t\tthis.#openList.add(node);\n\t\t}\n\t}\n\n\t#spread(node: TreeNode): void {\n\t\tthis._debugOutput('spread');\n\t\tthis.#closedList.add(node);\n\n\t\tfor (const c of this.#getNeighborConstraints(node.getObject())) {\n\t\t\tconst tnc: TreeNode = this.#nodes[c.index()];\n\n\t\t\tif (!this.#closedList.has(tnc) && !this.#openList.has(tnc)) {  // For constraints that are not included in Open or Closed.\n\t\t\t\tnode.add(tnc);\n\t\t\t\tthis.#openList.add(tnc);\n\t\t\t}\n\t\t}\n\t}\n\n\t#srs(): boolean {\n\t\tthis._debugOutput('srs');\n\n\t\tconst [wsd_cs,] = this._pro.constraintsWithWorstSatisfactionDegree();\n\t\tfor (const c of wsd_cs) {\n\t\t\tconst cn: TreeNode = this.#nodes[c.index()];\n\t\t\tcn.setParent(null);\n\t\t\tthis.#c_stars.add(cn);\n\t\t}\n\t\tthis.#closedList.clear();\n\t\tthis.#openList.clear();\n\t\tfor (const n of this.#c_stars) {\n\t\t\tthis.#openList.add(n);\n\t\t}\n\n\t\twhile (this.#c_stars.size && this.#openList.size) {\n\t\t\tif (this._iterLimit && this._iterLimit < this.#iterCount++) {  // Failure if repeated a specified number\n\t\t\t\tthis._debugOutput('stop: number of iterations has reached the limit');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.#endTime < Date.now()) {  // Failure if time limit is exceeded\n\t\t\t\tthis._debugOutput('stop: time limit has been reached');\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst node = this.#openList.values().next().value as TreeNode;\n\t\t\tthis.#openList.delete(node);\n\n\t\t\tif (this.#repair(node.getObject())) {\n\t\t\t\tif (this.#c_stars.delete(node)) continue;  // If the repaired node is included in C* (to be deleted)\n\t\t\t\tif (this.#repair((node.parent() as TreeNode).getObject())) {\n\t\t\t\t\tthis.#shrink(node);  // When its improvement leads to the improvement of its parents\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.#spread(node);\n\t\t}\n\t\treturn true;\n\t}\n\n\texec(): boolean {\n\t\tthis.#endTime = (this._timeLimit === null) ? Number.MAX_VALUE : (Date.now() + this._timeLimit);\n\t\tthis.#iterCount = 0;\n\t\tif (this._targetDeg && this._targetDeg <= this._pro.worstSatisfactionDegree()) {\n\t\t\treturn true;\n\t\t}\n\t\tconst sol = new AssignmentList();\n\n\t\tlet success: boolean = false;\n\t\twhile (true) {\n\t\t\tconst ret: boolean = this.#srs();\n\t\t\tif (!ret || this.#c_stars.size) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst solutionWorstDeg: number = this._pro.worstSatisfactionDegree();\n\t\t\tthis._debugOutput(`\\tfound a solution: ${solutionWorstDeg}\\t${this._targetDeg}`);\n\t\t\tsol.setProblem(this._pro);\n\n\t\t\tif (this.foundSolution(sol, solutionWorstDeg)) {  // Call hook\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (this._targetDeg === null) {  // Satisfaction degree is not specified\n\t\t\t\tsuccess = true;\n\t\t\t} else if (this._targetDeg <= solutionWorstDeg) {  // The current degree exceeded the specified degree.\n\t\t\t\tthis._debugOutput('stop: current degree is above the target');\n\t\t\t\tsuccess = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t}\n\n\t/**\n\t * Sets the randomness of the algorithm.\n\t * Enabling randomness reduces the risk of falling into a local solution, but makes the solution unrepeatable.\n\t * @param flag If true, randomness is enabled.\n\t */\n\tsetRandomness(flag: boolean): void {\n\t\tthis.#isRandom = flag;\n\t}\n\n}\n\nclass TreeNode {\n\n\t#children: TreeNode[] = [];\n\t#parent: TreeNode | null;\n\t#obj: any;\n\n\tconstructor(obj: any) {\n\t\tthis.#parent = null;\n\t\tthis.#obj = obj;\n\t}\n\n\tadd(tn: TreeNode): void {\n\t\ttn.#parent = this;\n\t\tthis.#children.push(tn);\n\t}\n\n\tclear(): void {\n\t\tfor (const tn of this.#children) {\n\t\t\ttn.#parent = null;\n\t\t}\n\t\tthis.#children.length = 0;\n\t}\n\n\tgetDescendants(tns: TreeNode[]): void {\n\t\ttns.push(this);\n\n\t\tfor (const tn of this.#children) {\n\t\t\ttn.getDescendants(tns);\n\t\t}\n\t}\n\n\tgetObject(): any {\n\t\treturn this.#obj;\n\t}\n\n\tparent(): TreeNode | null {\n\t\treturn this.#parent;\n\t}\n\n\tsetParent(p: TreeNode | null): void {\n\t\tthis.#parent = p;\n\t}\n\n}\n","/**\n * This class implements the SRS algorithm with PF.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../../problem/problem';\nimport { AssignmentList } from '../../util/assignment-list';\nimport { PostStabilization } from '../filter/post-stabilization';\nimport { SRS3 } from './srs3';\n\nexport class SRS3_PF extends SRS3 {\n\n\tconstructor(p: Problem) {\n\t\tsuper(p);\n\t}\n\n\tname(): string {\n\t\treturn 'SRS 3 + PF';\n\t}\n\n\texec(): boolean {\n\t\tlet deg: number = 0;\n\t\tlet uvs: number = 0;\n\t\tif (this._debug) {\n\t\t\tdeg = this._pro.worstSatisfactionDegree();\n\t\t\tuvs = this._pro.emptyVariableSize();\n\t\t}\n\t\tconst al = new AssignmentList();\n\t\tal.setProblem(this._pro);\n\n\t\tconst res: boolean = super.exec();\n\n\t\tif (res) {\n\t\t\tPostStabilization.apply(this._pro, al);\n\t\t}\n\t\tthis._debugOutput(`result: ${res ? 'success' : 'failure'}`);\n\t\tthis._debugOutput(`satisfaction degree: ${deg} -> ${this._pro.worstSatisfactionDegree()}`);\n\t\tthis._debugOutput(`unassigned size: ${uvs} -> ${this._pro.emptyVariableSize()}`);\n\t\treturn res;\n\t}\n\n}\n","/**\n * Class of post-stabilization.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\nimport { Assignment } from '../../util/assignment';\nimport { AssignmentList } from '../../util/assignment-list';\n\nexport class PostStabilization {\n\n\tstatic apply(p: Problem, orig: AssignmentList): boolean {\n\t\tconsole.log('start post-stabilization');\n\n\t\tlet stabilized: boolean;\n\t\tlet count: number = 0;\n\n\t\tdo {\n\t\t\tconsole.log('post-stabilization: count ' + count++);\n\n\t\t\tstabilized = false;\n\t\t\tlet C_min: number = p.worstSatisfactionDegree();\n\n\t\t\tconst xs: Variable[] = p.variables();\n\t\t\tfor (let i: number = 0; i < xs.length; ++i) {\n\t\t\t\tconst x: Variable = xs[i];\n\t\t\t\tconst org: number = x.value();\n\n\t\t\t\tconst a: Assignment = orig.at(i);\n\t\t\t\tif (org === a.value()) continue;\n\n\t\t\t\ta.apply();  // Try to assign the original.\n\t\t\t\tif (p.worstSatisfactionDegree() >= C_min) {\n\t\t\t\t\tstabilized = true;\n\t\t\t\t} else {\n\t\t\t\t\tx.assign(org);  // Restore.\n\t\t\t\t}\n\t\t\t}\n\t\t} while (stabilized);\n\n\t\tconsole.log('finish post-stabilization');\n\t\treturn true;\n\t}\n\n}\n","/**\n * The class implements AC-3, one of the arc consistency algorithms.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Problem } from '../../problem/problem';\nimport { Variable } from '../../problem/variable';\nimport { Constraint } from '../../problem/constraint';\nimport { Domain } from '../../problem/domain';\n\nexport class AC3 {\n\n\tstatic #checkConsistency(c: Constraint, x_j: Variable): boolean {\n\t\tfor (const v of x_j.domain()) {  // Is there a partner that satisfies the constraint?\n\t\t\tx_j.assign(v);\n\n\t\t\tif (c.isSatisfied() === 1) {  // It exists!\n\t\t\t\treturn true;  // Current assignment of v_i is consistent.\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic #reviseDomain(p: Problem, x_i: Variable, x_j: Variable): boolean {\n\t\tconst v_i: number = x_i.value();\n\t\tconst v_j: number = x_j.value();  // Save the value.\n\t\tconst d_i: Domain = x_i.domain();\n\t\tconst temp: number[] = [];\n\n\t\tconst cs: Constraint[] = p.constraintsBetween(x_i, x_j);\n\n\t\tvs: for (const v of d_i) {\n\t\t\tx_i.assign(v);\n\n\t\t\tfor (const c of cs) {\n\t\t\t\tif (c.size() !== 2) continue;  // Check the next constraint\n\t\t\t\tif (!AC3.#checkConsistency(c, x_j)) continue vs;   // Since there is no partner satisfying the constraint, check the next value.\n\t\t\t}\n\t\t\ttemp.push(v);\n\t\t}\n\t\tx_i.assign(v_i);  // Restore the value.\n\t\tx_j.assign(v_j);  // Restore the value.\n\n\t\tif (temp.length !== d_i.size()) {\n\t\t\tconst nd = p.createDomain({ values: temp }) as Domain;\n\t\t\tx_i.domain(nd);\n\t\t\tconsole.log(d_i.size() + ' -> ' + nd.size());\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic apply(p: Problem): void {\n\t\tconst cs: Constraint[] = [];\n\n\t\tfor (const c of p.constraints()) {\n\t\t\tif (c.size() === 2) cs.push(c);\n\t\t}\n\t\twhile (cs.length) {\n\t\t\tconst c = cs.pop() as Constraint;\n\t\t\tconst v_k = c.at(0) as Variable;\n\t\t\tconst v_m = c.at(1) as Variable;\n\n\t\t\tif (AC3.#reviseDomain(p, v_k, v_m)) {\n\t\t\t\tfor (const c1 of p.constraints()) {\n\t\t\t\t\tif (c1.size() === 2 && c1.at(1) === v_k && c1.at(0) !== v_m) {\n\t\t\t\t\t\tcs.unshift(c1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n","/**\n * Utility class that performs node consistency.\n *\n * @author Takuto Yanagida\n * @version 2024-10-21\n */\n\nimport { Problem } from '../../problem/problem';\nimport { CrispProblem } from '../../problem/problem-crisp';\nimport { Domain } from '../../problem/domain';\n\nexport class NodeConsistency {\n\n\t/**\n\t * Guarantees consistency of fuzzy unary constraints. The domain of each variable is replaced as needed.\n\t * Deletes elements from domains that do not meet the specified worst satisfaction degree.\n\t * @param p A problem.\n\t * @param threshold Worst satisfaction degree.\n\t * @return True if there is no empty domain.\n\t */\n\tstatic applyToProblem(p: Problem, threshold: number): boolean {\n\t\tfor (const x of p.variables()) {\n\t\t\tconst d: Domain = x.domain();\n\t\t\tconst origV: number = x.value();  // Save the value.\n\t\t\tconst elms: number[] = [];\n\n\t\t\tfor (const c of x) {\n\t\t\t\tif (c.size() !== 1) continue;\n\n\t\t\t\tfor (const v of d) {\n\t\t\t\t\tx.assign(v);\n\n\t\t\t\t\tif (c.satisfactionDegree() >= threshold) {\n\t\t\t\t\t\telms.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp.removeConstraint(c);\n\t\t\t}\n\t\t\tx.assign(origV);  // Restore the value.\n\t\t\tif (elms.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tx.domain(p.createDomain({ values: elms }) as Domain);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Guarantees consistency of crisp unary constraints. The domain of each variable is replaced as needed.\n\t * It cannot be applied to crisp views of fuzzy constraint satisfaction problems because it changes the structure of the constraint graph.\n\t * @param p A crisp problem.\n\t * @return True if there is no empty domain.\n\t */\n\tstatic applyToCrispProblem(p: CrispProblem) {\n\t\tfor (const x of p.variables()) {\n\t\t\tconst d: Domain = x.domain();\n\t\t\tconst origV: number = x.value();  // Save the value.\n\t\t\tconst elms: number[] = [];\n\n\t\t\tfor (const c of x) {\n\t\t\t\tif (c.size() !== 1) continue;\n\n\t\t\t\tfor (const v of d) {\n\t\t\t\t\tx.assign(v);\n\n\t\t\t\t\tif (c.isSatisfied() === 1) {\n\t\t\t\t\t\telms.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp.removeConstraint(c);\n\t\t\t}\n\t\t\tx.assign(origV);  // Restore the value.\n\t\t\tif (elms.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tx.domain(p.createDomain({ values: elms }) as Domain);\n\t\t}\n\t\treturn true;\n\t}\n\n}\n","/**\n * Utility class for constraint satisfaction problems.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nimport { Problem } from '../problem/problem';\nimport { CrispProblem } from '../problem/problem-crisp';\nimport { Variable } from '../problem/variable';\nimport { ImaginaryVariable } from '../problem/variables';\nimport { Domain } from '../problem/domain';\nimport { Relation } from '../problem/relation';\nimport { CrispRelation, FuzzyRelation } from '../problem/relation';\n\nexport class Problems {\n\n\tstatic #averagePathLength(p: Problem, x: Variable, length: number[], baseLength: number, xo: Set<Variable>): void {\n\t\tconst xn: Variable[] = [];\n\n\t\tfor (const c of x) {\n\t\t\tfor (const xi of c) {\n\t\t\t\tif (length[xi.index()] === Number.MAX_VALUE) {\n\t\t\t\t\txn.push(xi);\n\t\t\t\t\tlength[xi.index()] = baseLength + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const xi of xn) xo.add(xi);\n\t\tfor (const xi of xn) {\n\t\t\tProblems.#averagePathLength(p, xi, length, baseLength + 1, xo);\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the average path length for a given variable.\n\t * @param p A problem.\n\t * @param x A variable of the problem.\n\t * @return Average path length.\n\t */\n\tstatic averagePathLength(p: Problem, x: Variable): number {\n\t\tconst ls = new Array(p.variableSize());\n\t\tls.fill(Number.MAX_VALUE);\n\n\t\tconst xs = new Set<Variable>();\n\t\txs.add(x);\n\n\t\tls[x.index()] = 0;\n\t\tProblems.#averagePathLength(p, x, ls, 0, xs);\n\n\t\tlet connectedSize: number = 0;\n\t\tlet sum: number = 0;\n\n\t\tfor (let i: number = 0; i < ls.length; ++i) {\n\t\t\tif (ls[i] !== Number.MAX_VALUE && i !== x.index()) {\n\t\t\t\t++connectedSize;\n\t\t\t\tsum += ls[i];\n\t\t\t}\n\t\t}\n\t\tif (connectedSize === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn sum / connectedSize;\n\t}\n\n\t/**\n\t * Calculates the average path length.\n\t * @param p A problem.\n\t * @return Average path length.\n\t */\n\tstatic averagePathLengths(p: Problem): number[] {\n\t\tconst ls = new Array(p.variableSize());\n\n\t\tfor (const x of p.variables()) {\n\t\t\tls[x.index()] = Problems.averagePathLength(p, x);\n\t\t}\n\t\treturn ls;\n\t}\n\n\t/**\n\t * Gets an array containing all domains.\n\t * @param p A problem.\n\t * @return Array of domains.\n\t */\n\tstatic domains(p: Problem): Domain[] {\n\t\tconst ds: Domain[] = [];\n\n\t\tfor (const x of p.variables()) {\n\t\t\tds.push(x.domain());\n\t\t}\n\t\treturn ds;\n\t}\n\n\t/**\n\t * Returns the array of possible satisfaction degree values for all unary constraints.\n\t * @param p A problem.\n\t * @param degrees Array of degree values.\n\t * @return The array.\n\t */\n\tstatic possibleSatisfactionDegreesOfUnaryConstraints(p: Problem, degrees: number[]): number[] {\n\t\tfor (const c of p.constraints()) {\n\t\t\tif (c.size() !== 1) continue;\n\t\t\tconst x: Variable = c.at(0) as Variable;\n\t\t\tconst origVal: number = x.value();  // Save the value.\n\n\t\t\tfor (const v of x.domain()) {\n\t\t\t\tx.assign(v);\n\t\t\t\tdegrees.push(c.satisfactionDegree());\n\t\t\t}\n\t\t\tx.assign(origVal);  // Restore the value.\n\t\t}\n\t\treturn degrees;\n\t}\n\n\t/**\n\t * Set up all domains.\n\t * @param p A problem.\n\t * @param ds Array of domains.\n\t */\n\tstatic setDomains(p: Problem, ds: Domain[]): void {\n\t\tfor (let i: number = 0; i < ds.length; ++i) {\n\t\t\tp.variableAt(i).domain(ds[i]);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a view of the fuzzy constraint satisfaction problem as a crisp constraint satisfaction problem.\n\t * The relations and domains of the specified fuzzy constraint satisfaction problem are reused, but the other elements are newly generated.\n\t * Note: Assignments to variables and changes to domains of the view are reflected in the variables of the original problem.\n\t * @param p A fuzzy constraint satisfaction problem.\n\t * @param threshold The threshold of constraint satisfaction degree. A constraint is considered satisfied when the constraint satisfaction degree is greater than or equal to this value.\n\t * @return A crisp constraint satisfaction problem.\n\t */\n\tstatic toViewAsCrispProblem(p: Problem, threshold: number): CrispFuzzyProblem {\n\t\tconst cp = new CrispFuzzyProblem();\n\n\t\tfor (const x of p.variables()) {\n\t\t\tcp.createVariable({ variable: x });\n\t\t}\n\t\tfor (const c of p.constraints()) {\n\t\t\tconst xs: Variable[] = [];\n\n\t\t\tfor (const x of c) {\n\t\t\t\txs.push(cp.variableAt(x.index()));\n\t\t\t}\n\t\t\tlet r: Relation;\n\t\t\tif (c.isFuzzy()) {\n\t\t\t\tr = new CrispFuzzyRelation(c.fuzzyRelation(), threshold);\n\t\t\t} else {\n\t\t\t\tr = c.crispRelation();\n\t\t\t}\n\t\t\tcp.createConstraint({ relation: r, variables: xs });\n\t\t}\n\t\treturn cp;\n\t}\n\n}\n\nclass CrispFuzzyProblem extends CrispProblem {\n\n\tcreateVariable(args: { variable: Variable; }): Variable {\n\t\tconst iv = new ImaginaryVariable(args.variable);\n\t\tthis.addVariable(iv);\n\t\treturn iv;\n\t}\n\n}\n\nclass CrispFuzzyRelation implements CrispRelation {\n\n\t#th: number;\n\t#fr: FuzzyRelation;\n\n\tconstructor(fr: FuzzyRelation, th: number) {\n\t\tthis.#fr = fr;\n\t\tthis.#th = th;\n\t}\n\n\tisSatisfied(...vs: number[]): 0 | 1 {\n\t\treturn this.#fr.satisfactionDegree(...vs) >= this.#th ? 1 : 0;\n\t}\n\n}\n","/**\n * This class detects that a solver's operation is looping.\n *\n * @author Takuto Yanagida\n * @version 2024-10-22\n */\n\nexport class LoopDetector {\n\n\t#loopLength: number;\n\t#iterCount: number;\n\n\t#is: number[] = [];\n\t#vs: number[] = [];\n\n\t#cur: number = 0;\n\n\tconstructor(loopLength: number = 30, iterCount: number = 3) {\n\t\tthis.#loopLength = loopLength;\n\t\tthis.#iterCount = iterCount;\n\t\tthis.#initArrays();\n\t}\n\n\t#assignToVariable(index: number, value: number): void {\n\t\tthis.#is[this.#cur] = index;\n\t\tthis.#vs[this.#cur] = value;\n\n\t\tif (--this.#cur === -1) {\n\t\t\tthis.#cur = this.#is.length - 1;\n\t\t}\n\t}\n\n\t#checkLooping(): number {\n\t\tconst is = new Array(this.#loopLength);\n\t\tconst vs = new Array(this.#loopLength);\n\n\t\tout: for (let length: number = 1; length <= this.#loopLength; ++length) {\n\t\t\tlet offset: number = this.#cur + 1;\n\t\t\tfor (let i: number = 0; i < length; ++i) {\n\t\t\t\tif (i + offset === this.#is.length) {\n\t\t\t\t\toffset -= this.#is.length;\n\t\t\t\t}\n\t\t\t\tis[i] = this.#is[i + offset];\n\t\t\t\tvs[i] = this.#vs[i + offset];\n\t\t\t}\n\t\t\tlet fi: number = length;\n\t\t\tfor (let i: number = 0; i < this.#iterCount - 1; ++i) {\n\t\t\t\toffset = this.#cur + 1;\n\t\t\t\tfor (let j: number = 0; j < length; ++j) {\n\t\t\t\t\tif (fi + j + offset >= this.#is.length) {\n\t\t\t\t\t\toffset -= this.#is.length;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.#is[fi + j + offset] !== is[j] || this.#vs[fi + j + offset] !== vs[j]) {\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfi += length;\n\t\t\t}\n\t\t\treturn length;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t#initArrays(): void {\n\t\tthis.#is = new Array(this.#loopLength * this.#iterCount);\n\t\tthis.#vs = new Array(this.#loopLength * this.#iterCount);\n\t\tthis.#is.fill(-1);\n\t\tthis.#vs.fill(-1);\n\t\tthis.#cur = this.#is.length - 1;\n\t}\n\n\tcheckLoop(variableIndex: number, value: number): number {\n\t\tthis.#assignToVariable(variableIndex, value);\n\t\treturn this.#checkLooping();\n\t}\n\n\tclear(): void {\n\t\tthis.#is.fill(-1);\n\t\tthis.#vs.fill(-1);\n\t}\n\n\titerationCount(): number {\n\t\treturn this.#iterCount;\n\t}\n\n\tloopLength(): number {\n\t\treturn this.#loopLength;\n\t}\n\n\tvalues(): number[] {\n\t\treturn this.#vs.slice();\n\t}\n\n\tvariableIndices(): number[] {\n\t\treturn this.#is.slice();\n\t}\n\n}\n","export function waitFor(fn) {\n\treturn new Promise(r => {\n\t\tconst si = setInterval(() => {\n\t\t\tif (fn()) {\n\t\t\t\tclearInterval(si);\n\t\t\t\tr(null);\n\t\t\t}\n\t\t}, 100);\n\t});\n}\n\nexport function createLogOutput(id: string = 'output') {\n\tconst output = document.getElementById(id) as HTMLTextAreaElement;\n\treturn e => {\n\t\toutput.value += `${e}\\n`;\n\t\tsetTimeout(() => output.scrollTo(0, output.scrollHeight), 100);\n\t};\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","SolverFactory","$0f6ea66e9ef4e4cf$export$559d26475d35ac1e","$pU1Sy","$kjEaa","$3sJHX","$dldqc","$ebW8a","$94CnG","$AQJiv","$dVggH","o","d","Variable","r","xs","length","Constraint1","Constraint2","Constraint3","ConstraintN","setVariableFactory","fn","setConstraintFactory","addVariable","x","setIndex","push","createDomain","args","DomainArbitrary","values","DomainRanged","min","max","createVariable","variable","domain","setName","name","assign","value","undefined","contains","createConstraint","variables","owner","c","relation","connect","isFuzzy","removeConstraint","index","indexOf","splice","i","disconnect","clearAllVariables","clear","reverseVariables","reverse","sortVariables","comparator","sort","variableSize","variableAt","variableOf","hasVariable","includes","constraintSize","constraintAt","constraintOf","hasConstraint","constraints","constraintsBetween","v1","v2","cs","has","constraintsWithWorstSatisfactionDegree","cur","satisfactionDegree","Number","MIN_VALUE","worstSatisfactionDegree","Constraint","UNDEFINED","averageSatisfactionDegree","ave","emptyVariableSize","isEmpty","constraintDensity","hasEmptyDomain","size","$b3d2f9877ff61ecb$export$c867a5c9595a1350","$66bm1","Element","constructor","toString","np","at","neighbors","Symbol","iterator","RangeError","filter","$aebac6d707aea03e$export$db77ccec0bb4ccac","userObject","solverObject","$2e94c734a2d838e3$export$681548042801f21c","$b2Gif","Domain","next","done","$9d0e5c82a11742ce$export$f102e87ccfb079d0","random","Math","floor","$b4146d5df7ad9b79$export$62fe53be9d2bcdd3","vs","$b269187258a654e0$export$aec1359a0a40a615","rel","crispRelation","fuzzyRelation","sn","$6a0029ef3a1fce85$export$42d7bbd8a43e587d","isDefined","isSatisfied","highestConsistencyDegree","sd","cd","lowestConsistencyDegree","$28d738507c9375bb$export$18305a9eb79647d6","x1","x2","d1","d2","$dd27aab0852e9c64$export$7dc34a7e74bc57bb","x3","v3","d3","$cac261f9549e7972$export$fd9d2e5591a15c9a","Array","emptyIndices","checkHCD","checkLCD","currentStep","$b0fa7efcc20c7cf9$export$2d7b2a6964dca148","$4qG0Z","Problem","satisfiedConstraintRate","satisfiedConstraintSize","count","violatingConstraints","violatingConstraintSize","$8916545b3fe6be61$export$ebe658c66b5c45ae","$e5aa64fdd85bb56e$export$cca492cadf45c096","_debug","console","log","_pro","_iterLimit","_timeLimit","_targetDeg","pro","exec","setIterationLimit","setTimeLimit","msec","setTargetRate","rate","solve","addListener","l","removeListener","foundSolution","solution","worstDegree","finish","setDebugMode","flag","setDebugOutput","_debugOutput","str","$642a6c3604d92e8d$export$4e442516b8f577ee","$dqtH5","$envE3","$aDEbX","$b9ZRJ","$5pbCs","$2AvJP","$9BMnn","$9NLdx","$kYz6B","$2TCdz","$kpsHE","$ksORy","$8e260","$dfK30","$9wYtf","crispSolverNames","fuzzySolverNames","createSolver","type","p","createCrispSolver","createFuzzySolver","replaceAll","ForwardChecking","MaxForwardChecking","LocalChanges","LocalChangesEx","Breakout","GENET","CrispSRS3","FuzzyForwardChecking","FuzzyForwardCheckingBc","FlexibleLocalChanges","FlexibleLocalChangesEx","FuzzyBreakout","FuzzyGENET","SRS3","SRS3_PF","$5b597c0c8a6f9738$export$8570b7b487498488","$6nrDu","$5V057","$jWYxK","Solver","AssignmentList","DomainPruner","setUsingMinimumRemainingValuesHeuristics","j","level","currentIndex","x_i","d_i","dp_i","k","isValueHidden","hide","MAX_VALUE","hiddenSize","Date","now","setProblem","xc_index","xc","dp","reveal","a","apply","revealAll","$f354097057fedc87$export$1d4e454bcd46f18f","$blH6y","fromVariables","al","setVariables","Assignment","setAssignmentList","differenceSize","diff","$0a6def75b7f0de22$export$e6b39d88cc0d636","assignment","$d44a9b1f10b78424$export$f307752a90139b0e","fill","$695b212fabdeccbc$export$2a32484f7cb0d846","Set","vioCount","vcs","future","avc","add","deleted","$fefb29797493a6ea$export$8153937ab18ca581","delete","unassignAll","X1_X2","newX3","xa","origV","xi","A","X1","X2","union","X3","T","difference","xx","ret","notFixed","unassigned","$b0d12def09c2af65$export$e577c7182ffc977b","$c9db9f0e52a83cc6$export$44de86bc32e07644","setRandomness","vioXs","canList","maxDiff","x_v","nowVio","out","vioCs","from","endTime","iterCount","$047eed9e2a62e006$export$d94917317b4f74cb","nextInt","cons","$047eed9e2a62e006$var$Cluster","cl","_value","$047eed9e2a62e006$var$Connection","cl_f","cl_s","origV1","origV2","_neurons","lockConnections","is","temp","sol","order","success","modified","setActivityMaximumInput","clu","applyToVariable","con","refreshWeight","$047eed9e2a62e006$var$Neuron","_isActive","neurons","NEGATIVE_INFINITY","alreadyOn","input","getInput","_weight","first","second","addConnection","getNeuron","$73c03d91a2e9b25f$export$193930056f923a8","$73c03d91a2e9b25f$var$TreeNode","c0","node","c_stars","parent","getDescendants","getObject","tnc","obj","tn","tns","$40a3d027300d875f$export$2d94cf9ddb103458","CONTINUE","TERMINATE","setIncrementStepOfWorstSatisfactionDegree","degree","setIntensivePruning","vi_index","vj_index","orgVal","vi","vj","d_j","dp_j","loop_i","ni","nj","vk","d_k","dp_k","nk","v_i","emptySize","emp","indexes","comLoop","hidden","vc","index_x_i","x_j","bc","nextLevel","deg","$6186101130384aed$export$532d5536583284b8","$2781e45b3d984d73$export$c15ba88cf158f3d6","cr","res","Map","o1","o2","res1","res2","remain","low","high","h","consX1xi","consX12","rc","X3p","X1p","X2p","consX1","bestCons","bestX2","bestDij","x2Store","dij","consX1_xi","crNew","consX12_xi","repairCons","consX12xi","X","csd","wsd","initCons","initSol","result","$161a1ffca4c8b498$export$f3429dcb0286bfee","$eae699847452ddd0$export$151ca5d788220218","worstXs","worstCs","$5861f7a2b2a98532$export$6a3df005617df82a","worstDeg","$5861f7a2b2a98532$var$Cluster","$5861f7a2b2a98532$var$Connection","$5861f7a2b2a98532$var$Neuron","$9d09a091b6ea2794$export$4bfabca73d1ccb59","REPAIR_THRESHOLD","$9d09a091b6ea2794$var$TreeNode","minDeg0","maxDeg0","deg0","removeCStar","wsd_cs","cn","setParent","solutionWorstDeg","$c25e27777213027e$export$281ed65cbb041503","$6E6oA","uvs","PostStabilization","$a907b38c9f6e07f7$export$52631f16ca582d39","orig","stabilized","C_min","org","$f4847ffd40982f3c$export$9bbfceb27f687c1b","Promise","si","setInterval","clearInterval","$f4847ffd40982f3c$export$ad5fb9bd399ebc56","output","document","getElementById","setTimeout","scrollTo","scrollHeight"],"version":3,"file":"index.950b969f.js.map"}