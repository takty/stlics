var Qi=Object.defineProperty;var Ps=p=>{throw TypeError(p)};var Zi=(p,h,t)=>h in p?Qi(p,h,{enumerable:!0,configurable:!0,writable:!0,value:t}):p[h]=t;var v=(p,h,t)=>Zi(p,typeof h!="symbol"?h+"":h,t),cs=(p,h,t)=>h.has(p)||Ps("Cannot "+t);var i=(p,h,t)=>(cs(p,h,"read from private field"),t?t.call(p):h.get(p)),l=(p,h,t)=>h.has(p)?Ps("Cannot add the same private member more than once"):h instanceof WeakSet?h.add(p):h.set(p,t),f=(p,h,t,e)=>(cs(p,h,"write to private field"),e?e.call(p,t):h.set(p,t),t),d=(p,h,t)=>(cs(p,h,"access private method"),t);var A=(p,h,t,e)=>({set _(s){f(p,h,s,t)},get _(){return i(p,h,e)}});(function(){const h=document.createElement("link").relList;if(h&&h.supports&&h.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))e(s);new MutationObserver(s=>{for(const n of s)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&e(r)}).observe(document,{childList:!0,subtree:!0});function t(s){const n={};return s.integrity&&(n.integrity=s.integrity),s.referrerPolicy&&(n.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?n.credentials="include":s.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function e(s){if(s.ep)return;s.ep=!0;const n=t(s);fetch(s.href,n)}})();var ge,pe;class Xi{constructor(){l(this,ge,-1);l(this,pe,"");v(this,"userObject",null);v(this,"solverObject",null)}setIndex(h){f(this,ge,h)}setName(h){f(this,pe,h)}index(){return i(this,ge)}name(){return i(this,pe)}}ge=new WeakMap,pe=new WeakMap;const ss=class ss extends Xi{constructor(t){super();v(this,"rel");this.rel=t}crispRelation(){return this.rel}fuzzyRelation(){return this.rel}isFuzzy(){return"satisfactionDegree"in this.rel}toString(){const t=this.name(),e=t?`(${t})`:"",s=this.satisfactionDegree(),n=s===ss.UNDEFINED?"UNDEFINED":""+s;return`c${this.index()}${e} = ${n}`}};v(ss,"UNDEFINED",-1);let B=ss;var me,Ot;class R{constructor(h){v(this,"debug",!0);l(this,me,h=>console.log(h));v(this,"pro");v(this,"iterLimit",null);v(this,"timeLimit",null);v(this,"targetDeg",.8);l(this,Ot,[]);this.pro=h}name(){return""}exec(){return!1}setIterationLimit(h=null){this.iterLimit=h}setTimeLimit(h=null){this.timeLimit=h}setTargetRate(h=null){this.targetDeg=h}solve(){return this.exec()}addListener(h){i(this,Ot).push(h)}removeListener(h){i(this,Ot).splice(i(this,Ot).indexOf(h),1)}foundSolution(h,t){let e=!1;for(const s of i(this,Ot))s(h,t)&&(e=!0);return e}setDebugMode(h){this.debug=h}setDebugOutput(h){f(this,me,h)}debugOutput(h){this.debug&&i(this,me).call(this,h)}}me=new WeakMap,Ot=new WeakMap;var ut,lt;class Ye{constructor(h){l(this,ut);l(this,lt);if("assignment"in h)f(this,ut,h.assignment.variable()),f(this,lt,h.assignment.value());else if("variable"in h)f(this,ut,h.variable),f(this,lt,h.value??h.variable.value());else throw new RangeError}apply(){i(this,ut).assign(i(this,lt))}toString(){return`v${i(this,ut).index()} <- ${i(this,lt)}`}value(){return i(this,lt)}variable(){return i(this,ut)}}ut=new WeakMap,lt=new WeakMap;var V;const Fs=class Fs{constructor(){l(this,V,[])}static fromVariables(h){const t=new Fs;return t.setVariables(h),t}setProblem(h){i(this,V).length=0;for(const t of h.variables())i(this,V).push(new Ye({variable:t,value:t.value()}))}setAssignmentList(h){i(this,V).length=0;for(const t of h)i(this,V).push(new Ye({variable:t.variable(),value:t.value()}))}setVariables(h){i(this,V).length=0;for(const t of h)i(this,V).push(new Ye({variable:t,value:t.value()}))}addVariable(h,t=null){i(this,V).push(new Ye({variable:h,value:t}))}apply(){for(const h of i(this,V))h.apply()}clear(){i(this,V).length=0}isEmpty(){return i(this,V).length===0}size(){return i(this,V).length}differenceSize(){let h=0;for(const t of i(this,V))t.variable().value()!==t.value()&&++h;return h}at(h){return i(this,V)[h]}[Symbol.iterator](){return i(this,V)[Symbol.iterator]()}random(){return i(this,V)[Math.floor(Math.random()*i(this,V).length)]}};V=new WeakMap;let x=Fs;var ft,_,dt;const ct=class ct{constructor(h){l(this,_);l(this,dt,0);f(this,_,new Array(h)),i(this,_).fill(i(ct,ft))}hiddenSize(){return i(this,dt)}hide(h,t){i(this,_)[h]===i(ct,ft)&&++A(this,dt)._,i(this,_)[h]=t}isEmpty(){return i(this,_).length===i(this,dt)}isValueHidden(h){return i(this,_)[h]!==i(ct,ft)}reveal(h){for(let t=0;t<i(this,_).length;++t)i(this,_)[t]===h&&(i(this,_)[t]=i(ct,ft),--A(this,dt)._)}revealAll(){i(this,_).fill(i(ct,ft)),f(this,dt,0)}};ft=new WeakMap,_=new WeakMap,dt=new WeakMap,l(ct,ft,-1);let ce=ct;var k,be,gt,we,Kt,Jt,F,Ys,Ks,Js,Qs,us;class tn extends R{constructor(t){super(t);l(this,F);l(this,k);l(this,be,new x);l(this,gt,[]);l(this,we,!1);l(this,Kt,0);l(this,Jt,0);f(this,k,[...this.pro.variables()]);for(const e of i(this,k))e.solverObject=new ce(e.domain().size());d(this,F,Ys).call(this)}name(){return"Forward Checking"}setTargetRate(){}setUsingMinimumRemainingValuesHeuristics(t){f(this,we,t)}exec(){f(this,Jt,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),f(this,Kt,0),this.pro.clearAllVariables();const t=d(this,F,us).call(this,0);t||(this.iterLimit&&this.iterLimit<i(this,Kt)&&this.debugOutput("stop: number of iterations has reached the limit"),i(this,Jt)<Date.now()&&this.debugOutput("stop: time limit has been reached"));for(const e of i(this,be))e.apply(),e.variable().solverObject.revealAll();return t}}k=new WeakMap,be=new WeakMap,gt=new WeakMap,we=new WeakMap,Kt=new WeakMap,Jt=new WeakMap,F=new WeakSet,Ys=function(){f(this,gt,[]);for(let t=0;t<i(this,k).length;++t){i(this,gt).push(new Array(i(this,k).length));for(let e=0;e<i(this,k).length;++e)e<t&&(i(this,gt)[t][e]=this.pro.constraintsBetween(i(this,k)[e],i(this,k)[t]))}},Ks=function(t,e){return t<e?i(this,gt)[e][t]:i(this,gt)[t][e]},Js=function(t,e){for(const s of i(this,k)){if(!s.isEmpty())continue;const n=s.domain(),r=s.solverObject,o=d(this,F,Ks).call(this,e,s.index());for(const a of o)if(a.emptyVariableSize()===1){for(let c=0,u=n.size();c<u;++c)r.isValueHidden(c)||(s.assign(n.at(c)),a.isSatisfied()===0&&r.hide(c,t));if(s.clear(),r.isEmpty())return!1}}return!0},Qs=function(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<i(this,k).length;++s){const n=i(this,k)[s];if(!n.isEmpty())continue;const o=n.domain().size()-n.solverObject.hiddenSize();o<e&&(e=o,t=s)}return t},us=function(t){if(this.iterLimit&&this.iterLimit<A(this,Kt)._++||i(this,Jt)<Date.now())return!1;if(t===this.pro.variableSize())return i(this,be).setProblem(this.pro),!0;const e=i(this,we)?d(this,F,Qs).call(this):t,s=i(this,k)[e],n=s.domain(),r=s.solverObject;for(let o=0,a=n.size();o<a;++o)if(!r.isValueHidden(o)){if(s.assign(n.at(o)),d(this,F,Js).call(this,t,e)&&d(this,F,us).call(this,t+1))return!0;for(const c of i(this,k))c.solverObject.reveal(t)}return s.clear(),!1};var W,De,st,zt,Qt,Et,Zt,Xt,K,ls,Zs,Xs,ti;class en extends R{constructor(t){super(t);l(this,K);l(this,W);l(this,De,new x);l(this,st);l(this,zt,0);l(this,Qt,new Set);l(this,Et,[]);l(this,Zt,0);l(this,Xt,0);f(this,W,[...this.pro.variables()]);for(const e of i(this,W))e.solverObject=new ce(e.domain().size());f(this,st,this.pro.constraintSize())}name(){return"Forward Checking for Max CSPs"}exec(){f(this,Xt,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),f(this,Zt,0),this.pro.clearAllVariables();const t=d(this,K,ls).call(this,0,0);t?this.debugOutput("stop: current degree is above the target"):(this.iterLimit&&this.iterLimit<i(this,Zt)&&this.debugOutput("stop: number of iterations has reached the limit"),i(this,Xt)<Date.now()&&this.debugOutput("stop: time limit has been reached"));for(const e of i(this,De))e.apply(),e.variable().solverObject.revealAll();return t}}W=new WeakMap,De=new WeakMap,st=new WeakMap,zt=new WeakMap,Qt=new WeakMap,Et=new WeakMap,Zt=new WeakMap,Xt=new WeakMap,K=new WeakSet,ls=function(t,e){if(this.iterLimit&&this.iterLimit<A(this,Zt)._++||i(this,Xt)<Date.now())return!1;const s=this.pro;if(t===s.variableSize()){const a=s.violatingConstraintSize();return a<i(this,st)&&(f(this,st,a),i(this,De).setProblem(this.pro),this.debugOutput(`   refreshed ${i(this,st)}`),(this.targetDeg??1)<=s.satisfiedConstraintRate())}const n=i(this,W)[t],r=n.domain(),o=n.solverObject;for(let a=0,c=r.size();a<c;++a)if(!o.isValueHidden(a)&&(n.assign(r.at(a)),f(this,zt,e+d(this,K,Xs).call(this,t,n)),!(i(this,zt)>i(this,st)))){if(d(this,K,Zs).call(this,t)&&d(this,K,ls).call(this,t+1,i(this,zt)))return!0;for(const u of i(this,W))u.solverObject.reveal(t)}return n.clear(),!1},Zs=function(t){const e=i(this,W)[t];for(let s=t+1;s<i(this,W).length;++s){const n=i(this,W)[s];f(this,Et,this.pro.constraintsBetween(e,n));for(const r of i(this,Et))if(r.emptyVariableSize()===1&&d(this,K,ti).call(this,n,r,t)&&n.solverObject.isEmpty())return!1}return!0},Xs=function(t,e){let s=0;i(this,Qt).clear();for(let n=0;n<t;++n){f(this,Et,this.pro.constraintsBetween(e,i(this,W)[n]));for(const r of i(this,Et))i(this,Qt).has(r)||(r.isSatisfied()===0&&++s,i(this,Qt).add(r))}return s},ti=function(t,e,s){let n=!1;const r=t.domain(),o=t.solverObject;for(let a=0,c=r.size();a<c;++a)o.isValueHidden(a)||(t.assign(r.at(a)),e.isSatisfied()===0&&i(this,zt)+1>i(this,st)&&(o.hide(a,s),n=!0));return n};var vt,ds,gs,xe,ve,it,C,ei,Ke,si,ps,Je;const St=class St extends R{constructor(t,e=!1){super(t);l(this,C);l(this,xe,0);l(this,ve,0);l(this,it,!1);e&&this.pro.clearAllVariables()}name(){return"Local Changes"}exec(){f(this,ve,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),f(this,xe,0),f(this,it,!1),this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const t=new Set,e=new Set;for(const s of this.pro.variables())(s.isEmpty()?e:t).add(s);return d(this,C,Je).call(this,new Set,t,e)}};vt=new WeakSet,ds=function(t,e){return new Set(t).add(e)},gs=function(t,e){const s=new Set(t);return s.delete(e),s},xe=new WeakMap,ve=new WeakMap,it=new WeakMap,C=new WeakSet,ei=function(t,e,s){const n=new Set,r=new Set;for(const a of t){const c=this.pro.constraintsBetween(e,a);for(const u of c)r.add(u)}const o=e.value();e.assign(s);for(const a of r)if(a.isSatisfied()===0)for(const c of a)n.add(c);return e.assign(o),n.delete(e),n},Ke=function(t,e,s){const n=new Set;for(const o of t){const a=this.pro.constraintsBetween(e,o);for(const c of a)n.add(c)}const r=e.value();e.assign(s);for(const o of n)if(o.isSatisfied()===0)return e.assign(r),!1;return e.assign(r),!0},si=function(t,e,s,n){var c;if(!d(this,C,Ke).call(this,t,s,n))return!1;const r=t.union(e);if(d(this,C,Ke).call(this,r,s,n))return!0;const o=d(this,C,ei).call(this,r,s,n),a=r.difference(o);d(this,C,Ke).call(this,a,s,n)||this.debugOutput("bug");for(const u of o)u.clear();return t=d(c=St,vt,ds).call(c,t,s),e=e.difference(o),d(this,C,Je).call(this,t,e,o)},ps=function(t,e,s,n){var c;if(n.size===0)return!1;const r=n.values().next().value,o=x.fromVariables(e);s.assign(r);const a=d(this,C,si).call(this,t,e,s,r);return a||i(this,it)?a:(s.clear(),o.apply(),d(this,C,ps).call(this,t,e,s,d(c=St,vt,gs).call(c,n,r)))},Je=function(t,e,s){var a,c;if(this.debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),(this.targetDeg??1)<=this.pro.satisfiedConstraintRate())return this.debugOutput("stop: current degree is above the target"),f(this,it,!0),!0;if(this.iterLimit&&this.iterLimit<A(this,xe)._++)return this.debugOutput("stop: number of iterations has reached the limit"),f(this,it,!0),!1;if(i(this,ve)<Date.now())return this.debugOutput("stop: time limit has been reached"),f(this,it,!0),!1;if(s.size===0)return!0;const n=s.values().next().value,r=new Set;for(const u of n.domain())r.add(u);const o=d(this,C,ps).call(this,t,e,n,r);return!o||i(this,it)?o:(e=d(a=St,vt,ds).call(a,e,n),s=d(c=St,vt,gs).call(c,s,n),d(this,C,Je).call(this,t,e,s))},l(St,vt);let fs=St;var is,ii,Se,Oe,nt,j,ni,bs,ri,oi,ws;const ns=class ns extends R{constructor(t,e=!1){super(t);l(this,j);l(this,Se,0);l(this,Oe,0);l(this,nt,!1);e&&this.pro.clearAllVariables()}name(){return"Local Changes Ex"}exec(){f(this,Oe,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),f(this,Se,0),f(this,nt,!1),this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const t=new Set,e=new Set;for(const s of this.pro.variables())(s.isEmpty()?e:t).add(s);return d(this,j,ws).call(this,new Set,t,e)}};is=new WeakSet,ii=function(t,e){return new Set(t).add(e)},Se=new WeakMap,Oe=new WeakMap,nt=new WeakMap,j=new WeakSet,ni=function(t,e,s){const n=new Set,r=new Set;for(const a of t){const c=this.pro.constraintsBetween(e,a);for(const u of c)r.add(u)}const o=e.value();e.assign(s);for(const a of r)if(a.isSatisfied()===0)for(const c of a)n.add(c);return e.assign(o),n.delete(e),n},bs=function(t,e,s){const n=new Set;for(const o of t){const a=this.pro.constraintsBetween(e,o);for(const c of a)n.add(c)}const r=e.value();e.assign(s);for(const o of n)if(o.isSatisfied()===0)return e.assign(r),!1;return e.assign(r),!0},ri=function(t,e,s){var o;if(!d(this,j,bs).call(this,t,s,s.value()))return!1;const n=t.union(e);if(d(this,j,bs).call(this,n,s,s.value()))return!0;const r=d(this,j,ni).call(this,n,s,s.value());return t=d(o=ns,is,ii).call(o,t,s),e=e.difference(r),d(this,j,ws).call(this,t,e,r)},oi=function(t,e,s){for(const n of s.domain()){const r=x.fromVariables(e);s.assign(n);const o=d(this,j,ri).call(this,t,e,s);if(o||i(this,nt))return o;s.clear(),r.apply()}return!1},ws=function(t,e,s){for(e=new Set(e),s=new Set(s);;){if(this.debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),(this.targetDeg??1)<=this.pro.satisfiedConstraintRate())return this.debugOutput("stop: current degree is above the target"),f(this,nt,!0),!0;if(this.iterLimit&&this.iterLimit<A(this,Se)._++)return this.debugOutput("stop: number of iterations has reached the limit"),f(this,nt,!0),!1;if(i(this,Oe)<Date.now())return this.debugOutput("stop: time limit has been reached"),f(this,nt,!0),!1;if(s.size===0)return!0;const n=s.values().next().value,r=d(this,j,oi).call(this,t,e,n);if(!r||i(this,nt))return r;e.add(n),s.delete(n)}},l(ns,is);let ms=ns;var ze,pt,ue,ai,hi;class sn extends R{constructor(t){super(t);l(this,ue);l(this,ze,!0);l(this,pt);f(this,pt,new Array(this.pro.constraintSize())),i(this,pt).fill(1)}name(){return"Breakout"}setRandomness(t){f(this,ze,t)}exec(){const t=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let e=0;for(const r of this.pro.variables())r.isEmpty()&&r.assign(r.domain().at(0));const s=new x,n=this.pro;for(;;){const r=n.violatingConstraints();if((this.targetDeg??1)<=n.satisfiedConstraintRate())return this.debugOutput("stop: current degree is above the target"),!0;if(this.iterLimit&&this.iterLimit<e++)return this.debugOutput("stop: number of iterations has reached the limit"),!1;if(t<Date.now())return this.debugOutput("stop: time limit has been reached"),!1;if(this.debugOutput(r.length+" violations"),d(this,ue,ai).call(this,d(this,ue,hi).call(this,r),s),0<s.size()){const o=i(this,ze)?s.random():s.at(0);o.apply(),s.clear(),this.debugOutput("	"+o)}else{for(const o of r)i(this,pt)[o.index()]+=1;this.debugOutput("breakout")}}}}ze=new WeakMap,pt=new WeakMap,ue=new WeakSet,ai=function(t,e){let s=0;for(const n of t){const r=n.value();let o=0;for(const a of n)o+=(1-a.isSatisfied())*i(this,pt)[a.index()];t:for(const a of n.domain()){if(r===a)continue;n.assign(a);let c=o;for(const u of n)if(c-=(1-u.isSatisfied())*i(this,pt)[u.index()],c<s)continue t;c>s?(s=c,e.clear(),e.addVariable(n,a)):s!==0&&e.addVariable(n,a)}n.assign(r)}},hi=function(t){const e=new Set;for(const s of t)for(const n of s)e.add(n);return Array.from(e)};var G,Ee,le,ci,ui;const Us=class Us extends R{constructor(t){super(t);l(this,le);l(this,G,[]);l(this,Ee,[])}static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}name(){return"GENET"}exec(){if(!d(this,le,ci).call(this))throw new Error;const t=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let e=0;const s=new x,n=[];for(let c=0;c<i(this,G).length;++c)n.push(c);const r=this.pro;let o=r.satisfiedConstraintRate(),a=!1;for(;;){if(this.iterLimit&&this.iterLimit<e++){this.debugOutput("stop: number of iterations has reached the limit");break}if(t<Date.now()){this.debugOutput("stop: time limit has been reached");break}let c=!1;for(const u of d(this,le,ui).call(this,n))i(this,G)[u].setActivityMaximumInput()&&(c=!0);if(c){for(const g of i(this,G))g.applyToVariable();const u=r.satisfiedConstraintRate();if(o<u){if(o=u,this.debugOutput(`satisfied constraint rate: ${u}`),s.setProblem(this.pro),this.foundSolution(s,u)){a=!0;break}if(this.targetDeg??1<=o){this.debugOutput("stop: current degree is above the target"),a=!0;break}}}else for(const u of i(this,Ee))u.refreshWeight()}return s.apply(),a}};G=new WeakMap,Ee=new WeakMap,le=new WeakSet,ci=function(){this.debugOutput("network creation start");const t=[];for(const e of this.pro.variables()){if(e.domain().size()===0)return!1;i(this,G).push(new nn(e))}for(const e of this.pro.constraints())if(e.size()===1){const s=e.at(0),n=i(this,G)[s.index()];for(let r=0;r<n.size();++r){const o=s.value();s.assign(n.get(r)._value),e.isSatisfied()===0&&t.push(new Hs(n.get(r))),s.assign(o)}}else{const s=e.at(0),n=e.at(1),r=i(this,G)[s.index()],o=i(this,G)[n.index()];for(let a=0;a<r.size();++a){const c=s.value();s.assign(r.get(a)._value);for(let u=0;u<o.size();++u){const g=n.value();n.assign(o.get(u)._value),e.isSatisfied()===0&&t.push(new Hs(r.get(a),o.get(u))),n.assign(g)}s.assign(c)}}for(const e of i(this,G))for(const s of e._neurons)s.lockConnections();return f(this,Ee,t),this.debugOutput("network creation complete"),!0},ui=function(t){for(let e=t.length;e>1;--e){const s=Us.nextInt(e),n=t[e-1];t[e-1]=t[s],t[s]=n}return t};let Ds=Us;var ye,te,rt,Ve,xs,Gt;let nn=(Gt=class{constructor(h){l(this,Ve);l(this,ye);l(this,te,0);l(this,rt,[]);v(this,"_neurons",[]);f(this,ye,h);for(const t of h.domain())this._neurons.push(new rn(t));d(this,Ve,xs).call(this,Gt.nextInt(this._neurons.length))}static nextInt(h){return Math.floor(Math.random()*Math.floor(h))}applyToVariable(){i(this,ye).assign(this._neurons[i(this,te)]._value)}get(h){return this._neurons[h]}neurons(){return this._neurons}setActivityMaximumInput(){i(this,rt).length=0;let h=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const s=this._neurons[e].getInput();h<=s&&(h<s&&(h=s,i(this,rt).length=0,t=!1),i(this,rt).push(e),i(this,te)===e&&(t=!0))}return t||i(this,rt).length===0?!1:(d(this,Ve,xs).call(this,i(this,rt)[Gt.nextInt(i(this,rt).length)]),!0)}size(){return this._neurons.length}},ye=new WeakMap,te=new WeakMap,rt=new WeakMap,Ve=new WeakSet,xs=function(h){for(const t of this._neurons)t._isActive=!1;this._neurons[h]._isActive=!0,f(this,te,h)},Gt);var mt,Q,Ws;let Hs=(Ws=class{constructor(h,t=null){l(this,mt);l(this,Q);v(this,"_weight");this._weight=-1,f(this,mt,h),i(this,mt).addConnection(this),f(this,Q,t),i(this,Q)&&i(this,Q).addConnection(this)}getNeuron(h){return h===i(this,mt)?i(this,Q):h===i(this,Q)?i(this,mt):null}refreshWeight(){!i(this,mt)._isActive||i(this,Q)!==null&&!i(this,Q)._isActive||(this._weight+=-1)}},mt=new WeakMap,Q=new WeakMap,Ws);var ee,Le,Gs;let rn=(Gs=class{constructor(h){l(this,ee,[]);l(this,Le,[]);v(this,"_value");v(this,"_isActive",!1);this._value=h}addConnection(h){i(this,ee).push(h)}lockConnections(){f(this,Le,[...i(this,ee)]),f(this,ee,null)}getInput(){let h=0;for(const t of i(this,Le)){const e=t.getNeuron(this);h+=t._weight*(e===null||e._isActive?1:0)}return h}},ee=new WeakMap,Le=new WeakMap,Gs);var Ne,yt,P,se,Vt,M,li,Qe,fi,vs,di;class on extends R{constructor(t){super(t);l(this,M);l(this,Ne,!0);l(this,yt,new Set);l(this,P,new Set);l(this,se,[]);l(this,Vt,[]);for(const e of this.pro.constraints())i(this,se).push(new an(e)),i(this,Vt).push(null)}name(){return"SRS 3 for Crisp CSPs"}setRandomness(t){f(this,Ne,t)}exec(){const t=this.pro.violatingConstraints(),e=new Set;for(const s of t){const n=i(this,se)[s.index()];e.add(n)}return d(this,M,di).call(this,e)?!0:e.size===0}}Ne=new WeakMap,yt=new WeakMap,P=new WeakMap,se=new WeakMap,Vt=new WeakMap,M=new WeakSet,li=function(t){const e=t.index();return i(this,Vt)[e]===null&&(i(this,Vt)[e]=t.neighbors()),i(this,Vt)[e]},Qe=function(t){this.debugOutput("repair");const e=new x;let s=0;for(const n of t){const r=n.value();let o=0;for(const a of n)o+=1-a.isSatisfied();t:for(const a of n.domain()){if(r===a||(n.assign(a),t.isSatisfied()!==1))continue;let c=o;for(const u of n)if(c-=1-u.isSatisfied(),c<s)continue t;c>s?(s=c,e.clear(),e.addVariable(n,a)):s!==0&&e.addVariable(n,a)}n.assign(r)}if(e.size()>0){const n=i(this,Ne)?e.random():e.at(0);return n.apply(),this.debugOutput("	"+n),!0}return!1},fi=function(t,e){const s=[];let n=t;for(;;){n=n.parent(),s.length=0,n.getDescendants(s),n.clear();for(const r of e)i(this,P).delete(r),i(this,yt).delete(r);if(e.delete(n)||(i(this,P).add(n),n.parent()!==null&&!d(this,M,Qe).call(this,n.parent().getObject())))break}},vs=function(t){this.debugOutput("spread"),i(this,yt).add(t);for(const e of d(this,M,li).call(this,t.getObject())){const s=i(this,se)[e.index()];!i(this,yt).has(s)&&!i(this,P).has(s)&&(s.clear(),t.add(s),i(this,P).add(s))}},di=function(t){this.debugOutput("srs");const e=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let s=0;i(this,yt).clear(),i(this,P).clear();for(const r of t)i(this,P).add(r);const n=this.pro;for(;t.size&&i(this,P).size;){if((this.targetDeg??1)<=n.satisfiedConstraintRate())return this.debugOutput("stop: current degree is above the target"),!0;if(this.iterLimit&&this.iterLimit<s++)return this.debugOutput("stop: number of iterations has reached the limit"),!1;if(e<Date.now())return this.debugOutput("stop: time limit has been reached"),!1;const r=i(this,P).values().next().value;i(this,P).delete(r),d(this,M,Qe).call(this,r.getObject())?t.delete(r)||(r.parent()!==null&&d(this,M,Qe).call(this,r.parent().getObject())?d(this,M,fi).call(this,r,t):d(this,M,vs).call(this,r)):d(this,M,vs).call(this,r)}return!1};var Lt,Nt,Ce,qs;let an=(qs=class{constructor(h){l(this,Lt,[]);l(this,Nt);l(this,Ce);f(this,Nt,null),f(this,Ce,h)}add(h){f(h,Nt,this),i(this,Lt).push(h)}clear(){for(const h of i(this,Lt))f(h,Nt,null);i(this,Lt).length=0}getDescendants(h){h.push(this);for(const t of i(this,Lt))t.getDescendants(h)}getObject(){return i(this,Ce)}parent(){return i(this,Nt)}},Lt=new WeakMap,Nt=new WeakMap,Ce=new WeakMap,qs);var S,Ct,bt,O,At,kt,ie,Ae,Z,ke,Mt,Me,b,gi,Ze,Os,pi,mi,bi,wi,Di,xi,vi,zs,Es,Si;const U=class U extends R{constructor(t,e=null){super(t);l(this,b);l(this,S);l(this,Ct,new x);l(this,bt,[]);l(this,O,0);l(this,At,0);l(this,kt,0);l(this,ie,!1);l(this,Ae,0);l(this,Z);l(this,ke);l(this,Mt);l(this,Me,!1);f(this,S,[...this.pro.variables()]),f(this,Z,new Array(this.pro.variableSize())),d(this,b,gi).call(this),f(this,Mt,new Array(this.pro.constraintSize()));const s=[];for(const n of this.pro.constraints())n.size()===1&&s.push(n);f(this,ke,[...s]),e&&f(this,O,e)}name(){return"Forward Checking for Fuzzy CSPs"}setUsingMinimumRemainingValuesHeuristics(t){f(this,ie,t)}setIncrementStepOfWorstSatisfactionDegree(t){f(this,Ae,t)}setIntensivePruning(t){f(this,Me,t)}setTargetRate(t=null){if(this.targetDeg=t,this.targetDeg===null)f(this,O,0);else{let e=Number.MIN_VALUE;for(f(this,O,this.targetDeg-e);i(this,O)>=this.targetDeg;)e*=10,f(this,O,this.targetDeg-e)}}exec(){f(this,kt,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),f(this,At,0);for(const e of i(this,S))e.solverObject=new ce(e.domain().size());if(this.pro.clearAllVariables(),!d(this,b,Os).call(this))return!1;let t=!1;for(;;){if(d(this,b,Es).call(this,0)===U.TERMINATE){if(this.iterLimit&&this.iterLimit<A(this,At)._++){this.debugOutput("stop: number of iterations has reached the limit");break}if(i(this,kt)<Date.now()){this.debugOutput("stop: time limit has been reached");break}}if(i(this,Ct).isEmpty())break;if(this.debugOutput(`	found a solution: ${i(this,O)}`),this.foundSolution(i(this,Ct),i(this,O))){t=!0;break}if(this.targetDeg===null)t=!0,f(this,O,i(this,O)+i(this,Ae));else if(this.targetDeg<=i(this,O)){this.debugOutput("stop: current degree is above the target"),t=!0;break}for(const s of i(this,S))s.solverObject.revealAll()}i(this,Ct).apply();for(const e of i(this,S))e.solverObject=null;return t}};S=new WeakMap,Ct=new WeakMap,bt=new WeakMap,O=new WeakMap,At=new WeakMap,kt=new WeakMap,ie=new WeakMap,Ae=new WeakMap,Z=new WeakMap,ke=new WeakMap,Mt=new WeakMap,Me=new WeakMap,b=new WeakSet,gi=function(){f(this,bt,[]);for(let t=0;t<i(this,S).length;++t){i(this,bt).push(new Array(i(this,S).length));for(let e=0;e<i(this,S).length;++e)e<t&&(i(this,bt)[t][e]=this.pro.constraintsBetween(i(this,S)[e],i(this,S)[t]))}},Ze=function(t,e){return t<e?i(this,bt)[e][t]:i(this,bt)[t][e]},Os=function(){for(const t of i(this,ke)){const e=t.at(0),s=e.value(),n=e.domain(),r=e.solverObject;for(let o=0,a=n.size();o<a;++o)e.assign(n.at(o)),t.satisfactionDegree()<=i(this,O)&&r.hide(o,-1);if(e.assign(s),r.isEmpty())return!1}return!0},pi=function(t,e,s){const n=e.domain(),r=e.solverObject;for(let o=0,a=n.size();o<a;++o)r.isValueHidden(o)||(e.assign(n.at(o)),s.satisfactionDegree()<=i(this,O)&&r.hide(o,t));return e.clear(),!r.isEmpty()},mi=function(t,e,s){const n=e.domain(),r=e.solverObject;let o=null;for(const u of s)if(u.isEmpty()&&u!==e){o=u;break}const a=o.domain(),c=o.solverObject;t:for(let u=0,g=n.size();u<g;++u)if(!r.isValueHidden(u)){e.assign(n.at(u));for(let m=0,w=a.size();m<w;++m){if(c.isValueHidden(m))continue;if(o.assign(a.at(m)),s.satisfactionDegree()>i(this,O))continue t}r.hide(u,t)}return o.clear(),e.clear(),!r.isEmpty()},bi=function(t,e,s){const n=e.domain(),r=e.solverObject;let o=null,a=null;for(const w of s)if(w.isEmpty()&&w!==e)if(o===null)o=w;else{a=w;break}const c=o.domain(),u=a.domain(),g=o.solverObject,m=a.solverObject;t:for(let w=0,D=n.size();w<D;++w)if(!r.isValueHidden(w)){e.assign(n.at(w));for(let T=0,ht=c.size();T<ht;++T)if(!g.isValueHidden(T)){o.assign(c.at(T));for(let J=0,Ji=u.size();J<Ji;++J){if(m.isValueHidden(J))continue;if(a.assign(u.at(J)),s.satisfactionDegree()>i(this,O))continue t}}r.hide(w,t)}return a.clear(),o.clear(),e.clear(),!r.isEmpty()},wi=function(t,e,s,n){const r=e.domain(),o=e.solverObject,a=new Array(n-1);let c=0;for(const g of s)g.isEmpty()&&g!==e&&(a[c++]=g);const u=new Array(a.length);t:for(let g=0,m=r.size();g<m;++g)if(!o.isValueHidden(g)){e.assign(r.at(g)),u.fill(0);e:for(;;){let w=!1;for(let D=0;D<a.length;++D){const T=a[D].domain();if(a[D].solverObject.isValueHidden(u[D])){w=!0;break}a[D].assign(T.at(u[D]))}if(!w&&s.satisfactionDegree()>i(this,O))continue t;for(let D=0;D<a.length&&(u[D]+=1,!(u[D]<a[D].domain().size()));++D)if(u[D]=0,D===a.length-1)break e}o.hide(g,t)}for(const g of a)g.clear();return e.clear(),!o.isEmpty()},Di=function(t,e){for(const s of i(this,S)){if(!s.isEmpty())continue;const n=d(this,b,Ze).call(this,e,s.index());for(const r of n){const o=r.emptyVariableSize();if(o===1){if(!d(this,b,pi).call(this,t,s,r))return!1}else if(i(this,Me)){if(o===2){if(!d(this,b,mi).call(this,t,s,r))return!1}else if(o===3){if(!d(this,b,bi).call(this,t,s,r))return!1}else if(o>3&&!d(this,b,wi).call(this,t,s,r,o))return!1}}}return!0},xi=function(t){i(this,Mt).fill(!1);for(let e=0;e<i(this,S).length;++e){const s=i(this,S)[e];if(s===t||s.isEmpty())continue;const n=d(this,b,Ze).call(this,t.index(),e);for(const r of n){if(i(this,Mt)[r.index()])continue;const o=r.satisfactionDegree();if(o!==B.UNDEFINED&&o<=i(this,O))return!1;i(this,Mt)[r.index()]=!0}}return!0},vi=function(){for(let t=0;t<i(this,Z).length;++t){const e=i(this,Z)[t].index();for(let s=t+1;s<i(this,Z).length;++s){const n=i(this,Z)[s],r=d(this,b,Ze).call(this,e,n.index());for(const o of r){const a=n.value(),c=n.domain(),u=n.solverObject;for(let g=0,m=c.size();g<m;++g)u.isValueHidden(g)||(n.assign(c.at(g)),o.satisfactionDegree()<=i(this,O)&&u.hide(g,t));n.assign(a)}}}},zs=function(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<i(this,S).length;++s){const n=i(this,S)[s];if(!n.isEmpty())continue;const o=n.domain().size()-n.solverObject.hiddenSize();o<e&&(e=o,t=s)}return t},Es=function(t){let e=U.CONTINUE;const s=i(this,ie)?d(this,b,zs).call(this):t,n=i(this,S)[s],r=n.domain(),o=n.solverObject;i(this,Z)[t]=n;for(let a=0,c=r.size();a<c;++a){if(o.isValueHidden(a))continue;if(this.iterLimit&&this.iterLimit<A(this,At)._++||i(this,kt)<Date.now()){e=U.TERMINATE;break}n.assign(r.at(a));for(const g of i(this,S))g.solverObject.reveal(t);if(!d(this,b,xi).call(this,n)||!d(this,b,Di).call(this,t,s))continue;const u=t+1;if(e=u===i(this,S).length-1?d(this,b,Si).call(this,u):d(this,b,Es).call(this,u),e===U.TERMINATE)break}if(e===U.CONTINUE)for(const a of i(this,S))a.solverObject.reveal(t);return n.clear(),e},Si=function(t){let e=U.CONTINUE;const s=i(this,S)[i(this,ie)?d(this,b,zs).call(this):t],n=s.domain(),r=s.solverObject;i(this,Z)[t]=s;for(let o=0,a=n.size();o<a;++o){if(r.isValueHidden(o))continue;if(this.iterLimit&&this.iterLimit<A(this,At)._++||i(this,kt)<Date.now()){e=U.TERMINATE;break}s.assign(n.at(o));const c=this.pro.worstSatisfactionDegree();if(c>i(this,O)){if(f(this,O,c),i(this,Ct).setProblem(this.pro),e=U.TERMINATE,this.targetDeg!==null&&this.targetDeg<=i(this,O))break;d(this,b,Os).call(this),d(this,b,vi).call(this)}}return s.clear(),e},v(U,"CONTINUE",0),v(U,"TERMINATE",1);let Ss=U;var E,Tt,wt,L,It,jt,ne,Rt,N,Oi,zi,Ei,yi,Vs,Ls,Vi;const $=class $ extends R{constructor(t,e=null){super(t);l(this,N);l(this,E);l(this,Tt,new x);l(this,wt,[]);l(this,L,0);l(this,It,0);l(this,jt,0);l(this,ne,!1);l(this,Rt,0);f(this,E,[...this.pro.variables()]),d(this,N,Oi).call(this),f(this,L,Math.max(0,t.worstSatisfactionDegree())),e&&f(this,L,e)}name(){return"Forward Checking for Fuzzy CSPs of Binary Constraints"}setUsingMinimumRemainingValuesHeuristics(t){f(this,ne,t)}setIncrementStepOfWorstSatisfactionDegree(t){f(this,Rt,t)}setTargetRate(t=null){if(this.targetDeg=t,this.targetDeg===null)f(this,L,0);else{let e=Number.MIN_VALUE;for(f(this,L,this.targetDeg-e);i(this,L)>=this.targetDeg;)e*=10,f(this,L,this.targetDeg-e)}}exec(){f(this,jt,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),f(this,It,0);for(const s of i(this,E))s.solverObject=new ce(s.domain().size());this.pro.clearAllVariables();const t=new x;let e=!1;for(;;){if(d(this,N,Ls).call(this,0)===$.TERMINATE){if(this.iterLimit&&this.iterLimit<A(this,It)._++){this.debugOutput("stop: number of iterations has reached the limit");break}if(i(this,jt)<Date.now()){this.debugOutput("stop: time limit has been reached");break}}if(i(this,Tt).isEmpty())break;if(t.setAssignmentList(i(this,Tt)),i(this,Tt).clear(),this.debugOutput(`	found a solution: ${i(this,L)}`),this.foundSolution(t,i(this,L))){e=!0;break}if(this.targetDeg===null){if(e=!0,i(this,L)+i(this,Rt)>1)break;f(this,L,i(this,L)+(i(this,L)+i(this,Rt)>1?0:i(this,Rt)))}else if(this.targetDeg<=i(this,L)){this.debugOutput("stop: current degree is above the target"),e=!0;break}for(const n of i(this,E))n.solverObject.revealAll()}t.apply();for(const s of i(this,E))s.solverObject=null;return e}};E=new WeakMap,Tt=new WeakMap,wt=new WeakMap,L=new WeakMap,It=new WeakMap,jt=new WeakMap,ne=new WeakMap,Rt=new WeakMap,N=new WeakSet,Oi=function(){f(this,wt,[]);for(let t=0;t<i(this,E).length;++t){i(this,wt).push(new Array(i(this,E).length));for(let e=0;e<i(this,E).length;++e)e<t&&(i(this,wt)[t][e]=this.pro.constraintsBetween(i(this,E)[e],i(this,E)[t]))}},zi=function(t,e){return t<e?i(this,wt)[e][t]:i(this,wt)[t][e]},Ei=function(t,e,s){const n=e.domain(),r=e.solverObject;for(let o=0,a=n.size();o<a;++o)r.isValueHidden(o)||(e.assign(n.at(o)),s.satisfactionDegree()<=i(this,L)&&r.hide(o,t));return e.clear(),!r.isEmpty()},yi=function(t,e){for(const s of i(this,E)){if(!s.isEmpty())continue;const n=d(this,N,zi).call(this,e,s.index());for(const r of n)if(r.size()===2&&!d(this,N,Ei).call(this,t,s,r))return!1}return!0},Vs=function(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<i(this,E).length;++s){const n=i(this,E)[s];if(!n.isEmpty())continue;const o=n.domain().size()-n.solverObject.hiddenSize();o<e&&(e=o,t=s)}return t},Ls=function(t){let e=$.CONTINUE;const s=i(this,ne)?d(this,N,Vs).call(this):t,n=i(this,E)[s],r=n.domain(),o=n.solverObject;for(let a=0,c=r.size();a<c;++a){if(o.isValueHidden(a))continue;if(this.iterLimit&&this.iterLimit<A(this,It)._++||i(this,jt)<Date.now()){e=$.TERMINATE;break}n.assign(r.at(a));for(const g of i(this,E))g.solverObject.reveal(t);if(!d(this,N,yi).call(this,t,s))continue;const u=t+1;if(e=u===i(this,E).length-1?d(this,N,Vi).call(this,u):d(this,N,Ls).call(this,u),e===$.TERMINATE)break}if(e===$.CONTINUE)for(const a of i(this,E))a.solverObject.reveal(t);return n.clear(),e},Vi=function(t){let e=$.CONTINUE;const s=i(this,E)[i(this,ne)?d(this,N,Vs).call(this):t],n=s.domain(),r=s.solverObject;for(let o=0,a=n.size();o<a;++o){if(r.isValueHidden(o))continue;if(this.iterLimit&&this.iterLimit<A(this,It)._++||i(this,jt)<Date.now()){e=$.TERMINATE;break}s.assign(n.at(o));const c=this.pro.worstSatisfactionDegree();if(c>i(this,L)&&(f(this,L,c),i(this,Tt).setProblem(this.pro),e=$.TERMINATE,this.targetDeg!==null&&this.targetDeg<=i(this,L)))break}return s.clear(),e},v($,"CONTINUE",0),v($,"TERMINATE",1);let ys=$;var qt,Cs,Li,_t,Ft,Te,Ie,X,z,As,Ni,Ci,Ai,Xe,ki,Mi,Ti;const Yt=class Yt extends R{constructor(t){super(t);l(this,z);l(this,_t,0);l(this,Ft,0);l(this,Te,0);l(this,Ie,0);l(this,X,0);d(this,z,Ni).call(this)}name(){return"Flexible Local Changes"}exec(){f(this,Ie,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),f(this,Te,0),f(this,X,-1);const t=this.pro.worstSatisfactionDegree();this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const e=new Set,s=new Set,n=new Set;for(const w of this.pro.variables())(w.isEmpty()?n:s).add(w);const r=new Set,o=d(this,z,ki).call(this,s,r);let a,c=null;n.size===0?(a=o,c=x.fromVariables(s)):a=i(this,Ft);const u=d(this,z,As).call(this,s,r).union(n),g=s.difference(u);let m=d(this,z,Xe).call(this,e,g,u,i(this,_t),i(this,_t),a);return m<a&&c!==null&&c.apply(),m=this.pro.worstSatisfactionDegree(),m>t&&m>0&&(i(this,X)!==0||this.targetDeg===null)}};qt=new WeakSet,Cs=function(t,e){const s=new Set(t);return s.add(e),s},Li=function(t,e){const s=new Set(t);return s.delete(e),s},_t=new WeakMap,Ft=new WeakMap,Te=new WeakMap,Ie=new WeakMap,X=new WeakMap,z=new WeakSet,As=function(t,e){const s=new Map;for(const o of e)if(o.isDefined())for(const a of o)s.has(a)?s.set(a,(s.get(a)??0)+1):s.set(a,1);const n=[...t];n.sort((o,a)=>{let c=0,u=0;return s.has(o)&&(c=s.get(o)??0),s.has(a)&&(u=s.get(a)??0),c<u?1:c>u?-1:0});const r=new Set;for(const o of n){let a=!1;for(const c of e)if(c.isDefined()){a=!0;break}if(!a)break;o.clear(),r.add(o)}return r},Ni=function(){let t=1,e=0;for(const s of this.pro.variables())for(const n of s){const r=n.lowestConsistencyDegree(),o=n.highestConsistencyDegree();r<t&&(t=r),o>e&&(e=o)}f(this,Ft,t),f(this,_t,e)},Ci=function(t,e,s,n,r,o,a){var m;const c=d(this,z,As).call(this,e,o),u=d(m=Yt,qt,Cs).call(m,t,s),g=e.difference(c);return d(this,z,Xe).call(this,u,g,c,n,Math.min(r,n),a)},Ai=function(t,e,s,n,r,o){let a=i(this,Ft);if(s.domain().size()===0)return a;let c=x.fromVariables(e),u=s.domain().at(0);const g=x.fromVariables(e);for(let m=0;m<s.domain().size()&&a<r;++m){const w=s.domain().at(m);s.assign(w);const D=Math.min(n,d(this,z,Mi).call(this,t,s,a,o));if(D>Math.max(a,o)){const T=new Set,ht=Math.min(Math.min(D,r),d(this,z,Ti).call(this,t,e,s,D,r,T));if(ht>a&&(a=ht,u=w,c=x.fromVariables(e)),T.size){const J=d(this,z,Ci).call(this,t,e,s,D,r,T,Math.max(o,a));if(i(this,X)!==-1)return a;J>a&&(a=J,u=w,c=x.fromVariables(e)),g.apply()}}}return c.apply(),s.assign(u),a},Xe=function(t,e,s,n,r,o){var u,g;if(this.debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),this.targetDeg!==null&&this.targetDeg<=this.pro.worstSatisfactionDegree())return this.debugOutput("stop: current degree is above the target"),f(this,X,1),r;if(this.iterLimit&&this.iterLimit<A(this,Te)._++)return this.debugOutput("stop: number of iterations has reached the limit"),f(this,X,0),r;if(i(this,Ie)<Date.now())return this.debugOutput("stop: time limit has been reached"),f(this,X,0),r;if(s.size===0)return r;const a=s.values().next().value,c=d(this,z,Ai).call(this,t,e,a,n,r,o);return i(this,X)!==-1?r:c<o?i(this,Ft):(e=d(u=Yt,qt,Cs).call(u,e,a),s=d(g=Yt,qt,Li).call(g,s,a),d(this,z,Xe).call(this,t,e,s,n,c,o))},ki=function(t,e){const s=new Set;for(const r of t)for(const o of r)s.add(o);let n=1;for(const r of s){const o=r.satisfactionDegree();o!==B.UNDEFINED&&o<n&&(n=o)}for(const r of this.pro.constraints())r.lowestConsistencyDegree()<i(this,_t)&&e.add(r);return n},Mi=function(t,e,s,n){let r=1;const o=new Set;for(const a of t){const c=this.pro.constraintsBetween(a,e);for(const u of c)o.add(u)}for(const a of o){const c=a.satisfactionDegree();if(c!==B.UNDEFINED&&(c<r&&(r=c),r<=s||r<=n))return r}return r},Ti=function(t,e,s,n,r,o){let a=1;const c=new Set;for(const u of t){const g=this.pro.constraintsBetween(u,s);for(const m of g)c.add(m)}for(const u of e){const g=this.pro.constraintsBetween(u,s);for(const m of g)c.add(m)}for(const u of c){const g=u.satisfactionDegree();g!==B.UNDEFINED&&g<a&&(a=g)}for(const u of c){const g=u.satisfactionDegree();g!==B.UNDEFINED&&(g<n||g<r)&&o.add(u)}return a},l(Yt,qt);let Ns=Yt;var rs,Ii,Ut,$t,je,Re,tt,y,Ms,ji,Ri,_i,Ts,Fi,Ui,$i;const os=class os extends R{constructor(t){super(t);l(this,y);l(this,Ut,0);l(this,$t,0);l(this,je,0);l(this,Re,0);l(this,tt,0);d(this,y,ji).call(this)}name(){return"Flexible Local Changes Ex"}exec(){f(this,Re,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),f(this,je,0),f(this,tt,-1);const t=this.pro.worstSatisfactionDegree();this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const e=new Set,s=new Set,n=new Set;for(const w of this.pro.variables())(w.isEmpty()?n:s).add(w);const r=new Set,o=d(this,y,Fi).call(this,s,r);let a,c=null;n.size===0?(a=o,c=x.fromVariables(s)):a=i(this,$t);const u=d(this,y,Ms).call(this,s,r).union(n),g=s.difference(u);let m=d(this,y,Ts).call(this,e,g,u,i(this,Ut),i(this,Ut),a);return m<a&&c!==null&&c.apply(),m=this.pro.worstSatisfactionDegree(),m>t&&m>0&&(i(this,tt)!==0||this.targetDeg===null)}};rs=new WeakSet,Ii=function(t,e){const s=new Set(t);return s.add(e),s},Ut=new WeakMap,$t=new WeakMap,je=new WeakMap,Re=new WeakMap,tt=new WeakMap,y=new WeakSet,Ms=function(t,e){const s=new Map;for(const o of e)if(o.isDefined())for(const a of o)s.has(a)?s.set(a,(s.get(a)??0)+1):s.set(a,1);const n=[...t];n.sort((o,a)=>{let c=0,u=0;return s.has(o)&&(c=s.get(o)??0),s.has(a)&&(u=s.get(a)??0),c<u?1:c>u?-1:0});const r=new Set;for(const o of n){let a=!1;for(const c of e)if(c.isDefined()){a=!0;break}if(!a)break;o.clear(),r.add(o)}return r},ji=function(){let t=1,e=0;for(const s of this.pro.variables())for(const n of s){const r=n.lowestConsistencyDegree(),o=n.highestConsistencyDegree();r<t&&(t=r),o>e&&(e=o)}f(this,$t,t),f(this,Ut,e)},Ri=function(t,e,s,n,r,o,a){var m;const c=d(this,y,Ms).call(this,e,o),u=d(m=os,rs,Ii).call(m,t,s),g=e.difference(c);return d(this,y,Ts).call(this,u,g,c,n,Math.min(r,n),a)},_i=function(t,e,s,n,r,o){let a=i(this,$t);if(s.domain().size()===0)return a;let c=x.fromVariables(e),u=s.domain().at(0);const g=x.fromVariables(e);for(let m=0;m<s.domain().size()&&a<r;++m){const w=s.domain().at(m);s.assign(w);const D=Math.min(n,d(this,y,Ui).call(this,t,s,a,o));if(D>Math.max(a,o)){const T=new Set,ht=Math.min(Math.min(D,r),d(this,y,$i).call(this,t,e,s,D,r,T));if(ht>a&&(a=ht,u=w,c=x.fromVariables(e)),T.size){const J=d(this,y,Ri).call(this,t,e,s,D,r,T,Math.max(o,a));if(i(this,tt)!==-1)return a;J>a&&(a=J,u=w,c=x.fromVariables(e)),g.apply()}}}return c.apply(),s.assign(u),a},Ts=function(t,e,s,n,r,o){for(e=new Set(e),s=new Set(s);;){if(this.debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),this.targetDeg!==null&&this.targetDeg<=this.pro.worstSatisfactionDegree())return this.debugOutput("stop: current degree is above the target"),f(this,tt,1),r;if(this.iterLimit&&this.iterLimit<A(this,je)._++)return this.debugOutput("stop: number of iterations has reached the limit"),f(this,tt,0),r;if(i(this,Re)<Date.now())return this.debugOutput("stop: time limit has been reached"),f(this,tt,0),r;if(s.size===0)return r;const a=s.values().next().value,c=d(this,y,_i).call(this,t,e,a,n,r,o);if(i(this,tt)!==-1)return r;if(c<o)return i(this,$t);e.add(a),s.delete(a),r=c}},Fi=function(t,e){const s=new Set;for(const r of t)for(const o of r)s.add(o);let n=1;for(const r of s){const o=r.satisfactionDegree();o!==B.UNDEFINED&&o<n&&(n=o)}for(const r of this.pro.constraints())r.lowestConsistencyDegree()<i(this,Ut)&&e.add(r);return n},Ui=function(t,e,s,n){let r=1;const o=new Set;for(const a of t){const c=this.pro.constraintsBetween(a,e);for(const u of c)o.add(u)}for(const a of o){const c=a.satisfactionDegree();if(c!==B.UNDEFINED&&(c<r&&(r=c),r<=s||r<=n))return r}return r},$i=function(t,e,s,n,r,o){let a=1;const c=new Set;for(const u of t){const g=this.pro.constraintsBetween(u,s);for(const m of g)c.add(m)}for(const u of e){const g=this.pro.constraintsBetween(u,s);for(const m of g)c.add(m)}for(const u of c){const g=u.satisfactionDegree();g!==B.UNDEFINED&&g<a&&(a=g)}for(const u of c){const g=u.satisfactionDegree();g!==B.UNDEFINED&&(g<n||g<r)&&o.add(u)}return a},l(os,rs);let ks=os;var _e,Dt,re,fe,Pi,Hi;class hn extends R{constructor(t){super(t);l(this,fe);l(this,_e,!0);l(this,Dt);l(this,re,0);f(this,Dt,new Array(this.pro.constraintSize())),i(this,Dt).fill(1)}name(){return"Fuzzy Breakout"}setRandomness(t){f(this,_e,t)}exec(){const t=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let e=0;for(const o of this.pro.variables())o.isEmpty()&&o.assign(o.domain().at(0));const s=this.pro.worstSatisfactionDegree(),n=new x,r=new x;for(;;){const[o,a]=this.pro.constraintsWithWorstSatisfactionDegree();if(this.debugOutput(`worst satisfaction degree: ${a}`),this.iterLimit&&this.iterLimit<e++){this.debugOutput("stop: number of iterations has reached the limit");break}if(t<Date.now()){this.debugOutput("stop: time limit has been reached");break}if(i(this,re)<a&&(r.setProblem(this.pro),f(this,re,a),this.foundSolution(r,i(this,re))))return!0;if(this.targetDeg&&this.targetDeg<=a)return this.debugOutput("stop: current degree is above the target"),!0;if(d(this,fe,Pi).call(this,d(this,fe,Hi).call(this,o),n),0<n.size()){const c=i(this,_e)?n.random():n.at(0);c.apply(),n.clear(),this.debugOutput("	"+c)}else{for(const c of o)i(this,Dt)[c.index()]+=1;this.debugOutput("breakout")}}return this.targetDeg===null&&s<this.pro.worstSatisfactionDegree()}}_e=new WeakMap,Dt=new WeakMap,re=new WeakMap,fe=new WeakSet,Pi=function(t,e){let s=0;for(const n of t){const r=n.value();let o=0;for(const a of n)o+=(1-a.satisfactionDegree())*i(this,Dt)[a.index()];t:for(const a of n.domain()){if(r===a)continue;n.assign(a);let c=o;for(const u of n)if(c-=(1-u.satisfactionDegree())*i(this,Dt)[u.index()],c<s)continue t;c>s?(s=c,e.clear(),e.addVariable(n,a)):s!==0&&e.addVariable(n,a)}n.assign(r)}},Hi=function(t){const e=new Set;for(const s of t)for(const n of s)e.add(n);return Array.from(e)};var q,Fe,Ue,de,Bi,Wi;const $s=class $s extends R{constructor(t,e=1){super(t);l(this,de);l(this,q,[]);l(this,Fe,[]);l(this,Ue);f(this,Ue,e)}static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}name(){return"Fuzzy GENET"}exec(){if(!d(this,de,Bi).call(this,i(this,Ue)))throw new Error;const t=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let e=0;const s=new x,n=[];for(let a=0;a<i(this,q).length;++a)n.push(a);let r=this.pro.worstSatisfactionDegree(),o=!1;for(;;){if(this.iterLimit&&this.iterLimit<e++){this.debugOutput("stop: number of iterations has reached the limit");break}if(t<Date.now()){this.debugOutput("stop: time limit has been reached");break}let a=!1;for(const c of d(this,de,Wi).call(this,n))i(this,q)[c].setActivityMaximumInput()&&(a=!0);if(a){for(const u of i(this,q))u.applyToVariable();const c=this.pro.worstSatisfactionDegree();if(r<c){if(r=c,this.debugOutput(`worst satisfaction degree: ${c}`),s.setProblem(this.pro),this.foundSolution(s,c)){o=!0;break}if(this.targetDeg===null)o=!0;else if(this.targetDeg<=r){this.debugOutput("stop: current degree is above the target"),o=!0;break}}}else{for(const c of i(this,Fe))c.refreshWeight();continue}}return s.apply(),o}};q=new WeakMap,Fe=new WeakMap,Ue=new WeakMap,de=new WeakSet,Bi=function(t){this.debugOutput("network creation start");const e=[];for(const s of this.pro.variables()){if(s.domain().size()===0)return!1;i(this,q).push(new js(s))}for(const s of this.pro.constraints())if(s.size()===1){const n=s.at(0),r=i(this,q)[n.index()];for(let o=0;o<r.size();++o){const a=n.value();n.assign(r.get(o)._value),s.satisfactionDegree()<=t&&e.push(new Bs(s,r.get(o))),n.assign(a)}}else{const n=s.at(0),r=s.at(1),o=i(this,q)[n.index()],a=i(this,q)[r.index()];for(let c=0;c<o.size();++c){const u=n.value();n.assign(o.get(c)._value);for(let g=0;g<a.size();++g){const m=r.value();r.assign(a.get(g)._value),s.satisfactionDegree()<=t&&e.push(new Bs(s,o.get(c),a.get(g))),r.assign(m)}n.assign(u)}}for(const s of i(this,q))for(const n of s._neurons)n.lockConnections();return f(this,Fe,e),this.debugOutput("network creation complete"),!0},Wi=function(t){for(let e=t.length;e>1;--e){const s=$s.nextInt(e),n=t[e-1];t[e-1]=t[s],t[s]=n}return t};let Is=$s;var $e,oe,ot,Pe,Rs;const as=class as{constructor(h){l(this,Pe);l(this,$e);l(this,oe,0);l(this,ot,[]);v(this,"_neurons",[]);f(this,$e,h);for(const t of h.domain())this._neurons.push(new cn(t));d(this,Pe,Rs).call(this,as.nextInt(this._neurons.length))}static nextInt(h){return Math.floor(Math.random()*Math.floor(h))}applyToVariable(){i(this,$e).assign(this._neurons[i(this,oe)]._value)}get(h){return this._neurons[h]}neurons(){return this._neurons}setActivityMaximumInput(){i(this,ot).length=0;let h=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const s=this._neurons[e].getInput();h<=s&&(h<s&&(h=s,i(this,ot).length=0,t=!1),i(this,ot).push(e),i(this,oe)===e&&(t=!0))}return t||i(this,ot).length===0?!1:(d(this,Pe,Rs).call(this,i(this,ot)[as.nextInt(i(this,ot).length)]),!0)}size(){return this._neurons.length}};$e=new WeakMap,oe=new WeakMap,ot=new WeakMap,Pe=new WeakSet,Rs=function(h){for(const t of this._neurons)t._isActive=!1;this._neurons[h]._isActive=!0,f(this,oe,h)};let js=as;var Pt,et,Y;class Bs{constructor(h,t,e=null){l(this,Pt);l(this,et);l(this,Y);v(this,"_weight");this._weight=h.satisfactionDegree()-1,f(this,Pt,h),f(this,et,t),i(this,et).addConnection(this),f(this,Y,e),i(this,Y)!==null&&i(this,Y).addConnection(this)}getNeuron(h){return h===i(this,et)?i(this,Y):h===i(this,Y)?i(this,et):null}refreshWeight(){!i(this,et)._isActive||i(this,Y)!==null&&!i(this,Y)._isActive||(i(this,Pt).size()===1?this._weight+=i(this,Pt).fuzzyRelation().satisfactionDegree(i(this,et)._value)-1:this._weight+=i(this,Pt).fuzzyRelation().satisfactionDegree(i(this,et)._value,i(this,Y)._value)-1)}}Pt=new WeakMap,et=new WeakMap,Y=new WeakMap;var ae,He;class cn{constructor(h){l(this,ae,[]);l(this,He,[]);v(this,"_value");v(this,"_isActive",!1);this._value=h}addConnection(h){i(this,ae).push(h)}lockConnections(){f(this,He,[...i(this,ae)]),f(this,ae,null)}getInput(){let h=0;for(const t of i(this,He)){const e=t.getNeuron(this);h+=t._weight*(e===null||e._isActive?1:0)}return h}}ae=new WeakMap,He=new WeakMap;var Ht,H,he,Bt,at,Be,We,Ge,I,Gi,ts,qi,Yi,Ki;const hs=class hs extends R{constructor(t){super(t);l(this,I);l(this,Ht,new Set);l(this,H,new Set);l(this,he,[]);l(this,Bt,[]);l(this,at,new Set);l(this,Be,0);l(this,We,0);l(this,Ge,!0);for(const e of this.pro.constraints())i(this,he).push(new un(e)),i(this,Bt).push(null)}name(){return"SRS 3"}exec(){if(f(this,We,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),f(this,Be,0),this.targetDeg&&this.targetDeg<=this.pro.worstSatisfactionDegree())return!0;const t=new x;let e=!1;for(;!(!d(this,I,Ki).call(this)||i(this,at).size);){const n=this.pro.worstSatisfactionDegree();if(n!==-1){if(this.debugOutput(`	found a solution: ${n}	${this.targetDeg}`),t.setProblem(this.pro),this.foundSolution(t,n)){e=!0;break}if(this.targetDeg===null)e=!0;else if(this.targetDeg<=n){this.debugOutput("stop: current degree is above the target"),e=!0;break}}}return e}setRandomness(t){f(this,Ge,t)}};Ht=new WeakMap,H=new WeakMap,he=new WeakMap,Bt=new WeakMap,at=new WeakMap,Be=new WeakMap,We=new WeakMap,Ge=new WeakMap,I=new WeakSet,Gi=function(t){const e=t.index();return i(this,Bt)[e]===null&&(i(this,Bt)[e]=t.neighbors()),i(this,Bt)[e]},ts=function(t){this.debugOutput("repair");const e=new x,s=t.satisfactionDegree(),n=this.pro.worstSatisfactionDegree();let r=t.satisfactionDegree();for(const o of t){const a=o.value();t:for(const c of o.domain()){if(a===c)continue;o.assign(c);const u=t.satisfactionDegree();if(!(s>u||r-u>hs.REPAIR_THRESHOLD)){for(const g of o){if(g===t)continue;const m=g.satisfactionDegree();if(m!==B.UNDEFINED&&m<n)continue t}u>r&&(r=u,e.clear()),e.addVariable(o,c)}}o.assign(a)}if(e.size()>0){const o=i(this,Ge)?e.random():e.at(0);return o.apply(),this.debugOutput("	"+o),!0}return!1},qi=function(t){this.debugOutput("shrink");let e=!1;for(;;){if(t=t.parent(),i(this,at).delete(t)){e=!0;break}if(!d(this,I,ts).call(this,t.parent().getObject()))break}const s=[];t.getDescendants(s);for(const n of s)n.clear(),i(this,H).delete(n),i(this,Ht).delete(n);e||i(this,H).add(t)},Yi=function(t){this.debugOutput("spread"),i(this,Ht).add(t);for(const e of d(this,I,Gi).call(this,t.getObject())){const s=i(this,he)[e.index()];!i(this,Ht).has(s)&&!i(this,H).has(s)&&(t.add(s),i(this,H).add(s))}},Ki=function(){this.debugOutput("srs");const[t]=this.pro.constraintsWithWorstSatisfactionDegree();for(const e of t){const s=i(this,he)[e.index()];s.setParent(null),i(this,at).add(s)}i(this,Ht).clear(),i(this,H).clear();for(const e of i(this,at))i(this,H).add(e);for(;i(this,at).size&&i(this,H).size;){if(this.iterLimit&&this.iterLimit<A(this,Be)._++)return this.debugOutput("stop: number of iterations has reached the limit"),!1;if(i(this,We)<Date.now())return this.debugOutput("stop: time limit has been reached"),!1;const e=i(this,H).values().next().value;if(i(this,H).delete(e),d(this,I,ts).call(this,e.getObject())){if(i(this,at).delete(e))continue;if(d(this,I,ts).call(this,e.parent().getObject())){d(this,I,qi).call(this,e);continue}}d(this,I,Yi).call(this,e)}return!0},v(hs,"REPAIR_THRESHOLD",0);let es=hs;var Wt,xt,qe;class un{constructor(h){l(this,Wt,[]);l(this,xt);l(this,qe);f(this,xt,null),f(this,qe,h)}add(h){f(h,xt,this),i(this,Wt).push(h)}clear(){for(const h of i(this,Wt))f(h,xt,null);i(this,Wt).length=0}getDescendants(h){h.push(this);for(const t of i(this,Wt))t.getDescendants(h)}getObject(){return i(this,qe)}parent(){return i(this,xt)}setParent(h){f(this,xt,h)}}Wt=new WeakMap,xt=new WeakMap,qe=new WeakMap;class ln{static apply(h,t){console.log("start post-stabilization");let e,s=0;do{console.log("post-stabilization: count "+s++),e=!1;let n=h.worstSatisfactionDegree();const r=h.variables();for(let o=0;o<r.length;++o){const a=r[o],c=a.value(),u=t.at(o);c!==u.value()&&(u.apply(),h.worstSatisfactionDegree()>=n?e=!0:a.assign(c))}}while(e);return console.log("finish post-stabilization"),!0}}class fn extends es{constructor(h){super(h)}name(){return"SRS 3 + PF"}exec(){let h=0,t=0;this.debug&&(h=this.pro.worstSatisfactionDegree(),t=this.pro.emptyVariableSize());const e=new x;e.setProblem(this.pro);const s=super.exec();return s&&ln.apply(this.pro,e),this.debugOutput(`result: ${s?"success":"failure"}`),this.debugOutput(`satisfaction degree: ${h} -> ${this.pro.worstSatisfactionDegree()}`),this.debugOutput(`unassigned size: ${t} -> ${this.pro.emptyVariableSize()}`),s}}class _s{static crispSolverNames(){return["Forward Checking","Max Forward Checking","Local Changes","Local Changes Ex","Breakout","GENET","Crisp SRS 3"]}static fuzzySolverNames(){return["Fuzzy Forward Checking","Fuzzy Forward Checking Bc","Flexible Local Changes","Flexible Local Changes Ex","Fuzzy Breakout","Fuzzy GENET","SRS 3","SRS 3 PF"]}static async createSolver(h,t){const e=await _s.createCrispSolver(h,t);if(e)return e;const s=await _s.createFuzzySolver(h,t);return s||null}static async createCrispSolver(h,t){switch(h.replaceAll(" ","")){case"ForwardChecking":case"forward-checking":return new tn(t);case"MaxForwardChecking":case"max-forward-checking":return new en(t);case"LocalChanges":case"local-changes":return new fs(t);case"LocalChangesEx":case"local-changes-ex":return new ms(t);case"Breakout":case"breakout":return new sn(t);case"GENET":case"genet":return new Ds(t);case"CrispSRS3":case"crisp-srs3":return new on(t)}return null}static async createFuzzySolver(h,t){switch(h.replaceAll(" ","")){case"FuzzyForwardChecking":case"fuzzy-forward-checking":return new Ss(t);case"FuzzyForwardCheckingBc":case"fuzzy-forward-checking-bc":return new ys(t);case"FlexibleLocalChanges":case"flexible-local-changes":return new Ns(t);case"FlexibleLocalChangesEx":case"flexible-local-changes-ex":return new ks(t);case"FuzzyBreakout":case"fuzzy-breakout":return new hn(t);case"FuzzyGENET":case"fuzzy-genet":return new Is(t);case"SRS3":case"srs3":return new es(t);case"SRS3PF":case"SRS3_PF":case"srs3-pf":return new fn(t)}return null}}function wn(p){return new Promise(h=>{const t=setInterval(()=>{p()&&(clearInterval(t),h(null))},100)})}function Dn(p="output"){const h=document.getElementById(p);return t=>{h.value+=`${t}
`,setTimeout(()=>h.scrollTo(0,h.scrollHeight),100)}}export{_s as S,Dn as c,wn as w};
