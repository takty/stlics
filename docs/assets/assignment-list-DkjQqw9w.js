var N=Object.defineProperty;var L=s=>{throw TypeError(s)};var V=(s,t,i)=>t in s?N(s,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):s[t]=i;var D=(s,t,i)=>V(s,typeof t!="symbol"?t+"":t,i),T=(s,t,i)=>t.has(s)||L("Cannot "+i);var e=(s,t,i)=>(T(s,t,"read from private field"),i?i.call(s):t.get(s)),l=(s,t,i)=>t.has(s)?L("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(s):t.set(s,i),n=(s,t,i,o)=>(T(s,t,"write to private field"),o?o.call(s,i):t.set(s,i),i);var A=(s,t,i,o)=>({set _(y){n(s,t,y,i)},get _(){return e(s,t,o)}});var b,p,c,g,m,a,f,v,d,S,E;class _{constructor(){l(this,b,!0);l(this,p,t=>console.log(t));l(this,c,()=>!1);l(this,g,Number.MAX_SAFE_INTEGER);l(this,m,null);l(this,a,.8);l(this,f,null);l(this,v,0);l(this,d,0);l(this,S,-1);l(this,E,0)}initialize(){n(this,v,e(this,m)===null?Number.MAX_VALUE:Date.now()+e(this,m)),n(this,d,0)}check(t=null){if(t!==null&&e(this,a)!==null&&e(this,a)<=t)return this.outputDebugString("Stop: Current evaluation value is above the target"),!0;if(e(this,g)<A(this,d)._++)return this.outputDebugString("Stop: Number of iterations has reached the limit"),!1;if(e(this,v)<Date.now())return this.outputDebugString("Stop: Time limit has been reached"),!1;if(t!==null&&e(this,f)!==null)if(t!==-1&&e(this,S)===t){if(e(this,f)<A(this,E)._++)return this.outputDebugString("Stop: Evaluation value has not changed for a certain number of times"),!1}else n(this,S,t),n(this,E,0);return null}solutionFound(t,i){return e(this,c).call(this,t,i)}outputDebugString(t){e(this,b)&&e(this,p).call(this,t)}isDebugMode(){return e(this,b)}isTargetAssigned(){return e(this,a)!==null}getTarget(){return e(this,a)}setIterationLimit(t=null){n(this,g,t===null?Number.MAX_SAFE_INTEGER:t)}setTimeLimit(t=null){n(this,m,t)}setTarget(t=null){n(this,a,t)}setSameEvaluationLimit(t=null){n(this,f,t)}setListener(t){n(this,c,t)}setDebugMode(t){n(this,b,t)}setDebugOutput(t){n(this,p,t)}}b=new WeakMap,p=new WeakMap,c=new WeakMap,g=new WeakMap,m=new WeakMap,a=new WeakMap,f=new WeakMap,v=new WeakMap,d=new WeakMap,S=new WeakMap,E=new WeakMap;class C{constructor(){D(this,"pro");D(this,"monitor")}name(){return""}solve(t,i=new _){this.pro=t,this.monitor=i,this.preprocess();const o=this.exec();return this.postprocess(),o}preprocess(){}exec(){return!1}postprocess(){}}var u,h;class w{constructor(t){l(this,u);l(this,h);if("assignment"in t)n(this,u,t.assignment.variable()),n(this,h,t.assignment.value());else if("variable"in t)n(this,u,t.variable),n(this,h,t.value??t.variable.value());else throw new RangeError}apply(){e(this,u).assign(e(this,h))}toString(){return`v${e(this,u).index()} <- ${e(this,h)}`}value(){return e(this,h)}variable(){return e(this,u)}}u=new WeakMap,h=new WeakMap;var r;const M=class M{constructor(){l(this,r,[])}static fromVariables(t){const i=new M;return i.setVariables(t),i}setProblem(t){e(this,r).length=0;for(const i of t.variables())e(this,r).push(new w({variable:i,value:i.value()}))}setAssignmentList(t){e(this,r).length=0;for(const i of t)e(this,r).push(new w({variable:i.variable(),value:i.value()}))}setVariables(t){e(this,r).length=0;for(const i of t)e(this,r).push(new w({variable:i,value:i.value()}))}addVariable(t,i=null){e(this,r).push(new w({variable:t,value:i}))}apply(){for(const t of e(this,r))t.apply()}clear(){e(this,r).length=0}isEmpty(){return e(this,r).length===0}size(){return e(this,r).length}differenceSize(){let t=0;for(const i of e(this,r))i.variable().value()!==i.value()&&++t;return t}at(t){return e(this,r)[t]}[Symbol.iterator](){return e(this,r)[Symbol.iterator]()}random(){return e(this,r)[Math.floor(Math.random()*e(this,r).length)]}};r=new WeakMap;let x=M;export{x as A,C as S};
