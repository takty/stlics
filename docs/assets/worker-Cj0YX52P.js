var wt=Object.defineProperty;var ft=h=>{throw TypeError(h)};var Dt=(h,s,t)=>s in h?wt(h,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[s]=t;var _=(h,s,t)=>Dt(h,typeof s!="symbol"?s+"":s,t),ht=(h,s,t)=>s.has(h)||ft("Cannot "+t);var e=(h,s,t)=>(ht(h,s,"read from private field"),t?t.call(h):s.get(h)),c=(h,s,t)=>s.has(h)?ft("Cannot add the same private member more than once"):s instanceof WeakSet?s.add(h):s.set(h,t),a=(h,s,t,i)=>(ht(h,s,"write to private field"),i?i.call(h,t):s.set(h,t),t),mt=(h,s,t)=>(ht(h,s,"access private method"),t);var at=(h,s,t,i)=>({set _(r){a(h,s,r,t)},get _(){return e(h,s,i)}});var j,H;class Et{constructor(){c(this,j,-1);c(this,H,"");_(this,"userObject",null)}setIndex(s){a(this,j,s)}setName(s){a(this,H,s)}index(){return e(this,j)}name(){return e(this,H)}}j=new WeakMap,H=new WeakMap;var V,q,R,W,x;const O=class O extends Et{constructor(t,i){super();c(this,q);c(this,R);c(this,W,e(O,V));c(this,x,[]);a(this,q,t),a(this,R,i)}toString(){const t=this.name(),i=t?`(${t})`:"",r=this.isEmpty()?"<empty>":""+this.value();return`x${this.index()}${i} = ${r}`}size(){return e(this,x).length}at(t){return e(this,x).at(t)}has(t){return e(this,x).includes(t)}indexOf(t){return e(this,x).indexOf(t)}neighbors(){const t=[];for(const i of e(this,x))for(const r of i)r!==this&&t.push(r);return t}[Symbol.iterator](){return e(this,x)[Symbol.iterator]()}owner(){return e(this,q)}connect(t){if(e(this,x).includes(t))throw new RangeError;e(this,x).push(t)}disconnect(t){if(!e(this,x).includes(t))throw new RangeError;a(this,x,e(this,x).filter(i=>i!==t))}domain(t){if(t===void 0)return e(this,R);a(this,R,t),this.clear()}assign(t){a(this,W,t)}clear(){this.assign(e(O,V))}value(){return e(this,W)}isEmpty(){return this.value()===e(O,V)}};V=new WeakMap,q=new WeakMap,R=new WeakMap,W=new WeakMap,x=new WeakMap,c(O,V,Number.MIN_VALUE);let ct=O;class pt{random(){return this.at(Math.floor(Math.random()*this.size()))}}var F,M;class St extends pt{constructor(t,i){super();c(this,F);c(this,M);a(this,F,t|0),a(this,M,i|0)}contains(t){return e(this,F)<=t&&t<=e(this,M)}indexOf(t){return e(this,F)<=t&&t<=e(this,M)?t-e(this,F):-1}size(){return e(this,M)-e(this,F)+1}at(t){return e(this,F)+t}[Symbol.iterator](){let t=e(this,F);const i=e(this,M);return{next(){return t<=i?{value:t++,done:!1}:{value:null,done:!0}}}}}F=new WeakMap,M=new WeakMap;var C;class xt extends pt{constructor(t){super();c(this,C);a(this,C,[...t])}contains(t){return e(this,C).includes(t)}indexOf(t){return e(this,C).indexOf(t)}size(){return e(this,C).length}at(t){return e(this,C)[t]}[Symbol.iterator](){return e(this,C)[Symbol.iterator]()}}C=new WeakMap;class zt{}class yt extends zt{isSatisfied(...s){const t=this.degree(...s);return 0<t&&t<1?0:t}}const rt=class rt extends Et{constructor(t){super();_(this,"rel");this.rel=t}relation(){return this.rel}isFuzzy(){return this.rel instanceof yt}toString(){const t=this.name(),i=t?`(${t})`:"",r=this.degree(),o=r===rt.UNDEFINED?"UNDEFINED":""+r;return`c${this.index()}${i} = ${o}`}};_(rt,"UNDEFINED",-1);let y=rt;var D;class Nt extends y{constructor(t,i){super(t);c(this,D,[]);a(this,D,[i])}size(){return 1}at(t){return e(this,D).at(t)}has(t){return t===e(this,D)[0]}indexOf(t){return t===e(this,D)[0]?0:-1}neighbors(){const t=[];for(const i of e(this,D)[0])i!==this&&t.push(i);return t}[Symbol.iterator](){return e(this,D)[Symbol.iterator]()}emptyVariableSize(){return e(this,D)[0].isEmpty()?1:0}isDefined(){return!e(this,D)[0].isEmpty()}isSatisfied(){return e(this,D)[0].isEmpty()?y.UNDEFINED:this.rel.isSatisfied(e(this,D)[0].value())?1:0}degree(){return e(this,D)[0].isEmpty()?y.UNDEFINED:this.rel.degree(e(this,D)[0].value())}highestConsistencyDegree(){const t=this.degree();if(t!==y.UNDEFINED)return t;let i=0;const r=o=>{const u=this.rel.degree(o);return u>i&&(i=u),i===1};for(const o of e(this,D)[0].domain())if(r(o))break;return i}lowestConsistencyDegree(){const t=this.degree();if(t!==y.UNDEFINED)return t;let i=1;const r=o=>{const u=this.rel.degree(o);return u<i&&(i=u),i===0};for(const o of e(this,D)[0].domain())if(r(o))break;return i}}D=new WeakMap;var l;class Ft extends y{constructor(t,i,r){super(t);c(this,l,[]);a(this,l,[i,r])}size(){return 2}at(t){return e(this,l).at(t)}has(t){return e(this,l)[0]===t||e(this,l)[1]===t}indexOf(t){return t===e(this,l)[0]?0:t===e(this,l)[1]?1:-1}neighbors(){const t=[];for(const i of e(this,l))for(const r of i)r!==this&&t.push(r);return t}[Symbol.iterator](){return e(this,l)[Symbol.iterator]()}emptyVariableSize(){let t=0;return e(this,l)[0].isEmpty()&&++t,e(this,l)[1].isEmpty()&&++t,t}isDefined(){return!e(this,l)[0].isEmpty()&&!e(this,l)[1].isEmpty()}isSatisfied(){return e(this,l)[0].isEmpty()||e(this,l)[1].isEmpty()?y.UNDEFINED:this.rel.isSatisfied(e(this,l)[0].value(),e(this,l)[1].value())?1:0}degree(){return e(this,l)[0].isEmpty()||e(this,l)[1].isEmpty()?y.UNDEFINED:this.rel.degree(e(this,l)[0].value(),e(this,l)[1].value())}highestConsistencyDegree(){const t=this.degree();if(t!==y.UNDEFINED)return t;let i=0;const r=(g,b)=>{const f=this.rel.degree(g,b);return f>i&&(i=f),i===1},o=e(this,l)[0].value(),u=e(this,l)[1].value(),m=e(this,l)[0].domain(),d=e(this,l)[1].domain();if(e(this,l)[0].isEmpty()&&!e(this,l)[1].isEmpty()){for(const g of m)if(r(g,u))break}else if(!e(this,l)[0].isEmpty()&&e(this,l)[1].isEmpty()){for(const g of d)if(r(o,g))break}else for(const g of m)for(const b of d)if(r(g,b))break;return i}lowestConsistencyDegree(){const t=this.degree();if(t!==y.UNDEFINED)return t;let i=1;const r=(g,b)=>{const f=this.rel.degree(g,b);return f<i&&(i=f),i===0},o=e(this,l)[0].value(),u=e(this,l)[1].value(),m=e(this,l)[0].domain(),d=e(this,l)[1].domain();if(e(this,l)[0].isEmpty()&&!e(this,l)[1].isEmpty()){for(const g of m)if(r(g,u))break}else if(!e(this,l)[0].isEmpty()&&e(this,l)[1].isEmpty()){for(const g of d)if(r(o,g))break}else for(const g of m)for(const b of d)if(r(g,b))break;return i}}l=new WeakMap;var n;class Ct extends y{constructor(t,i,r,o){super(t);c(this,n,[]);a(this,n,[i,r,o])}size(){return 3}at(t){return e(this,n).at(t)}has(t){return e(this,n)[0]===t||e(this,n)[1]===t||e(this,n)[2]===t}indexOf(t){return t===e(this,n)[0]?0:t===e(this,n)[1]?1:t===e(this,n)[2]?2:-1}neighbors(){const t=[];for(const i of e(this,n))for(const r of i)r!==this&&t.push(r);return t}[Symbol.iterator](){return e(this,n)[Symbol.iterator]()}emptyVariableSize(){let t=0;return e(this,n)[0].isEmpty()&&++t,e(this,n)[1].isEmpty()&&++t,e(this,n)[2].isEmpty()&&++t,t}isDefined(){return!e(this,n)[0].isEmpty()&&!e(this,n)[1].isEmpty()&&!e(this,n)[2].isEmpty()}isSatisfied(){return e(this,n)[0].isEmpty()||e(this,n)[1].isEmpty()||e(this,n)[2].isEmpty()?y.UNDEFINED:this.rel.isSatisfied(e(this,n)[0].value(),e(this,n)[1].value(),e(this,n)[2].value())?1:0}degree(){return e(this,n)[0].isEmpty()||e(this,n)[1].isEmpty()||e(this,n)[2].isEmpty()?y.UNDEFINED:this.rel.degree(e(this,n)[0].value(),e(this,n)[1].value(),e(this,n)[2].value())}highestConsistencyDegree(){const t=this.degree();if(t!==y.UNDEFINED)return t;let i=0;const r=(f,w,L)=>{const P=this.rel.degree(f,w,L);return P>i&&(i=P),i===1},o=e(this,n)[0].value(),u=e(this,n)[1].value(),m=e(this,n)[2].value(),d=e(this,n)[0].domain(),g=e(this,n)[1].domain(),b=e(this,n)[2].domain();if(e(this,n)[0].isEmpty()&&!e(this,n)[1].isEmpty()&&!e(this,n)[2].isEmpty()){for(const f of d)if(r(f,u,m))break}else if(!e(this,n)[0].isEmpty()&&e(this,n)[1].isEmpty()&&!e(this,n)[2].isEmpty()){for(const f of g)if(r(o,f,m))break}else if(!e(this,n)[0].isEmpty()&&!e(this,n)[1].isEmpty()&&e(this,n)[2].isEmpty()){for(const f of b)if(r(o,u,f))break}else if(e(this,n)[0].isEmpty()&&e(this,n)[1].isEmpty()&&!e(this,n)[2].isEmpty()){for(const f of d)for(const w of g)if(r(f,w,m))break}else if(e(this,n)[0].isEmpty()&&!e(this,n)[1].isEmpty()&&e(this,n)[2].isEmpty()){for(const f of d)for(const w of b)if(r(f,u,w))break}else if(!e(this,n)[0].isEmpty()&&e(this,n)[1].isEmpty()&&e(this,n)[2].isEmpty()){for(const f of g)for(const w of b)if(r(o,f,w))break}else for(const f of d)for(const w of g)for(const L of b)if(r(f,w,L))break;return i}lowestConsistencyDegree(){const t=this.degree();if(t!==y.UNDEFINED)return t;let i=1;const r=(f,w,L)=>{const P=this.rel.degree(f,w,L);return P<i&&(i=P),i===0},o=e(this,n)[0].value(),u=e(this,n)[1].value(),m=e(this,n)[2].value(),d=e(this,n)[0].domain(),g=e(this,n)[1].domain(),b=e(this,n)[2].domain();if(e(this,n)[0].isEmpty()&&!e(this,n)[1].isEmpty()&&!e(this,n)[2].isEmpty()){for(const f of d)if(r(f,u,m))break}else if(!e(this,n)[0].isEmpty()&&e(this,n)[1].isEmpty()&&!e(this,n)[2].isEmpty()){for(const f of g)if(r(o,f,m))break}else if(!e(this,n)[0].isEmpty()&&!e(this,n)[1].isEmpty()&&e(this,n)[2].isEmpty()){for(const f of b)if(r(o,u,f))break}else if(e(this,n)[0].isEmpty()&&e(this,n)[1].isEmpty()&&!e(this,n)[2].isEmpty()){for(const f of d)for(const w of g)if(r(f,w,m))break}else if(e(this,n)[0].isEmpty()&&!e(this,n)[1].isEmpty()&&e(this,n)[2].isEmpty()){for(const f of d)for(const w of b)if(r(f,u,w))break}else if(!e(this,n)[0].isEmpty()&&e(this,n)[1].isEmpty()&&e(this,n)[2].isEmpty()){for(const f of g)for(const w of b)if(r(o,f,w))break}else for(const f of d)for(const w of g)for(const L of b)if(r(f,w,L))break;return i}}n=new WeakMap;var p,S;class kt extends y{constructor(t,...i){super(t);c(this,p);c(this,S);a(this,p,[...i]),a(this,S,new Array(e(this,p).length))}size(){return e(this,p).length}at(t){return e(this,p).at(t)}has(t){return e(this,p).includes(t)}indexOf(t){return e(this,p).indexOf(t)}neighbors(){const t=[];for(const i of e(this,p))for(const r of i)r!==this&&t.push(r);return t}[Symbol.iterator](){return e(this,p)[Symbol.iterator]()}emptyVariableSize(){let t=0;for(const i of e(this,p))t+=i.isEmpty()?1:0;return t}isDefined(){for(const t of e(this,p))if(t.isEmpty())return!1;return!0}isSatisfied(){for(let t=0;t<e(this,p).length;++t){const i=e(this,p)[t];if(i.isEmpty())return y.UNDEFINED;e(this,S)[t]=i.value()}return this.rel.isSatisfied(...e(this,S))?1:0}degree(){for(let t=0;t<e(this,p).length;++t){const i=e(this,p)[t];if(i.isEmpty())return y.UNDEFINED;e(this,S)[t]=i.value()}return this.rel.degree(...e(this,S))}highestConsistencyDegree(){const t=this.degree();if(t!==y.UNDEFINED)return t;const i=new Array(this.emptyVariableSize());let r=0;for(let o=0;o<e(this,p).length;++o){const u=e(this,p)[o];u.isEmpty()?i[r++]=o:e(this,S)[o]=u.value()}return this.checkHCD(i,0,0)}lowestConsistencyDegree(){const t=this.degree();if(t!==y.UNDEFINED)return t;const i=new Array(this.emptyVariableSize());let r=0;for(let o=0;o<e(this,p).length;++o){const u=e(this,p)[o];u.isEmpty()?i[r++]=o:e(this,S)[o]=u.value()}return this.checkLCD(i,0,1)}checkHCD(t,i,r){const o=t[i],u=e(this,p)[o].domain();if(i===t.length-1)for(const m of u){e(this,S)[o]=m;const d=this.rel.degree(...e(this,S));if(d>r&&(r=d),r===1)break}else for(const m of u)e(this,S)[o]=m,r=this.checkHCD(t,i+1,r);return r}checkLCD(t,i,r){const o=t[i],u=e(this,p)[o].domain();if(i===t.length-1)for(const m of u){e(this,S)[o]=m;const d=this.rel.degree(...e(this,S));if(d<r&&(r=d),r===0)break}else for(const m of u)e(this,S)[o]=m,r=this.checkLCD(t,i+1,r);return r}}p=new WeakMap,S=new WeakMap;var T,J,A,v,E;class Mt{constructor(){c(this,T,(s,t)=>new ct(s,t));c(this,J,(s,t)=>t.length===1?new Nt(s,t[0]):t.length===2?new Ft(s,t[0],t[1]):t.length===3?new Ct(s,t[0],t[1],t[2]):new kt(s,...t));c(this,A,!1);c(this,v,[]);c(this,E,[])}setVariableFactory(s){a(this,T,s)}setConstraintFactory(s){a(this,J,s)}addVariable(s){s.setIndex(e(this,v).length),e(this,v).push(s)}createDomain(s){return"values"in s?new xt(s.values):"min"in s&&"max"in s?new St(s.min,s.max):null}createVariable(s){if("variable"in s){const t=e(this,T).call(this,this,s.variable.domain());return this.addVariable(t),t.setName(t.name()),t.assign(t.value()),t}else{if(s.value!==void 0&&!s.domain.contains(s.value))throw new Error;const t=e(this,T).call(this,this,s.domain);return this.addVariable(t),s.name&&t.setName(s.name),s.value&&t.assign(s.value),t}}createConstraint(s){for(const i of s.variables)if(i.owner()!==this)return null;const t=e(this,J).call(this,s.relation,s.variables);t.setIndex(e(this,E).length),e(this,E).push(t);for(const i of s.variables)i.connect(t);return t.isFuzzy()&&a(this,A,!0),"name"in s&&t.setName(s.name),t}removeConstraint(s){const t=e(this,E).indexOf(s);e(this,E).splice(t,1);for(let i=t;i<e(this,E).length;++i)e(this,E)[i].setIndex(i);for(const i of s)i.disconnect(s);a(this,A,!1);for(const i of e(this,E))if(i.isFuzzy()){a(this,A,!0);break}}clearAllVariables(){for(const s of e(this,v))s.clear()}reverseVariables(){e(this,v).reverse();for(let s=0;s<e(this,v).length;++s)e(this,v)[s].setIndex(s)}sortVariables(s){e(this,v).sort(s);for(let t=0;t<e(this,v).length;++t)e(this,v)[t].setIndex(t)}variables(){return e(this,v)}variableSize(){return e(this,v).length}variableAt(s){return e(this,v)[s]}variableOf(s){for(const t of e(this,v))if(t.name()===s)return t;return null}hasVariable(s){return e(this,v).includes(s)}constraints(){return e(this,E)}constraintSize(){return e(this,E).length}constraintAt(s){return e(this,E)[s]}constraintOf(s){for(const t of e(this,E))if(t.name()===s)return t;return null}hasConstraint(s){return e(this,E).includes(s)}constraintsBetween(s,t){const i=[];for(const r of s)r.has(t)&&i.push(r);return i}isFuzzy(){return e(this,A)}constraintDensity(){return e(this,E).length/e(this,v).length}emptyVariableSize(){let s=0;for(const t of e(this,v))s+=t.isEmpty()?1:0;return s}hasEmptyDomain(){for(const s of e(this,v))if(s.domain().size()===0)return!0;return!1}degree(){let s=1;for(const t of e(this,E)){const i=t.degree();if(i===y.UNDEFINED)return i;i<s&&(s=i)}return s}constraintsWithDegree(){const s=[];let t=1;for(const i of e(this,E)){const r=i.degree();r<t?(t=r,s.length=0,s.push(i)):r-t<Number.MIN_VALUE*10&&s.push(i)}return[s,t]}averageDegree(){let s=0;for(const t of e(this,E))s+=t.degree();return s/e(this,E).length}ratio(){return this.satisfiedConstraintSize()/e(this,E).length}satisfiedConstraintSize(){let s=0;for(const t of e(this,E))s+=t.isSatisfied()===1?1:0;return s}violatingConstraintSize(){return e(this,E).length-this.satisfiedConstraintSize()}satisfiedConstraints(){const s=[];for(const t of e(this,E))t.isSatisfied()===1&&s.push(t);return s}violatingConstraints(){const s=[];for(const t of e(this,E))t.isSatisfied()!==1&&s.push(t);return s}}T=new WeakMap,J=new WeakMap,A=new WeakMap,v=new WeakMap,E=new WeakMap;var B,K,Q,Y,G,I,$,Z,tt,et,st;class It{constructor(){c(this,B,!0);c(this,K,s=>console.log(s));c(this,Q,()=>!1);c(this,Y,Number.MAX_SAFE_INTEGER);c(this,G,null);c(this,I,.8);c(this,$,null);c(this,Z,0);c(this,tt,0);c(this,et,-1);c(this,st,0)}initialize(){a(this,Z,e(this,G)===null?Number.MAX_VALUE:Date.now()+e(this,G)),a(this,tt,0)}check(s=null){if(s!==null&&e(this,I)!==null&&e(this,I)<=s)return this.outputDebugString("Stop: Current evaluation value is above the target"),!0;if(e(this,Y)<at(this,tt)._++)return this.outputDebugString("Stop: Number of iterations has reached the limit"),!1;if(e(this,Z)<Date.now())return this.outputDebugString("Stop: Time limit has been reached"),!1;if(s!==null&&e(this,$)!==null)if(s!==-1&&e(this,et)===s){if(at(this,st)._++>e(this,$))return this.outputDebugString("Stop: Evaluation value has not changed for a certain number of times"),!1}else a(this,et,s),a(this,st,0);return null}solutionFound(s,t){return e(this,Q).call(this,s,t)}outputDebugString(s){e(this,B)&&e(this,K).call(this,s)}isDebugMode(){return e(this,B)}isTargetAssigned(){return e(this,I)!==null}getTarget(){return e(this,I)}setIterationLimit(s=null){a(this,Y,s===null?Number.MAX_SAFE_INTEGER:s)}setTimeLimit(s=null){a(this,G,s)}setTarget(s=null){a(this,I,s)}setSameEvaluationLimit(s=null){a(this,$,s)}setListener(s){a(this,Q,s)}setDebugMode(s){a(this,B,s)}setDebugOutput(s){a(this,K,s)}}B=new WeakMap,K=new WeakMap,Q=new WeakMap,Y=new WeakMap,G=new WeakMap,I=new WeakMap,$=new WeakMap,Z=new WeakMap,tt=new WeakMap,et=new WeakMap,st=new WeakMap;class X{static crispSolverNames(){return["Forward Checking","Max Forward Checking","Local Changes","Local Changes Ex","Breakout","GENET","Crisp SRS3"]}static fuzzySolverNames(){return["Full Checking","Fuzzy Forward Checking","Flexible Local Changes","Flexible Local Changes Ex","Fuzzy Breakout","Fuzzy GENET","SRS3","SRS3 PF"]}static async createSolver(s){const t=await X.createCrispSolver(s);if(t)return t;const i=await X.createFuzzySolver(s);return i||null}static async createCrispSolver(s){switch(s.replaceAll(" ","")){case"ForwardChecking":case"forward-checking":const{ForwardChecking:t}=await import("./forward-checking-_UWzGHz-.js");return new t;case"MaxForwardChecking":case"max-forward-checking":const{MaxForwardChecking:i}=await import("./max-forward-checking-uRFCqHS9.js");return new i;case"LocalChanges":case"local-changes":const{LocalChanges:r}=await import("./local-changes-v2c5FWcV.js");return new r;case"LocalChangesEx":case"local-changes-ex":const{LocalChangesEx:o}=await import("./local-changes-ex-BqRUYAx5.js");return new o;case"Breakout":case"breakout":const{Breakout:u}=await import("./breakout-CeLsddMi.js");return new u;case"GENET":case"genet":const{GENET:m}=await import("./genet-BD1HrF6s.js");return new m;case"CrispSRS3":case"crisp-srs3":const{CrispSRS3:d}=await import("./crisp-srs3-Bp0aYcNA.js");return new d}return null}static async createFuzzySolver(s){switch(s.replaceAll(" ","")){case"FullChecking":case"full-checking":const{FullChecking:t}=await import("./full-checking-IKdUuFWn.js");return new t;case"FuzzyForwardChecking":case"fuzzy-forward-checking":const{FuzzyForwardChecking:i}=await import("./fuzzy-forward-checking-BFa-jjw5.js");return new i;case"FlexibleLocalChanges":case"flexible-local-changes":const{FlexibleLocalChanges:r}=await import("./flexible-local-changes-D2gUF1Yf.js");return new r;case"FlexibleLocalChangesEx":case"flexible-local-changes-ex":const{FlexibleLocalChangesEx:o}=await import("./flexible-local-changes-ex-C50HsR2W.js");return new o;case"FuzzyBreakout":case"fuzzy-breakout":const{FuzzyBreakout:u}=await import("./fuzzy-breakout-BLrapa5J.js");return new u;case"FuzzyGENET":case"fuzzy-genet":const{FuzzyGENET:m}=await import("./fuzzy-genet-3PdjrQ39.js");return new m;case"SRS3":case"srs3":const{SRS3:d}=await import("./srs3-BcQsm2dw.js");return new d;case"SRS3PF":case"SRS3_PF":case"srs3-pf":{const{SRS3:g}=await import("./srs3-BcQsm2dw.js"),{wrapWithPostStabilizer:b}=await import("./post-stabilizer-DI12K1ct.js");return b(new g)}}return null}}function Lt(h,s){const t=dt(h);return t/(t+dt(s))}function dt(h){let s,t,i,r,o;if(h>1){s=Math.sqrt(2*h-1);do do{do{do t=Math.random(),i=2*Math.random()-1;while(t*t+i*i>=1||t===0);i=i/t,t=s*i+h-1}while(t<=0);r=(h-1)*Math.log(t/(h-1))-s*i}while(r<=-50);while((1+i*i)*Math.exp(r)<=Math.random())}else{s=Math.E/(h+Math.E);do Math.random()<s?(t=0,i=1,o=Math.random(),o>0&&(t=Math.exp(Math.log(o)/h),i=Math.exp(-t))):(o=Math.random(),t=1,i=0,o>0&&(t=1-Math.log(o),i=Math.exp((h-1)*Math.log(t))));while(Math.random()>=i)}return t}var nt;class At{constructor(){_(this,"_debug",!0);c(this,nt,s=>console.log(s))}setDebugMode(s){this._debug=s}setDebugOutput(s){this._debugOutput=s}_debugOutput(s){this._debug&&e(this,nt).call(this,s)}}nt=new WeakMap;var z,U,k,N,ot,vt;class Ut extends At{constructor(t,i,r,o=null){super();c(this,ot);c(this,z);c(this,U);c(this,k);c(this,N);a(this,z,t),a(this,U,i),a(this,k,r),a(this,N,o??t)}getVariableCount(){return e(this,z)}setVariableCount(t){a(this,z,t)}getDensity(){return e(this,U)}setDensity(t){a(this,U,t)}getAverageTightness(){return e(this,k)}setAverageTightness(t){a(this,k,t)}getDomainSize(){return e(this,N)}setDomainSize(t){a(this,N,t)}isFuzzy(){return!0}createProblem(t){const i=e(this,U)*((e(this,z)*e(this,z)-e(this,z))/2)|0,r=[];for(let o=0;o<e(this,z);++o){const u=t.createVariable({domain:t.createDomain({min:0,max:e(this,N)-1}),value:0,name:""});r.push(u)}for(;t.constraintSize()<i;){const o=gt(e(this,z)),u=gt(e(this,z));o!==u&&t.constraintsBetween(r[o],r[u]).length===0&&t.createConstraint({relation:new Ot(mt(this,ot,vt).call(this)),variables:[r[o],r[u]]})}return t}}z=new WeakMap,U=new WeakMap,k=new WeakMap,N=new WeakMap,ot=new WeakSet,vt=function(){const t=[];for(let i=0;i<e(this,N);++i)t.push(new Array(e(this,N)));for(let i=0;i<e(this,N);++i)for(let r=0;r<e(this,N);++r){const o=e(this,k)===0?Number.MAX_VALUE:(1-e(this,k))/e(this,k);t[i][r]=Lt(1,o)}return t};function gt(h){return Math.floor(Math.random()*Math.floor(h))}var it;class Ot extends yt{constructor(t){super();c(this,it);a(this,it,t)}degree(t,i){return e(this,it)[t][i]}}it=new WeakMap;onmessage=async h=>{const{task:s,args:t}=h.data;switch(s){case"create":Vt(...t);break;case"solve":Rt(...t);break}};let ut=null,lt=null;function Vt(h,s,t){ut=new Ut(h,s,t),ut.setDebugOutput(bt),lt=ut.createProblem(new Mt)}async function Rt(h,s){const t=Date.now(),i=X.fuzzySolverNames()[h],r=new It;r.setTimeLimit(5e3),r.setTarget(s),r.setDebugOutput(bt),r.setDebugMode(!0);const o=await X.createSolver(i),u=o.solve(lt,r),m=Date.now()-t,d=lt.degree();postMessage({result:u,time:m,deg:d,solver:o.name()})}function bt(h){postMessage({log:h})}export{y as C,It as M};
