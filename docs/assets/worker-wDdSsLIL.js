var gt=Object.defineProperty;var rt=r=>{throw TypeError(r)};var mt=(r,e,t)=>e in r?gt(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var A=(r,e,t)=>mt(r,typeof e!="symbol"?e+"":e,t),Z=(r,e,t)=>e.has(r)||rt("Cannot "+t);var s=(r,e,t)=>(Z(r,e,"read from private field"),t?t.call(r):e.get(r)),o=(r,e,t)=>e.has(r)?rt("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),a=(r,e,t,i)=>(Z(r,e,"write to private field"),i?i.call(r,t):e.set(r,t),t),nt=(r,e,t)=>(Z(r,e,"access private method"),t);var tt=(r,e,t,i)=>({set _(n){a(r,e,n,t)},get _(){return s(r,e,i)}});var V,O;class ht{constructor(){o(this,V,-1);o(this,O,"");A(this,"userObject",null)}setIndex(e){a(this,V,e)}setName(e){a(this,O,e)}index(){return s(this,V)}name(){return s(this,O)}}V=new WeakMap,O=new WeakMap;var C,L,M,I,f;const v=class v extends ht{constructor(t,i){super();o(this,L);o(this,M);o(this,I,s(v,C));o(this,f,[]);a(this,L,t),a(this,M,i)}toString(){const t=this.name(),i=t?`(${t})`:"",n=this.isEmpty()?"<empty>":""+this.value();return`x${this.index()}${i} = ${n}`}size(){return s(this,f).length}at(t){return s(this,f).at(t)}has(t){return s(this,f).includes(t)}indexOf(t){return s(this,f).indexOf(t)}neighbors(){const t=[];for(const i of s(this,f))for(const n of i)n!==this&&t.push(n);return t}[Symbol.iterator](){return s(this,f)[Symbol.iterator]()}owner(){return s(this,L)}connect(t){if(s(this,f).includes(t))throw new RangeError;s(this,f).push(t)}disconnect(t){if(!s(this,f).includes(t))throw new RangeError;a(this,f,s(this,f).filter(i=>i!==t))}domain(t){if(t===void 0)return s(this,M);a(this,M,t),this.clear()}assign(t){a(this,I,t)}clear(){this.assign(s(v,C))}value(){return s(this,I)}isEmpty(){return this.value()===s(v,C)}};C=new WeakMap,L=new WeakMap,M=new WeakMap,I=new WeakMap,f=new WeakMap,o(v,C,Number.MIN_VALUE);let H=v;class R{static createRangedDomain(e,t){return new pt(e,t)}static createArbitraryDomain(e){return new dt(e)}random(){return this.at(Math.floor(Math.random()*this.size()))}}var p;class dt extends R{constructor(t){super();o(this,p);a(this,p,[...t])}contains(t){return s(this,p).includes(t)}indexOf(t){return s(this,p).indexOf(t)}size(){return s(this,p).length}at(t){return s(this,p)[t]}[Symbol.iterator](){return s(this,p)[Symbol.iterator]()}}p=new WeakMap;var d,w;class pt extends R{constructor(t,i){super();o(this,d);o(this,w);a(this,d,t|0),a(this,w,i|0)}contains(t){return s(this,d)<=t&&t<=s(this,w)}indexOf(t){return s(this,d)<=t&&t<=s(this,w)?t-s(this,d):-1}size(){return s(this,w)-s(this,d)+1}at(t){return s(this,d)+t}[Symbol.iterator](){let t=s(this,d);const i=s(this,w);return{next(){return t<=i?{value:t++,done:!1}:{value:null,done:!0}}}}}d=new WeakMap,w=new WeakMap;class xt{}class ut extends xt{isSatisfied(...e){const t=this.degree(...e);return 0<t&&t<1?0:t}}class _ extends ht{constructor(t){super();A(this,"r");A(this,"xs",[]);this.r=t}static create(t,i){return i.length===1?new wt(t,i[0]):i.length===2?new yt(t,i[0],i[1]):i.length===3?new bt(t,i[0],i[1],i[2]):new St(t,...i)}toString(){const t=this.name(),i=t?`(${t})`:"",n=this.degree(),h=n<0?"UNDEFINED":""+n;return`c${this.index()}${i} = ${h}`}size(){return this.xs.length}at(t){return this.xs.at(t)}has(t){return this.xs.includes(t)}indexOf(t){return this.xs.indexOf(t)}neighbors(){const t=[];for(const i of this.xs)for(const n of i)n!==this&&t.push(n);return t}[Symbol.iterator](){return this.xs[Symbol.iterator]()}relation(){return this.r}isFuzzy(){return this.r instanceof ut}}class wt extends _{constructor(e,t){super(e),this.xs=[t]}emptyVariableSize(){return this.xs[0].isEmpty()?1:0}isDefined(){return!this.xs[0].isEmpty()}isSatisfied(){return this.xs[0].isEmpty()?-1:this.r.isSatisfied(this.xs[0].value())?1:0}degree(){return this.xs[0].isEmpty()?-1:this.r.degree(this.xs[0].value())}}class yt extends _{constructor(e,t,i){super(e),this.xs=[t,i]}emptyVariableSize(){let e=0;return this.xs[0].isEmpty()&&++e,this.xs[1].isEmpty()&&++e,e}isDefined(){return!this.xs[0].isEmpty()&&!this.xs[1].isEmpty()}isSatisfied(){return this.xs[0].isEmpty()||this.xs[1].isEmpty()?-1:this.r.isSatisfied(this.xs[0].value(),this.xs[1].value())?1:0}degree(){return this.xs[0].isEmpty()||this.xs[1].isEmpty()?-1:this.r.degree(this.xs[0].value(),this.xs[1].value())}}class bt extends _{constructor(e,t,i,n){super(e),this.xs=[t,i,n]}emptyVariableSize(){let e=0;return this.xs[0].isEmpty()&&++e,this.xs[1].isEmpty()&&++e,this.xs[2].isEmpty()&&++e,e}isDefined(){return!this.xs[0].isEmpty()&&!this.xs[1].isEmpty()&&!this.xs[2].isEmpty()}isSatisfied(){return this.xs[0].isEmpty()||this.xs[1].isEmpty()||this.xs[2].isEmpty()?-1:this.r.isSatisfied(this.xs[0].value(),this.xs[1].value(),this.xs[2].value())?1:0}degree(){return this.xs[0].isEmpty()||this.xs[1].isEmpty()||this.xs[2].isEmpty()?-1:this.r.degree(this.xs[0].value(),this.xs[1].value(),this.xs[2].value())}}var y;class St extends _{constructor(t,...i){super(t);o(this,y);this.xs=[...i],a(this,y,new Array(this.xs.length))}emptyVariableSize(){let t=0;for(const i of this.xs)t+=i.isEmpty()?1:0;return t}isDefined(){for(const t of this.xs)if(t.isEmpty())return!1;return!0}isSatisfied(){for(let t=0;t<this.xs.length;++t){const i=this.xs[t];if(i.isEmpty())return-1;s(this,y)[t]=i.value()}return this.r.isSatisfied(...s(this,y))?1:0}degree(){for(let t=0;t<this.xs.length;++t){const i=this.xs[t];if(i.isEmpty())return-1;s(this,y)[t]=i.value()}return this.r.degree(...s(this,y))}}y=new WeakMap;var D,B,E,l,u;class Et{constructor(){o(this,D,(e,t)=>new H(e,t));o(this,B,(e,t)=>_.create(e,t));o(this,E,!1);o(this,l,[]);o(this,u,[])}setVariableFactory(e){a(this,D,e)}setConstraintFactory(e){a(this,B,e)}addVariable(e){e.setIndex(s(this,l).length),s(this,l).push(e)}createDomain(e,t=null){if(Array.isArray(e))return R.createArbitraryDomain(e);if(t!==null)return R.createRangedDomain(e,t);throw new RangeError}createVariable(e,t=null,i){if(e instanceof H){const n=s(this,D).call(this,this,e.domain());return this.addVariable(n),n.setName(n.name()),n.assign(n.value()),n}else if(e instanceof R){if(t!==null&&!e.contains(t))throw new Error;const n=s(this,D).call(this,this,e);return this.addVariable(n),t!==null&&n.assign(t),i&&n.setName(i),n}throw new RangeError}createConstraint(e,t,i){for(const h of t)if(h.owner()!==this)throw new RangeError;const n=s(this,B).call(this,e,t);n.setIndex(s(this,u).length),s(this,u).push(n);for(const h of t)h.connect(n);return n.isFuzzy()&&a(this,E,!0),i&&n.setName(i),n}removeConstraint(e){const t=s(this,u).indexOf(e);s(this,u).splice(t,1);for(let i=t;i<s(this,u).length;++i)s(this,u)[i].setIndex(i);for(const i of e)i.disconnect(e);a(this,E,!1);for(const i of s(this,u))if(i.isFuzzy()){a(this,E,!0);break}}clearAllVariables(){for(const e of s(this,l))e.clear()}reverseVariables(){s(this,l).reverse();for(let e=0;e<s(this,l).length;++e)s(this,l)[e].setIndex(e)}sortVariables(e){s(this,l).sort(e);for(let t=0;t<s(this,l).length;++t)s(this,l)[t].setIndex(t)}variables(){return s(this,l)}variableSize(){return s(this,l).length}variableAt(e){return s(this,l)[e]}variableOf(e){for(const t of s(this,l))if(t.name()===e)return t;return null}hasVariable(e){return s(this,l).includes(e)}constraints(){return s(this,u)}constraintSize(){return s(this,u).length}constraintAt(e){return s(this,u)[e]}constraintOf(e){for(const t of s(this,u))if(t.name()===e)return t;return null}hasConstraint(e){return s(this,u).includes(e)}constraintsBetween(e,t){const i=[];for(const n of e)n.has(t)&&i.push(n);return i}isFuzzy(){return s(this,E)}constraintDensity(){return s(this,u).length/s(this,l).length}emptyVariableSize(){let e=0;for(const t of s(this,l))e+=t.isEmpty()?1:0;return e}hasEmptyDomain(){for(const e of s(this,l))if(e.domain().size()===0)return!0;return!1}degree(){let e=1;for(const t of s(this,u)){const i=t.degree();if(i<0)return i;i<e&&(e=i)}return e}constraintsWithDegree(){const e=[];let t=1;for(const i of s(this,u)){const n=i.degree();n<t?(t=n,e.length=0,e.push(i)):n-t<Number.MIN_VALUE*10&&e.push(i)}return[e,t]}averageDegree(){let e=0;for(const t of s(this,u))e+=t.degree();return e/s(this,u).length}ratio(){return this.satisfiedConstraintSize()/s(this,u).length}satisfiedConstraintSize(){let e=0;for(const t of s(this,u))e+=t.isSatisfied()===1?1:0;return e}violatingConstraintSize(){return s(this,u).length-this.satisfiedConstraintSize()}satisfiedConstraints(){const e=[];for(const t of s(this,u))t.isSatisfied()===1&&e.push(t);return e}violatingConstraints(){const e=[];for(const t of s(this,u))t.isSatisfied()===0&&e.push(t);return e}}D=new WeakMap,B=new WeakMap,E=new WeakMap,l=new WeakMap,u=new WeakMap;var F,G,$,P,k,b,N,U,X,j,q;class zt{constructor(){o(this,F,!0);o(this,G,e=>console.log(e));o(this,$,()=>!1);o(this,P,Number.MAX_SAFE_INTEGER);o(this,k,null);o(this,b,.8);o(this,N,null);o(this,U,0);o(this,X,0);o(this,j,-1);o(this,q,0)}initialize(){a(this,U,s(this,k)===null?Number.MAX_VALUE:Date.now()+s(this,k)),a(this,X,0)}check(e=null){if(e!==null&&s(this,b)!==null&&s(this,b)<=e)return this.outputDebugString("Stop: Current evaluation value is above the target"),!0;if(s(this,P)<tt(this,X)._++)return this.outputDebugString("Stop: Number of iterations has reached the limit"),!1;if(s(this,U)<Date.now())return this.outputDebugString("Stop: Time limit has been reached"),!1;if(e!==null&&s(this,N)!==null)if(e!==-1&&s(this,j)===e){if(s(this,N)<tt(this,q)._++)return this.outputDebugString("Stop: Evaluation value has not changed for a certain number of times"),!1}else a(this,j,e),a(this,q,0);return null}solutionFound(e,t){return s(this,$).call(this,e,t)}outputDebugString(e){s(this,F)&&s(this,G).call(this,e)}isDebugMode(){return s(this,F)}isTargetAssigned(){return s(this,b)!==null}getTarget(){return s(this,b)}setIterationLimit(e=null){a(this,P,e===null?Number.MAX_SAFE_INTEGER:e)}setTimeLimit(e=null){a(this,k,e)}setTarget(e=null){a(this,b,e)}setSameEvaluationLimit(e=null){a(this,N,e)}setListener(e){a(this,$,e)}setDebugMode(e){a(this,F,e)}setDebugOutput(e){a(this,G,e)}}F=new WeakMap,G=new WeakMap,$=new WeakMap,P=new WeakMap,k=new WeakMap,b=new WeakMap,N=new WeakMap,U=new WeakMap,X=new WeakMap,j=new WeakMap,q=new WeakMap;class T{static crispSolverNames(){return["Forward Checking","Max Forward Checking","Local Changes","Breakout","GENET","Crisp SRS3"]}static fuzzySolverNames(){return["Full Checking","Fuzzy Forward Checking","Flexible Local Changes","Fuzzy Breakout","Fuzzy GENET","SRS3","SRS3 PF"]}static async createSolver(e){const t=await T.createCrispSolver(e);if(t)return t;const i=await T.createFuzzySolver(e);return i||null}static async createCrispSolver(e){switch(e.replaceAll(" ","")){case"ForwardChecking":case"forward-checking":const{ForwardChecking:t}=await import("./forward-checking-C_8Xkvt-.js");return new t;case"MaxForwardChecking":case"max-forward-checking":const{MaxForwardChecking:i}=await import("./max-forward-checking-TqtAiE4_.js");return new i;case"LocalChanges":case"local-changes":const{LocalChanges:n}=await import("./local-changes-mAInB2wh.js");return new n;case"Breakout":case"breakout":const{Breakout:h}=await import("./breakout-aDQhLBn-.js");return new h;case"GENET":case"genet":const{GENET:c}=await import("./genet-DXuKRor2.js");return new c;case"CrispSRS3":case"crisp-srs3":const{CrispSRS3:S}=await import("./crisp-srs3-StisSY4K.js");return new S}return null}static async createFuzzySolver(e){switch(e.replaceAll(" ","")){case"FullChecking":case"full-checking":const{FullChecking:t}=await import("./full-checking-DY5IODzr.js");return new t;case"FuzzyForwardChecking":case"fuzzy-forward-checking":const{FuzzyForwardChecking:i}=await import("./fuzzy-forward-checking-DVC9IjgM.js");return new i;case"FlexibleLocalChanges":case"flexible-local-changes":const{FlexibleLocalChanges:n}=await import("./flexible-local-changes-Bk1HLxkf.js");return new n;case"FuzzyBreakout":case"fuzzy-breakout":const{FuzzyBreakout:h}=await import("./fuzzy-breakout-Bm8h2OIf.js");return new h;case"FuzzyGENET":case"fuzzy-genet":const{FuzzyGENET:c}=await import("./fuzzy-genet-CqyodUBM.js");return new c;case"SRS3":case"srs3":const{SRS3:S}=await import("./srs3-C3Gb7nar.js");return new S;case"SRS3PF":case"SRS3_PF":case"srs3-pf":{const{SRS3:Q}=await import("./srs3-C3Gb7nar.js"),{wrapWithPostStabilizer:Y}=await import("./post-stabilizer-DGshL3g9.js");return Y(new Q)}}return null}}function vt(r,e){const t=at(r);return t/(t+at(e))}function at(r){let e,t,i,n,h;if(1<r){e=Math.sqrt(2*r-1);do do{do{do t=Math.random(),i=2*Math.random()-1;while(1<=t*t+i*i||t===0);i=i/t,t=e*i+r-1}while(t<=0);n=(r-1)*Math.log(t/(r-1))-e*i}while(n<=-50);while((1+i*i)*Math.exp(n)<=Math.random())}else{e=Math.E/(r+Math.E);do Math.random()<e?(t=0,i=1,h=Math.random(),0<h&&(t=Math.exp(Math.log(h)/r),i=Math.exp(-t))):(h=Math.random(),t=1,i=0,0<h&&(t=1-Math.log(h),i=Math.exp((r-1)*Math.log(t))));while(Math.random()>=i)}return t}var J;class Ct{constructor(){A(this,"_debug",!0);o(this,J,e=>console.log(e))}setDebugMode(e){this._debug=e}setDebugOutput(e){this._debugOutput=e}_debugOutput(e){this._debug&&s(this,J).call(this,e)}}J=new WeakMap;var g,z,x,m,K,lt;class Mt extends Ct{constructor(t,i,n,h=null){super();o(this,K);o(this,g);o(this,z);o(this,x);o(this,m);a(this,g,t),a(this,z,i),a(this,x,n),a(this,m,h??t)}getVariableCount(){return s(this,g)}setVariableCount(t){a(this,g,t)}getDensity(){return s(this,z)}setDensity(t){a(this,z,t)}getAverageTightness(){return s(this,x)}setAverageTightness(t){a(this,x,t)}getDomainSize(){return s(this,m)}setDomainSize(t){a(this,m,t)}isFuzzy(){return!0}createProblem(t){const i=s(this,z)*((s(this,g)*s(this,g)-s(this,g))/2)|0,n=[];for(let h=0;h<s(this,g);++h){const c=t.createVariable(t.createDomain(0,s(this,m)-1),0);n.push(c)}for(;t.constraintSize()<i;){const h=ot(s(this,g)),c=ot(s(this,g));h!==c&&t.constraintsBetween(n[h],n[c]).length===0&&t.createConstraint(new Dt(nt(this,K,lt).call(this)),[n[h],n[c]])}return t}}g=new WeakMap,z=new WeakMap,x=new WeakMap,m=new WeakMap,K=new WeakSet,lt=function(){const t=[];for(let i=0;i<s(this,m);++i)t.push(new Array(s(this,m)));for(let i=0;i<s(this,m);++i)for(let n=0;n<s(this,m);++n){const h=s(this,x)===0?Number.MAX_VALUE:(1-s(this,x))/s(this,x);t[i][n]=vt(1,h)}return t};function ot(r){return Math.floor(Math.random()*Math.floor(r))}var W;class Dt extends ut{constructor(t){super();o(this,W);a(this,W,t)}degree(t,i){return s(this,W)[t][i]}}W=new WeakMap;onmessage=async r=>{const{task:e,args:t}=r.data;switch(e){case"create":Ft(...t);break;case"solve":kt(...t);break}};let et=null,st=null,it=!1;function Ft(r,e,t){et=new Mt(r,e,t),et.setDebugOutput(ct),st=et.createProblem(new Et)}async function kt(r,e,t,i){const n=Date.now(),h=T.fuzzySolverNames()[r],c=new zt;c.setTarget(e===-1?null:e),c.setTimeLimit(t===-1?null:t),c.setDebugOutput(ct),c.setDebugMode(i);const S=await T.createSolver(h);it=i;const Q=S.solve(st,c),Y=Date.now()-n,ft=st.degree();it=!0,postMessage({result:Q,time:Y,ev:ft,solver:S.name()})}function ct(r){it&&postMessage({log:r})}export{zt as M,H as V};
