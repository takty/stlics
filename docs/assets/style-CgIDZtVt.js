var Vi=Object.defineProperty;var ds=d=>{throw TypeError(d)};var _i=(d,a,t)=>a in d?Vi(d,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[a]=t;var C=(d,a,t)=>_i(d,typeof a!="symbol"?a+"":a,t),We=(d,a,t)=>a.has(d)||ds("Cannot "+t);var i=(d,a,t)=>(We(d,a,"read from private field"),t?t.call(d):a.get(d)),h=(d,a,t)=>a.has(d)?ds("Cannot add the same private member more than once"):a instanceof WeakSet?a.add(d):a.set(d,t),g=(d,a,t,e)=>(We(d,a,"write to private field"),e?e.call(d,t):a.set(d,t),t),f=(d,a,t)=>(We(d,a,"access private method"),t);var oe=(d,a,t,e)=>({set _(s){g(d,a,s,t)},get _(){return i(d,a,e)}});(function(){const a=document.createElement("link").relList;if(a&&a.supports&&a.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))e(s);new MutationObserver(s=>{for(const n of s)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&e(r)}).observe(document,{childList:!0,subtree:!0});function t(s){const n={};return s.integrity&&(n.integrity=s.integrity),s.referrerPolicy&&(n.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?n.credentials="include":s.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function e(s){if(s.ep)return;s.ep=!0;const n=t(s);fetch(s.href,n)}})();var ae,ce;class Mi{constructor(){h(this,ae,-1);h(this,ce,"");C(this,"userObject",null);C(this,"solverObject",null)}setIndex(a){g(this,ae,a)}setName(a){g(this,ce,a)}index(){return i(this,ae)}name(){return i(this,ce)}}ae=new WeakMap,ce=new WeakMap;class Pi{}class Ri extends Pi{isSatisfied(...a){const t=this.degree(...a);return 0<t&&t<1?0:t}}const je=class je extends Mi{constructor(t){super();C(this,"rel");this.rel=t}relation(){return this.rel}isFuzzy(){return this.rel instanceof Ri}toString(){const t=this.name(),e=t?`(${t})`:"",s=this.degree(),n=s===je.UNDEFINED?"UNDEFINED":""+s;return`c${this.index()}${e} = ${n}`}};C(je,"UNDEFINED",-1);let U=je;var It,le,he,ue,$t,st,Tt,fe,de,ge,pe;class Ii{constructor(){h(this,It,!0);h(this,le,a=>console.log(a));h(this,he,()=>!1);h(this,ue,Number.MAX_SAFE_INTEGER);h(this,$t,null);h(this,st,.8);h(this,Tt,null);h(this,fe,0);h(this,de,0);h(this,ge,-1);h(this,pe,0)}initialize(){g(this,fe,i(this,$t)===null?Number.MAX_VALUE:Date.now()+i(this,$t)),g(this,de,0)}check(a=null){if(a!==null&&i(this,st)!==null&&i(this,st)<=a)return this.outputDebugString("Stop: Current evaluation value is above the target"),!0;if(i(this,ue)<oe(this,de)._++)return this.outputDebugString("Stop: Number of iterations has reached the limit"),!1;if(i(this,fe)<Date.now())return this.outputDebugString("Stop: Time limit has been reached"),!1;if(a!==null&&i(this,Tt)!==null)if(a!==-1&&i(this,ge)===a){if(oe(this,pe)._++>i(this,Tt))return this.outputDebugString("Stop: Evaluation value has not changed for a certain number of times"),!1}else g(this,ge,a),g(this,pe,0);return null}solutionFound(a,t){return i(this,he).call(this,a,t)}outputDebugString(a){i(this,It)&&i(this,le).call(this,a)}isDebugMode(){return i(this,It)}isTargetAssigned(){return i(this,st)!==null}getTarget(){return i(this,st)}setIterationLimit(a=null){g(this,ue,a===null?Number.MAX_SAFE_INTEGER:a)}setTimeLimit(a=null){g(this,$t,a)}setTarget(a=null){g(this,st,a)}setSameEvaluationLimit(a=null){g(this,Tt,a)}setListener(a){g(this,he,a)}setDebugMode(a){g(this,It,a)}setDebugOutput(a){g(this,le,a)}}It=new WeakMap,le=new WeakMap,he=new WeakMap,ue=new WeakMap,$t=new WeakMap,st=new WeakMap,Tt=new WeakMap,fe=new WeakMap,de=new WeakMap,ge=new WeakMap,pe=new WeakMap;class F{constructor(a){C(this,"pro");C(this,"monitor",new Ii);this.pro=a}setMonitor(a){this.monitor=a}getMonitor(){return this.monitor}name(){return""}exec(){return!1}solve(){return this.exec()}}var it,V,nt;const et=class et{constructor(a){h(this,V);h(this,nt,0);g(this,V,new Array(a)),i(this,V).fill(i(et,it))}prunedSize(){return i(this,nt)}prune(a,t){if(i(this,V)[a]===i(et,it))++oe(this,nt)._;else throw new Error;i(this,V)[a]=t}isEmpty(){return i(this,V).length===i(this,nt)}isPruned(a){return i(this,V)[a]!==i(et,it)}recover(a){for(let t=0;t<i(this,V).length;++t)i(this,V)[t]===a&&(i(this,V)[t]=i(et,it),--oe(this,nt)._)}recoverAll(){i(this,V).fill(i(et,it)),g(this,nt,0)}};it=new WeakMap,V=new WeakMap,nt=new WeakMap,h(et,it,Number.MIN_SAFE_INTEGER);let He=et;function Oe(d){for(const a of d)a.solverObject=new He(a.domain().size())}function Ue(d){for(const a of d)a.solverObject=null}function dt(d,a){for(const t of d)t.solverObject.recover(a)}function Be(d){let a=0,t=Number.MAX_VALUE;for(let e=0;e<d.length;++e){const s=d[e];if(!s.isEmpty())continue;const r=s.domain().size()-s.solverObject.prunedSize();r<t&&(t=r,a=e)}return a}var rt,ot;class Re{constructor(a){h(this,rt);h(this,ot);if("assignment"in a)g(this,rt,a.assignment.variable()),g(this,ot,a.assignment.value());else if("variable"in a)g(this,rt,a.variable),g(this,ot,a.value??a.variable.value());else throw new RangeError}apply(){i(this,rt).assign(i(this,ot))}toString(){return`v${i(this,rt).index()} <- ${i(this,ot)}`}value(){return i(this,ot)}variable(){return i(this,rt)}}rt=new WeakMap,ot=new WeakMap;var D;const fs=class fs{constructor(){h(this,D,[])}static fromVariables(a){const t=new fs;return t.setVariables(a),t}setProblem(a){i(this,D).length=0;for(const t of a.variables())i(this,D).push(new Re({variable:t,value:t.value()}))}setAssignmentList(a){i(this,D).length=0;for(const t of a)i(this,D).push(new Re({variable:t.variable(),value:t.value()}))}setVariables(a){i(this,D).length=0;for(const t of a)i(this,D).push(new Re({variable:t,value:t.value()}))}addVariable(a,t=null){i(this,D).push(new Re({variable:a,value:t}))}apply(){for(const a of i(this,D))a.apply()}clear(){i(this,D).length=0}isEmpty(){return i(this,D).length===0}size(){return i(this,D).length}differenceSize(){let a=0;for(const t of i(this,D))t.variable().value()!==t.value()&&++a;return a}at(a){return i(this,D)[a]}[Symbol.iterator](){return i(this,D)[Symbol.iterator]()}random(){return i(this,D)[Math.floor(Math.random()*i(this,D).length)]}};D=new WeakMap;let b=fs;function Ge(d,a){const t=[];for(let e=0;e<a.length;++e){t.push(new Array(a.length));for(let s=0;s<a.length;++s)s<e&&(t[e][s]=d.constraintsBetween(a[s],a[e]))}return t}var I,Lt,jt,me,M,qe,Es,Ds,ks,Cs;class $i extends F{constructor(t){super(t);h(this,M);h(this,I);h(this,Lt,[]);h(this,jt,new b);h(this,me,!0);g(this,I,[...this.pro.variables()]),g(this,Lt,Ge(this.pro,i(this,I)))}name(){return"Forward Checking"}setUsingMinimumRemainingValuesHeuristics(t){g(this,me,t)}exec(){this.monitor.initialize(),Oe(i(this,I)),this.pro.clearAllVariables();const t=f(this,M,qe).call(this,0);return i(this,jt).apply(),Ue(i(this,I)),t===!0}}I=new WeakMap,Lt=new WeakMap,jt=new WeakMap,me=new WeakMap,M=new WeakSet,qe=function(t){if(t===this.pro.variableSize()){const o=this.pro.ratio();return i(this,jt).setProblem(this.pro),this.monitor.outputDebugString(`	Evaluation ${o}`),this.monitor.solutionFound(i(this,jt),o),!0}let e=null;if((e=this.monitor.check())!==null)return e;const s=i(this,I)[i(this,me)?Be(i(this,I)):t],n=s.domain(),r=s.solverObject;for(let o=0,c=n.size();o<c;++o)if(!(r.isPruned(o)||(s.assign(n.at(o)),f(this,M,Cs).call(this,s)))){if(f(this,M,Es).call(this,t,s)&&(e=f(this,M,qe).call(this,t+1),e!==null))break;dt(i(this,I),t)}return e===null&&(dt(i(this,I),t),s.clear()),e},Es=function(t,e){for(const s of i(this,I)){if(!s.isEmpty())continue;const n=f(this,M,Ds).call(this,e.index(),s.index()),r=s.solverObject,o=s.domain();for(const c of n)if(c.emptyVariableSize()===1&&!f(this,M,ks).call(this,t,s,o,r,c))return!1}return!0},Ds=function(t,e){return t<e?i(this,Lt)[e][t]:i(this,Lt)[t][e]},ks=function(t,e,s,n,r){for(let o=0,c=s.size();o<c;++o)n.isPruned(o)||(e.assign(s.at(o)),r.isSatisfied()===0&&n.prune(o,t));return e.clear(),!n.isEmpty()},Cs=function(t){let e=0;for(const s of t)s.isSatisfied()===0&&++e;return e};var $,Ot,Ut,be,at,P,Ye,Fs,Ns,As,Vs;class Ti extends F{constructor(t){super(t);h(this,P);h(this,$);h(this,Ot,[]);h(this,Ut,new b);h(this,be,!0);h(this,at,0);g(this,$,[...this.pro.variables()]),g(this,Ot,Ge(this.pro,i(this,$)))}name(){return"Forward Checking for Max CSPs"}setUsingMinimumRemainingValuesHeuristics(t){g(this,be,t)}exec(){this.monitor.initialize(),g(this,at,this.pro.constraintSize()),Oe(i(this,$)),this.pro.clearAllVariables();const t=f(this,P,Ye).call(this,0);return i(this,Ut).apply(),Ue(i(this,$)),t===!0}}$=new WeakMap,Ot=new WeakMap,Ut=new WeakMap,be=new WeakMap,at=new WeakMap,P=new WeakSet,Ye=function(t,e=0){if(t===this.pro.variableSize()){const c=this.pro.ratio();return i(this,Ut).setProblem(this.pro),this.monitor.outputDebugString(`	Evaluation ${c}`),e<i(this,at)&&(g(this,at,e),this.monitor.solutionFound(i(this,Ut),c))?!0:this.monitor.check(c)}let s=null;if((s=this.monitor.check())!==null)return s;const n=i(this,$)[i(this,be)?Be(i(this,$)):t],r=n.domain(),o=n.solverObject;for(let c=0,l=r.size();c<l;++c){if(o.isPruned(c))continue;n.assign(r.at(c));const u=e+f(this,P,Vs).call(this,n);if(!(i(this,at)<=u)){if((e+1<i(this,at)||f(this,P,Fs).call(this,t,n))&&(s=f(this,P,Ye).call(this,t+1,u),s!==null))break;dt(i(this,$),t)}}return s===null&&(dt(i(this,$),t),n.clear()),s},Fs=function(t,e){for(const s of i(this,$)){if(!s.isEmpty())continue;const n=f(this,P,Ns).call(this,e.index(),s.index()),r=s.solverObject,o=s.domain();for(const c of n)if(c.emptyVariableSize()===1&&!f(this,P,As).call(this,t,s,o,r,c))return!1}return!0},Ns=function(t,e){return t<e?i(this,Ot)[e][t]:i(this,Ot)[t][e]},As=function(t,e,s,n,r){for(let o=0,c=s.size();o<c;++o)n.isPruned(o)||(e.assign(s.at(o)),r.isSatisfied()===0&&n.prune(o,t));return e.clear(),!n.isEmpty()},Vs=function(t){let e=0;for(const s of t)s.isSatisfied()===0&&++e;return e};var wt,k,Ie,Ke,_s,Je,Ms;class Li extends F{constructor(t,e=!1){super(t);h(this,k);h(this,wt,!1);e&&this.pro.clearAllVariables()}name(){return"Local Changes"}exec(){this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables(),g(this,wt,!1);const t=new Set,e=new Set;for(const o of this.pro.variables())(o.isEmpty()?e:t).add(o);this.monitor.initialize();const s=new b,n=f(this,k,Ie).call(this,new Set,t,e),r=this.pro.ratio();return this.monitor.outputDebugString(`Evaluation: ${r}`),n&&(s.setProblem(this.pro),this.monitor.solutionFound(s,r))?!0:n}}wt=new WeakMap,k=new WeakSet,Ie=function(t,e,s){{this.monitor.outputDebugString(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`);const n=this.monitor.check(this.pro.degree());if(n!==null)return g(this,wt,!0),n;if(s.size===0)return!0;const r=s.values().next().value,o=f(this,k,Ke).call(this,t,e,r,ji(r));return!o||i(this,wt)?o:(e=gs(e,r),s=ps(s,r),f(this,k,Ie).call(this,t,e,s))}},Ke=function(t,e,s,n){if(n.size){const r=n.values().next().value,o=b.fromVariables(e);s.assign(r);const c=f(this,k,_s).call(this,t,e,s,r);return c||i(this,wt)?c:(s.clear(),o.apply(),f(this,k,Ke).call(this,t,e,s,ps(n,r)))}return!1},_s=function(t,e,s,n){if(!f(this,k,Je).call(this,t,s,n))return!1;const r=t.union(e);if(f(this,k,Je).call(this,r,s,n))return!0;const o=f(this,k,Ms).call(this,r,s,n);return t=gs(t,s),e=e.difference(o),f(this,k,Ie).call(this,t,e,o)},Je=function(t,e,s){const n=new Set;for(const o of t){const c=this.pro.constraintsBetween(e,o);for(const l of c)n.add(l)}const r=e.value();e.assign(s);for(const o of n)if(o.isSatisfied()!==1)return e.assign(r),!1;return e.assign(r),!0},Ms=function(t,e,s){const n=new Set,r=new Set;for(const c of t)for(const l of this.pro.constraintsBetween(e,c))r.add(l);const o=e.value();e.assign(s);for(const c of r)if(c.isSatisfied()!==1)for(const l of c)n.add(l);return e.assign(o),n.delete(e),n};function gs(d,a){return new Set(d).add(a)}function ps(d,a){const t=new Set(d);return t.delete(a),t}function ji(d){return new Set(d.domain())}var St,A,Qe,Ps,Rs,Ze,Is;class Oi extends F{constructor(t,e=!1){super(t);h(this,A);h(this,St,!1);e&&this.pro.clearAllVariables()}name(){return"Local Changes Ex"}exec(){this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables(),g(this,St,!1);const t=new Set,e=new Set;for(const o of this.pro.variables())(o.isEmpty()?e:t).add(o);this.monitor.initialize();const s=new b,n=f(this,A,Qe).call(this,new Set,t,e),r=this.pro.ratio();return this.monitor.outputDebugString(`Evaluation: ${r}`),n&&(s.setProblem(this.pro),this.monitor.solutionFound(s,r))?!0:n}}St=new WeakMap,A=new WeakSet,Qe=function(t,e,s){for(e=new Set(e),s=new Set(s);;){this.monitor.outputDebugString(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`);const n=this.monitor.check(this.pro.degree());if(n!==null)return g(this,St,!0),n;if(s.size===0)return!0;const r=s.values().next().value,o=f(this,A,Ps).call(this,t,e,r);if(!o||i(this,St))return o;e.add(r),s.delete(r)}},Ps=function(t,e,s){for(const n of s.domain()){const r=b.fromVariables(e);s.assign(n);const o=f(this,A,Rs).call(this,t,e,s);if(o||i(this,St))return o;s.clear(),r.apply()}return!1},Rs=function(t,e,s){if(!f(this,A,Ze).call(this,t,s,s.value()))return!1;const n=t.union(e);if(f(this,A,Ze).call(this,n,s,s.value()))return!0;const r=f(this,A,Is).call(this,n,s,s.value());return t=Ui(t,s),e=e.difference(r),f(this,A,Qe).call(this,t,e,r)},Ze=function(t,e,s){const n=new Set;for(const o of t){const c=this.pro.constraintsBetween(e,o);for(const l of c)n.add(l)}const r=e.value();e.assign(s);for(const o of n)if(o.isSatisfied()!==1)return e.assign(r),!1;return e.assign(r),!0},Is=function(t,e,s){const n=new Set,r=new Set;for(const c of t)for(const l of this.pro.constraintsBetween(e,c))r.add(l);const o=e.value();e.assign(s);for(const c of r)if(c.isSatisfied()!==1)for(const l of c)n.add(l);return e.assign(o),n.delete(e),n};function Ui(d,a){return new Set(d).add(a)}var we,ct,gt,$s,Ts,Ls;class Bi extends F{constructor(t){super(t);h(this,gt);h(this,we,!0);h(this,ct);g(this,ct,new Array(this.pro.constraintSize())),i(this,ct).fill(1)}name(){return"Breakout"}setRandomness(t){g(this,we,t)}exec(){for(const o of this.pro.variables())o.isEmpty()&&o.assign(o.domain().at(0));const t=this.pro.ratio(),e=new b;let s=t;this.monitor.initialize();const n=new b;let r=null;for(;;){const o=this.pro.violatingConstraints(),c=this.pro.ratio();if(this.monitor.outputDebugString(`Evaluation: ${c}`),s<c&&(e.setProblem(this.pro),s=c,this.monitor.solutionFound(e,s)))return!0;if((r=this.monitor.check(c))!==null)break;f(this,gt,$s).call(this,o,n)}return r===!1&&!this.monitor.isTargetAssigned()&&t<s&&(e.apply(),r=!0),r}}we=new WeakMap,ct=new WeakMap,gt=new WeakSet,$s=function(t,e){if(f(this,gt,Ts).call(this,f(this,gt,Ls).call(this,t),e),0<e.size()){const s=i(this,we)?e.random():e.at(0);s.apply(),e.clear(),this.monitor.outputDebugString("	"+s)}else{for(const s of t)i(this,ct)[s.index()]+=1;this.monitor.outputDebugString("Breakout")}},Ts=function(t,e){let s=0;for(const n of t){const r=n.value();let o=0;for(const c of n)o+=(1-c.isSatisfied())*i(this,ct)[c.index()];t:for(const c of n.domain()){if(r===c)continue;n.assign(c);let l=o;for(const u of n)if(l-=(1-u.isSatisfied())*i(this,ct)[u.index()],l<s)continue t;s<l?(s=l,e.clear(),e.addVariable(n,c)):s!==0&&e.addVariable(n,c)}n.assign(r)}},Ls=function(t){const e=new Set;for(const s of t)for(const n of s)e.add(n);return Array.from(e)};var B,Se,pt,js,Os,Us;class Gi extends F{constructor(t){super(t);h(this,pt);h(this,B,[]);h(this,Se,[])}name(){return"GENET"}exec(){if(!f(this,pt,js).call(this))throw new Error;const t=[...Array(i(this,B).length).keys()],e=this.pro.ratio(),s=new b;let n=e;this.monitor.initialize();let r=null;for(;;){const o=this.pro.ratio();if(this.monitor.outputDebugString(`Evaluation: ${o}`),n<o&&(s.setProblem(this.pro),n=o,this.monitor.solutionFound(s,n)))return!0;if((r=this.monitor.check(o))!==null)break;f(this,pt,Os).call(this,t)}return r===!1&&!this.monitor.isTargetAssigned()&&e<n&&(s.apply(),r=!0),r}}B=new WeakMap,Se=new WeakMap,pt=new WeakSet,js=function(){this.monitor.outputDebugString("Start of Network Generation");const t=[];for(const e of this.pro.variables()){if(e.domain().size()===0)return!1;i(this,B).push(new Wi(e))}for(const e of this.pro.constraints())if(e.size()===1){const s=e.at(0),n=i(this,B)[s.index()];for(const r of n){const o=s.value();s.assign(r._value),e.isSatisfied()!==1&&t.push(new ms(e,r)),s.assign(o)}}else{const s=e.at(0),n=e.at(1),r=i(this,B)[s.index()],o=i(this,B)[n.index()];for(const c of r){const l=s.value();s.assign(c._value);for(const u of o){const p=n.value();n.assign(u._value),e.isSatisfied()!==1&&t.push(new ms(e,c,u)),n.assign(p)}s.assign(l)}}for(const e of i(this,B))for(const s of e._neurons)s.lockConnections();return g(this,Se,t),this.monitor.outputDebugString("End of Network Generation"),!0},Os=function(t){let e=!1;for(const s of f(this,pt,Us).call(this,t))i(this,B)[s].setActivityMaximumInput()&&(e=!0);if(e)for(const s of i(this,B))s.applyToVariable();else for(const s of i(this,Se))s.refreshWeight()},Us=function(t){for(let e=t.length;e>1;--e){const s=ts(e),n=t[e-1];t[e-1]=t[s],t[s]=n}return t};var ve,Bt,J,xe,Xe,vs;let Wi=(vs=class{constructor(a){h(this,xe);h(this,ve);h(this,Bt,0);h(this,J,[]);C(this,"_neurons",[]);g(this,ve,a);for(const t of a.domain())this._neurons.push(new Hi(t));f(this,xe,Xe).call(this,ts(this._neurons.length))}applyToVariable(){i(this,ve).assign(this._neurons[i(this,Bt)]._value)}setActivityMaximumInput(){i(this,J).length=0;let a=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const s=this._neurons[e].getInput();a<=s&&(a<s&&(a=s,i(this,J).length=0,t=!1),i(this,J).push(e),i(this,Bt)===e&&(t=!0))}return t||i(this,J).length===0?!1:(f(this,xe,Xe).call(this,i(this,J)[ts(i(this,J).length)]),!0)}[Symbol.iterator](){return this._neurons[Symbol.iterator]()}},ve=new WeakMap,Bt=new WeakMap,J=new WeakMap,xe=new WeakSet,Xe=function(a){for(const t of this._neurons)t._isActive=!1;this._neurons[a]._isActive=!0,g(this,Bt,a)},vs);var vt,Y,G,xs;let ms=(xs=class{constructor(a,t,e=null){h(this,vt);h(this,Y);h(this,G);C(this,"_weight");g(this,vt,a),g(this,Y,t),g(this,G,e),this._weight=a.isSatisfied()-1,i(this,Y).addConnection(this),i(this,G)&&i(this,G).addConnection(this)}getNeuron(a){return a===i(this,Y)?i(this,G):a===i(this,G)?i(this,Y):null}refreshWeight(){!i(this,Y)._isActive||i(this,G)!==null&&!i(this,G)._isActive||(i(this,vt).size()===1?this._weight+=i(this,vt).relation().isSatisfied(i(this,Y)._value)-1:this._weight+=i(this,vt).relation().isSatisfied(i(this,Y)._value,i(this,G)._value)-1)}},vt=new WeakMap,Y=new WeakMap,G=new WeakMap,xs);var ze,Gt,zs;let Hi=(zs=class{constructor(a){h(this,ze,[]);h(this,Gt,[]);C(this,"_value");C(this,"_isActive",!1);this._value=a}addConnection(a){i(this,Gt).push(a)}lockConnections(){g(this,ze,[...i(this,Gt)]),g(this,Gt,null)}getInput(){let a=0;for(const t of i(this,ze)){const e=t.getNeuron(this);a+=t._weight*(e===null||e._isActive?1:0)}return a}},ze=new WeakMap,Gt=new WeakMap,zs);function ts(d){return Math.floor(Math.random()*Math.floor(d))}var Wt,Q,xt,T,zt,yt,x,Bs,es,$e,Gs,Ws,Hs,qs,Ys;class qi extends F{constructor(t){super(t);h(this,x);h(this,Wt,!0);h(this,Q);h(this,xt,new Set);h(this,T,new Set);h(this,zt,[]);h(this,yt,[]);for(const e of this.pro.constraints())i(this,zt).push(new Yi(e)),i(this,yt).push(null);g(this,Q,new Array(this.pro.constraintSize())),i(this,Q).fill(1)}name(){return"SRS3 for Crisp CSPs"}setRandomness(t){g(this,Wt,t)}exec(){for(const r of this.pro.variables())r.isEmpty()&&r.assign(r.domain().at(0));const t=this.pro.degree(),e=new b;let s=t;this.monitor.initialize();let n=null;for(;;){const r=this.pro.violatingConstraints(),o=this.pro.ratio();if(this.monitor.outputDebugString(`Evaluation: ${o}`),s<o&&(e.setProblem(this.pro),s=o,this.monitor.solutionFound(e,s)))return!0;if((n=this.monitor.check(o))!==null)break;for(const l of i(this,zt))l.clear();const c=new Set;for(const l of r){const u=i(this,zt)[l.index()];c.add(u)}f(this,x,Bs).call(this,c)}return n===!1&&!this.monitor.isTargetAssigned()&&t<s&&(e.apply(),n=!0),n}}Wt=new WeakMap,Q=new WeakMap,xt=new WeakMap,T=new WeakMap,zt=new WeakMap,yt=new WeakMap,x=new WeakSet,Bs=function(t){this.monitor.outputDebugString("SRS"),i(this,xt).clear(),i(this,T).clear();for(const e of t)i(this,T).add(e);for(;t.size&&i(this,T).size;){const e=f(this,x,Hs).call(this,i(this,T));i(this,T).delete(e),f(this,x,$e).call(this,e.constraint())?t.delete(e)||(e.parent()&&f(this,x,$e).call(this,e.parent().constraint())?f(this,x,Gs).call(this,e,t):f(this,x,es).call(this,e)):f(this,x,es).call(this,e)}return t.size===0},es=function(t){this.monitor.outputDebugString("Spread"),i(this,xt).add(t);for(const e of f(this,x,Ws).call(this,t))!i(this,xt).has(e)&&!i(this,T).has(e)&&(e.clear(),t.append(e),i(this,T).add(e))},$e=function(t){this.monitor.outputDebugString("Repair"),i(this,Q)[t.index()]+=1;const e=new b;let s=0;for(const n of t){const r=n.value();let o=0;for(const c of n)o+=(1-c.isSatisfied())*i(this,Q)[c.index()];t:for(const c of n.domain()){if(r===c||(n.assign(c),t.isSatisfied()!==1))continue;let l=o;for(const u of n)if(l-=(1-u.isSatisfied())*i(this,Q)[u.index()],l<s)continue t;s<l?(s=l,e.clear(),e.addVariable(n,c)):s!==0&&e.addVariable(n,c)}n.assign(r)}if(0<e.size()){const n=i(this,Wt)?e.random():e.at(0);return n.apply(),this.monitor.outputDebugString("	"+n),!0}return!1},Gs=function(t,e){this.monitor.outputDebugString("Shrink");let s=t,n=!1;for(;;){if(s=s.parent(),e.delete(s)){n=!0;break}if(!s.parent()||!f(this,x,$e).call(this,s.parent().constraint()))break}const r=[];s.getDescendants(r),s.clear();for(const o of r)i(this,T).delete(o),i(this,xt).delete(o);n||i(this,T).add(s)},Ws=function(t){const e=t.constraint(),s=e.index();if(i(this,yt)[s]===null){const n=[];for(const r of e.neighbors())n.push(i(this,zt)[r.index()]);i(this,yt)[s]=n}return i(this,yt)[s]},Hs=function(t){const e=f(this,x,qs).call(this,f(this,x,Ys).call(this,t));return i(this,Wt)?e[Math.floor(Math.random()*e.length)]:e[0]},qs=function(t){let e=Number.MAX_VALUE,s=[];for(const n of t){const r=i(this,Q)[n.constraint().index()];r<e?(e=r,s.length=0,s.push(n)):r===e&&s.push(n)}return s},Ys=function(t){let e=Number.MAX_VALUE,s=[];for(const n of t){const r=n.depth();r<e?(e=r,s.length=0,s.push(n)):r===e&&s.push(n)}return s};var ye,Et,Ht,Dt,ys;let Yi=(ys=class{constructor(a){h(this,ye);h(this,Et,0);h(this,Ht,null);h(this,Dt,[]);g(this,ye,a)}append(a){g(a,Ht,this),g(a,Et,i(this,Et)+1),i(this,Dt).push(a)}clear(){g(this,Ht,null),g(this,Et,0);for(const a of i(this,Dt))a.clear();i(this,Dt).length=0}constraint(){return i(this,ye)}depth(){return i(this,Et)}parent(){return i(this,Ht)}getDescendants(a){a.push(this);for(const t of i(this,Dt))t.getDescendants(a)}},ye=new WeakMap,Et=new WeakMap,Ht=new WeakMap,Dt=new WeakMap,ys);var _,qt,Yt,Ee,L,Kt,Jt,De,ke,Ce,v,Ks,ss,Js,is,Qs,Zs,Xs,ti,ei;class Ki extends F{constructor(t){super(t);h(this,v);h(this,_);h(this,qt,[]);h(this,Yt,new b);h(this,Ee,!0);h(this,L,0);h(this,Kt,!1);h(this,Jt,new Set);h(this,De);h(this,ke,[]);h(this,Ce,!1);g(this,_,[...this.pro.variables()]),g(this,qt,Ge(this.pro,i(this,_))),g(this,De,new Array(this.pro.variableSize())),g(this,ke,this.pro.constraints().filter(e=>e.size()===1))}name(){return"Full Checking for Fuzzy CSPs"}setUsingMinimumRemainingValuesHeuristics(t){g(this,Ee,t)}setIntensivePruning(t){g(this,Ce,t)}exec(){this.monitor.initialize(),g(this,L,0),Oe(i(this,_));let t=null;for(;t===null;){if(!f(this,v,Ks).call(this)){t=!1;break}this.pro.clearAllVariables(),t=f(this,v,ss).call(this,0),i(this,Yt).apply(),g(this,Kt,!1)}return Ue(i(this,_)),t===!0}}_=new WeakMap,qt=new WeakMap,Yt=new WeakMap,Ee=new WeakMap,L=new WeakMap,Kt=new WeakMap,Jt=new WeakMap,De=new WeakMap,ke=new WeakMap,Ce=new WeakMap,v=new WeakSet,Ks=function(){for(const t of i(this,ke)){const e=t.at(0),s=e.value(),n=e.domain(),r=e.solverObject;for(let o=0,c=n.size();o<c;++o)e.assign(n.at(o)),t.degree()<=i(this,L)&&r.prune(o,-1);if(e.assign(s),r.isEmpty())return!1}return!0},ss=function(t,e=1){if(t===this.pro.variableSize()){const c=this.pro.degree();return i(this,Yt).setProblem(this.pro),this.monitor.outputDebugString(`	Evaluation ${c}`),i(this,L)<c&&(g(this,L,c),g(this,Kt,!0),this.monitor.solutionFound(i(this,Yt),c))?!0:this.monitor.check(c)}let s=null;if((s=this.monitor.check())!==null)return s;const n=i(this,_)[i(this,Ee)?Be(i(this,_)):t],r=n.domain(),o=n.solverObject;i(this,De)[t]=n;for(let c=0,l=r.size();c<l;++c){if(o.isPruned(c))continue;n.assign(r.at(c));const u=Math.min(e,f(this,v,ei).call(this,n));if(!(u<=i(this,L))){if(f(this,v,Js).call(this,t,n)&&(s=f(this,v,ss).call(this,t+1,u),s!==null||i(this,Kt)))break;dt(i(this,_),t)}}return s===null&&(dt(i(this,_),t),n.clear()),s},Js=function(t,e){for(const s of i(this,_)){if(!s.isEmpty())continue;const n=f(this,v,is).call(this,e.index(),s.index()),r=s.solverObject,o=s.domain();for(const c of n){const l=c.emptyVariableSize();if(l===1){if(!f(this,v,Qs).call(this,t,s,o,r,c))return!1}else if(i(this,Ce)){if(l===2){if(!f(this,v,Zs).call(this,t,s,o,r,c))return!1}else if(l===3){if(!f(this,v,Xs).call(this,t,s,o,r,c))return!1}else if(l>3&&!f(this,v,ti).call(this,t,s,o,r,c,l))return!1}}}return!0},is=function(t,e){return t<e?i(this,qt)[e][t]:i(this,qt)[t][e]},Qs=function(t,e,s,n,r){for(let o=0,c=s.size();o<c;++o)n.isPruned(o)||(e.assign(s.at(o)),r.degree()<=i(this,L)&&n.prune(o,t));return e.clear(),!n.isEmpty()},Zs=function(t,e,s,n,r){let o=null;for(const u of r)if(u.isEmpty()&&u!==e){o=u;break}const c=o.domain(),l=o.solverObject;t:for(let u=0,p=s.size();u<p;++u)if(!n.isPruned(u)){e.assign(s.at(u));for(let m=0,w=c.size();m<w;++m)if(!l.isPruned(m)&&(o.assign(c.at(m)),r.degree()>i(this,L)))continue t;n.prune(u,t)}return o.clear(),e.clear(),!n.isEmpty()},Xs=function(t,e,s,n,r){let o=null,c=null;for(const w of r)if(w.isEmpty()&&w!==e)if(o===null)o=w;else{c=w;break}const l=o.domain(),u=c.domain(),p=o.solverObject,m=c.solverObject;t:for(let w=0,S=s.size();w<S;++w)if(!n.isPruned(w)){e.assign(s.at(w));for(let N=0,tt=l.size();N<tt;++N)if(!p.isPruned(N)){o.assign(l.at(N));for(let q=0,Ai=u.size();q<Ai;++q)if(!m.isPruned(q)&&(c.assign(u.at(q)),r.degree()>i(this,L)))continue t}n.prune(w,t)}return c.clear(),o.clear(),e.clear(),!n.isEmpty()},ti=function(t,e,s,n,r,o){const c=new Array(o-1);let l=0;for(const p of r)p.isEmpty()&&p!==e&&(c[l++]=p);const u=new Array(c.length);t:for(let p=0,m=s.size();p<m;++p)if(!n.isPruned(p)){e.assign(s.at(p)),u.fill(0);e:for(;;){let w=!1;for(let S=0;S<c.length;++S){const N=c[S].domain();if(c[S].solverObject.isPruned(u[S])){w=!0;break}c[S].assign(N.at(u[S]))}if(!w&&r.degree()>i(this,L))continue t;for(let S=0;S<c.length&&(u[S]+=1,!(u[S]<c[S].domain().size()));++S)if(u[S]=0,S===c.length-1)break e}n.prune(p,t)}for(const p of c)p.clear();return e.clear(),!n.isEmpty()},ei=function(t){let e=Number.MAX_VALUE;i(this,Jt).clear();for(const s of i(this,_)){if(s===t||s.isEmpty())continue;const n=f(this,v,is).call(this,t.index(),s.index());for(const r of n)if(!i(this,Jt).has(r)){const o=r.degree();o!==U.UNDEFINED&&o<e&&(e=o),i(this,Jt).add(r)}}return e};var j,Qt,Zt,Fe,lt,Xt,R,ns,si,ii,ni,ri;class Ji extends F{constructor(t){super(t);h(this,R);h(this,j);h(this,Qt,[]);h(this,Zt,new b);h(this,Fe,!0);h(this,lt,0);h(this,Xt,!1);g(this,j,[...this.pro.variables()]),g(this,Qt,Ge(this.pro,i(this,j)))}name(){return"Forward Checking for Fuzzy CSPs"}setUsingMinimumRemainingValuesHeuristics(t){g(this,Fe,t)}exec(){this.monitor.initialize(),g(this,lt,0),Oe(i(this,j));let t=null;for(;t===null;)this.pro.clearAllVariables(),t=f(this,R,ns).call(this,0),i(this,Zt).apply(),g(this,Xt,!1);return Ue(i(this,j)),t===!0}}j=new WeakMap,Qt=new WeakMap,Zt=new WeakMap,Fe=new WeakMap,lt=new WeakMap,Xt=new WeakMap,R=new WeakSet,ns=function(t,e=1){if(t===this.pro.variableSize()){const c=this.pro.degree();return i(this,Zt).setProblem(this.pro),this.monitor.outputDebugString(`	Evaluation ${c}`),i(this,lt)<c&&(g(this,lt,c),g(this,Xt,!0),this.monitor.solutionFound(i(this,Zt),c))?!0:this.monitor.check(c)}let s=null;if((s=this.monitor.check())!==null)return s;const n=i(this,j)[i(this,Fe)?Be(i(this,j)):t],r=n.domain(),o=n.solverObject;for(let c=0,l=r.size();c<l;++c){if(o.isPruned(c))continue;n.assign(r.at(c));const u=Math.min(e,f(this,R,ri).call(this,n));if(!(u<=i(this,lt))){if(f(this,R,si).call(this,t,n)&&(s=f(this,R,ns).call(this,t+1,u),s!==null||i(this,Xt)))break;dt(i(this,j),t)}}return s===null&&(dt(i(this,j),t),n.clear()),s},si=function(t,e){for(const s of i(this,j)){if(!s.isEmpty())continue;const n=f(this,R,ii).call(this,e.index(),s.index()),r=s.solverObject,o=s.domain();for(const c of n)if(c.emptyVariableSize()===1&&!f(this,R,ni).call(this,t,s,o,r,c))return!1}return!0},ii=function(t,e){return t<e?i(this,Qt)[e][t]:i(this,Qt)[t][e]},ni=function(t,e,s,n,r){for(let o=0,c=s.size();o<c;++o)n.isPruned(o)||(e.assign(s.at(o)),r.degree()<=i(this,lt)&&n.prune(o,t));return e.clear(),!n.isEmpty()},ri=function(t){let e=Number.MAX_VALUE;for(const s of t){const n=s.degree();n!==U.UNDEFINED&&n<e&&(e=n)}return e};var kt,Ct,ht,z,rs,oi,ai,ci,Te,li,hi,ui;class Qi extends F{constructor(t){super(t);h(this,z);h(this,kt,0);h(this,Ct,0);h(this,ht,0);f(this,z,oi).call(this)}name(){return"Flexible Local Changes"}exec(){this.monitor.initialize(),g(this,ht,-1);const t=this.pro.degree();this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const e=new Set,s=new Set,n=new Set;for(const w of this.pro.variables())(w.isEmpty()?n:s).add(w);const r=new Set,o=f(this,z,li).call(this,s,r);let c,l=null;n.size===0?(c=o,l=b.fromVariables(s)):c=i(this,Ct);const u=f(this,z,rs).call(this,s,r).union(n),p=s.difference(u);let m=f(this,z,Te).call(this,e,p,u,i(this,kt),i(this,kt),c);return m<c&&l!==null&&l.apply(),m=this.pro.degree(),m>t&&m>0&&(i(this,ht)!==0||this.targetDeg===null)}}kt=new WeakMap,Ct=new WeakMap,ht=new WeakMap,z=new WeakSet,rs=function(t,e){const s=new Map;for(const o of e)if(o.isDefined())for(const c of o)s.has(c)?s.set(c,(s.get(c)??0)+1):s.set(c,1);const n=[...t];n.sort((o,c)=>{let l=0,u=0;return s.has(o)&&(l=s.get(o)??0),s.has(c)&&(u=s.get(c)??0),l<u?1:l>u?-1:0});const r=new Set;for(const o of n){let c=!1;for(const l of e)if(l.isDefined()){c=!0;break}if(!c)break;o.clear(),r.add(o)}return r},oi=function(){let t=1,e=0;for(const s of this.pro.variables())for(const n of s){const r=n.lowestConsistencyDegree(),o=n.highestConsistencyDegree();r<t&&(t=r),o>e&&(e=o)}g(this,Ct,t),g(this,kt,e)},ai=function(t,e,s,n,r,o,c){const l=f(this,z,rs).call(this,e,o),u=bs(t,s),p=e.difference(l);return f(this,z,Te).call(this,u,p,l,n,Math.min(r,n),c)},ci=function(t,e,s,n,r,o){let c=i(this,Ct);if(s.domain().size()===0)return c;let l=b.fromVariables(e),u=s.domain().at(0);const p=b.fromVariables(e);for(let m=0;m<s.domain().size()&&c<r;++m){const w=s.domain().at(m);s.assign(w);const S=Math.min(n,f(this,z,hi).call(this,t,s,c,o));if(S>Math.max(c,o)){const N=new Set,tt=Math.min(Math.min(S,r),f(this,z,ui).call(this,t,e,s,S,r,N));if(tt>c&&(c=tt,u=w,l=b.fromVariables(e)),N.size){const q=f(this,z,ai).call(this,t,e,s,S,r,N,Math.max(o,c));if(i(this,ht)!==-1)return c;q>c&&(c=q,u=w,l=b.fromVariables(e)),p.apply()}}}return l.apply(),s.assign(u),c},Te=function(t,e,s,n,r,o){{this.monitor.outputDebugString(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`);const c=this.monitor.check(this.pro.degree());if(c!==null)return g(this,ht,c?1:0),r;if(s.size===0)return r;const l=s.values().next().value,u=f(this,z,ci).call(this,t,e,l,n,r,o);return i(this,ht)!==-1?r:u<o?i(this,Ct):(e=bs(e,l),s=Zi(s,l),f(this,z,Te).call(this,t,e,s,n,u,o))}},li=function(t,e){const s=new Set;for(const r of t)for(const o of r)s.add(o);let n=1;for(const r of s){const o=r.degree();o!==U.UNDEFINED&&o<n&&(n=o)}for(const r of this.pro.constraints())r.lowestConsistencyDegree()<i(this,kt)&&e.add(r);return n},hi=function(t,e,s,n){let r=1;const o=new Set;for(const c of t){const l=this.pro.constraintsBetween(c,e);for(const u of l)o.add(u)}for(const c of o){const l=c.degree();if(l!==U.UNDEFINED&&(l<r&&(r=l),r<=s||r<=n))return r}return r},ui=function(t,e,s,n,r,o){let c=1;const l=new Set;for(const u of t){const p=this.pro.constraintsBetween(u,s);for(const m of p)l.add(m)}for(const u of e){const p=this.pro.constraintsBetween(u,s);for(const m of p)l.add(m)}for(const u of l){const p=u.degree();p!==U.UNDEFINED&&p<c&&(c=p)}for(const u of l){const p=u.degree();p!==U.UNDEFINED&&(p<n||p<r)&&o.add(u)}return c};function bs(d,a){return new Set(d).add(a)}function Zi(d,a){const t=new Set(d);return t.delete(a),t}var Ft,Nt,ut,E,os,fi,di,gi,as,pi,mi,bi;class Xi extends F{constructor(t){super(t);h(this,E);h(this,Ft,0);h(this,Nt,0);h(this,ut,0);f(this,E,fi).call(this)}name(){return"Flexible Local Changes Ex"}exec(){this.monitor.initialize(),g(this,ut,-1);const t=this.pro.degree();this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const e=new Set,s=new Set,n=new Set;for(const w of this.pro.variables())(w.isEmpty()?n:s).add(w);const r=new Set,o=f(this,E,pi).call(this,s,r);let c,l=null;n.size===0?(c=o,l=b.fromVariables(s)):c=i(this,Nt);const u=f(this,E,os).call(this,s,r).union(n),p=s.difference(u);let m=f(this,E,as).call(this,e,p,u,i(this,Ft),i(this,Ft),c);return m<c&&l!==null&&l.apply(),m=this.pro.degree(),m>t&&m>0&&(i(this,ut)!==0||this.targetDeg===null)}}Ft=new WeakMap,Nt=new WeakMap,ut=new WeakMap,E=new WeakSet,os=function(t,e){const s=new Map;for(const o of e)if(o.isDefined())for(const c of o)s.has(c)?s.set(c,(s.get(c)??0)+1):s.set(c,1);const n=[...t];n.sort((o,c)=>{let l=0,u=0;return s.has(o)&&(l=s.get(o)??0),s.has(c)&&(u=s.get(c)??0),l<u?1:l>u?-1:0});const r=new Set;for(const o of n){let c=!1;for(const l of e)if(l.isDefined()){c=!0;break}if(!c)break;o.clear(),r.add(o)}return r},fi=function(){let t=1,e=0;for(const s of this.pro.variables())for(const n of s){const r=n.lowestConsistencyDegree(),o=n.highestConsistencyDegree();r<t&&(t=r),o>e&&(e=o)}g(this,Nt,t),g(this,Ft,e)},di=function(t,e,s,n,r,o,c){const l=f(this,E,os).call(this,e,o),u=tn(t,s),p=e.difference(l);return f(this,E,as).call(this,u,p,l,n,Math.min(r,n),c)},gi=function(t,e,s,n,r,o){let c=i(this,Nt);if(s.domain().size()===0)return c;let l=b.fromVariables(e),u=s.domain().at(0);const p=b.fromVariables(e);for(let m=0;m<s.domain().size()&&c<r;++m){const w=s.domain().at(m);s.assign(w);const S=Math.min(n,f(this,E,mi).call(this,t,s,c,o));if(S>Math.max(c,o)){const N=new Set,tt=Math.min(Math.min(S,r),f(this,E,bi).call(this,t,e,s,S,r,N));if(tt>c&&(c=tt,u=w,l=b.fromVariables(e)),N.size){const q=f(this,E,di).call(this,t,e,s,S,r,N,Math.max(o,c));if(i(this,ut)!==-1)return c;q>c&&(c=q,u=w,l=b.fromVariables(e)),p.apply()}}}return l.apply(),s.assign(u),c},as=function(t,e,s,n,r,o){for(e=new Set(e),s=new Set(s);;){this.monitor.outputDebugString(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`);const c=this.monitor.check(this.pro.degree());if(c!==null)return g(this,ut,c?1:0),r;if(s.size===0)return r;const l=s.values().next().value,u=f(this,E,gi).call(this,t,e,l,n,r,o);if(i(this,ut)!==-1)return r;if(u<o)return i(this,Nt);e.add(l),s.delete(l),r=u}},pi=function(t,e){const s=new Set;for(const r of t)for(const o of r)s.add(o);let n=1;for(const r of s){const o=r.degree();o!==U.UNDEFINED&&o<n&&(n=o)}for(const r of this.pro.constraints())r.lowestConsistencyDegree()<i(this,Ft)&&e.add(r);return n},mi=function(t,e,s,n){let r=1;const o=new Set;for(const c of t){const l=this.pro.constraintsBetween(c,e);for(const u of l)o.add(u)}for(const c of o){const l=c.degree();if(l!==U.UNDEFINED&&(l<r&&(r=l),r<=s||r<=n))return r}return r},bi=function(t,e,s,n,r,o){let c=1;const l=new Set;for(const u of t){const p=this.pro.constraintsBetween(u,s);for(const m of p)l.add(m)}for(const u of e){const p=this.pro.constraintsBetween(u,s);for(const m of p)l.add(m)}for(const u of l){const p=u.degree();p!==U.UNDEFINED&&p<c&&(c=p)}for(const u of l){const p=u.degree();p!==U.UNDEFINED&&(p<n||p<r)&&o.add(u)}return c};function tn(d,a){return new Set(d).add(a)}var Ne,ft,mt,wi,Si,vi;class en extends F{constructor(t){super(t);h(this,mt);h(this,Ne,!0);h(this,ft);g(this,ft,new Array(this.pro.constraintSize())),i(this,ft).fill(1)}name(){return"Fuzzy Breakout"}setRandomness(t){g(this,Ne,t)}exec(){for(const o of this.pro.variables())o.isEmpty()&&o.assign(o.domain().at(0));const t=this.pro.degree(),e=new b;let s=t;this.monitor.initialize();const n=new b;let r=null;for(;;){const[o,c]=this.pro.constraintsWithDegree();if(this.monitor.outputDebugString(`Evaluation: ${c}`),s<c&&(e.setProblem(this.pro),s=c,this.monitor.solutionFound(e,s)))return!0;if((r=this.monitor.check(c))!==null)break;f(this,mt,wi).call(this,o,n)}return r===!1&&!this.monitor.isTargetAssigned()&&t<s&&(e.apply(),r=!0),r}}Ne=new WeakMap,ft=new WeakMap,mt=new WeakSet,wi=function(t,e){if(f(this,mt,Si).call(this,f(this,mt,vi).call(this,t),e),0<e.size()){const s=i(this,Ne)?e.random():e.at(0);s.apply(),e.clear(),this.monitor.outputDebugString("	"+s)}else{for(const s of t)i(this,ft)[s.index()]+=1;this.monitor.outputDebugString("Breakout")}},Si=function(t,e){let s=0;for(const n of t){const r=n.value();let o=0;for(const c of n)o+=(1-c.degree())*i(this,ft)[c.index()];t:for(const c of n.domain()){if(r===c)continue;n.assign(c);let l=o;for(const u of n)if(l-=(1-u.degree())*i(this,ft)[u.index()],l<s)continue t;s<l?(s=l,e.clear(),e.addVariable(n,c)):s!==0&&e.addVariable(n,c)}n.assign(r)}},vi=function(t){const e=new Set;for(const s of t)for(const n of s)e.add(n);return Array.from(e)};var W,Ae,te,bt,xi,zi,yi;class sn extends F{constructor(t,e=1){super(t);h(this,bt);h(this,W,[]);h(this,Ae,[]);h(this,te);g(this,te,e)}name(){return"Fuzzy GENET"}exec(){if(!f(this,bt,xi).call(this))throw new Error;const t=[...Array(i(this,W).length).keys()],e=this.pro.degree(),s=new b;let n=e;this.monitor.initialize();let r=null;for(;;){const o=this.pro.degree();if(this.monitor.outputDebugString(`Evaluation: ${o}`),n<o&&(s.setProblem(this.pro),n=o,this.monitor.solutionFound(s,n)))return!0;if((r=this.monitor.check(o))!==null)break;f(this,bt,zi).call(this,t)}return r===!1&&!this.monitor.isTargetAssigned()&&e<n&&(s.apply(),r=!0),r}}W=new WeakMap,Ae=new WeakMap,te=new WeakMap,bt=new WeakSet,xi=function(){this.monitor.outputDebugString("Start of Network Generation");const t=[];for(const e of this.pro.variables()){if(e.domain().size()===0)return!1;i(this,W).push(new nn(e))}for(const e of this.pro.constraints())if(e.size()===1){const s=e.at(0),n=i(this,W)[s.index()];for(const r of n){const o=s.value();s.assign(r._value),e.degree()<=i(this,te)&&t.push(new ws(e,r)),s.assign(o)}}else{const s=e.at(0),n=e.at(1),r=i(this,W)[s.index()],o=i(this,W)[n.index()];for(const c of r){const l=s.value();s.assign(c._value);for(const u of o){const p=n.value();n.assign(u._value),e.degree()<=i(this,te)&&t.push(new ws(e,c,u)),n.assign(p)}s.assign(l)}}for(const e of i(this,W))for(const s of e._neurons)s.lockConnections();return g(this,Ae,t),this.monitor.outputDebugString("End of Network Generation"),!0},zi=function(t){let e=!1;for(const s of f(this,bt,yi).call(this,t))i(this,W)[s].setActivityMaximumInput()&&(e=!0);if(e)for(const s of i(this,W))s.applyToVariable();else for(const s of i(this,Ae))s.refreshWeight()},yi=function(t){for(let e=t.length;e>1;--e){const s=ls(e),n=t[e-1];t[e-1]=t[s],t[s]=n}return t};var Ve,ee,Z,_e,cs;class nn{constructor(a){h(this,_e);h(this,Ve);h(this,ee,0);h(this,Z,[]);C(this,"_neurons",[]);g(this,Ve,a);for(const t of a.domain())this._neurons.push(new rn(t));f(this,_e,cs).call(this,ls(this._neurons.length))}applyToVariable(){i(this,Ve).assign(this._neurons[i(this,ee)]._value)}setActivityMaximumInput(){i(this,Z).length=0;let a=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const s=this._neurons[e].getInput();a<=s&&(a<s&&(a=s,i(this,Z).length=0,t=!1),i(this,Z).push(e),i(this,ee)===e&&(t=!0))}return t||i(this,Z).length===0?!1:(f(this,_e,cs).call(this,i(this,Z)[ls(i(this,Z).length)]),!0)}[Symbol.iterator](){return this._neurons[Symbol.iterator]()}}Ve=new WeakMap,ee=new WeakMap,Z=new WeakMap,_e=new WeakSet,cs=function(a){for(const t of this._neurons)t._isActive=!1;this._neurons[a]._isActive=!0,g(this,ee,a)};var At,K,H;class ws{constructor(a,t,e=null){h(this,At);h(this,K);h(this,H);C(this,"_weight");g(this,At,a),g(this,K,t),g(this,H,e),this._weight=a.degree()-1,i(this,K).addConnection(this),i(this,H)&&i(this,H).addConnection(this)}getNeuron(a){return a===i(this,K)?i(this,H):a===i(this,H)?i(this,K):null}refreshWeight(){!i(this,K)._isActive||i(this,H)!==null&&!i(this,H)._isActive||(i(this,At).size()===1?this._weight+=i(this,At).relation().degree(i(this,K)._value)-1:this._weight+=i(this,At).relation().degree(i(this,K)._value,i(this,H)._value)-1)}}At=new WeakMap,K=new WeakMap,H=new WeakMap;var Me,se;class rn{constructor(a){h(this,Me,[]);h(this,se,[]);C(this,"_value");C(this,"_isActive",!1);this._value=a}addConnection(a){i(this,se).push(a)}lockConnections(){g(this,Me,[...i(this,se)]),g(this,se,null)}getInput(){let a=0;for(const t of i(this,Me)){const e=t.getNeuron(this);a+=t._weight*(e===null||e._isActive?1:0)}return a}}Me=new WeakMap,se=new WeakMap;function ls(d){return Math.floor(Math.random()*Math.floor(d))}var ie,X,Vt,O,_t,Mt,y,Ei,hs,Le,Di,ki,Ci,Fi,Ni;class Ss extends F{constructor(t){super(t);h(this,y);h(this,ie,!0);h(this,X);h(this,Vt,new Set);h(this,O,new Set);h(this,_t,[]);h(this,Mt,[]);for(const e of this.pro.constraints())i(this,_t).push(new on(e)),i(this,Mt).push(null);g(this,X,new Array(this.pro.constraintSize())),i(this,X).fill(1)}name(){return"SRS3"}setRandomness(t){g(this,ie,t)}exec(){for(const r of this.pro.variables())r.isEmpty()&&r.assign(r.domain().at(0));const t=this.pro.degree(),e=new b;let s=t;this.monitor.initialize();let n=null;for(;;){const[r,o]=this.pro.constraintsWithDegree();if(this.monitor.outputDebugString(`Evaluation: ${o}`),s<o&&(e.setProblem(this.pro),s=o,this.monitor.solutionFound(e,s)))return!0;if((n=this.monitor.check(o))!==null)break;for(const l of i(this,_t))l.clear();const c=new Set;for(const l of r){const u=i(this,_t)[l.index()];c.add(u)}f(this,y,Ei).call(this,c)}return n===!1&&!this.monitor.isTargetAssigned()&&t<s&&(e.apply(),n=!0),n}}ie=new WeakMap,X=new WeakMap,Vt=new WeakMap,O=new WeakMap,_t=new WeakMap,Mt=new WeakMap,y=new WeakSet,Ei=function(t){this.monitor.outputDebugString("SRS"),i(this,Vt).clear(),i(this,O).clear();for(const e of t)i(this,O).add(e);for(;t.size&&i(this,O).size;){const e=f(this,y,Ci).call(this,i(this,O));i(this,O).delete(e),f(this,y,Le).call(this,e.constraint())?t.delete(e)||(e.parent()&&f(this,y,Le).call(this,e.parent().constraint())?f(this,y,Di).call(this,e,t):f(this,y,hs).call(this,e)):f(this,y,hs).call(this,e)}return t.size===0},hs=function(t){this.monitor.outputDebugString("Spread"),i(this,Vt).add(t);for(const e of f(this,y,ki).call(this,t))!i(this,Vt).has(e)&&!i(this,O).has(e)&&(e.clear(),t.append(e),i(this,O).add(e))},Le=function(t){this.monitor.outputDebugString("Repair"),i(this,X)[t.index()]+=1;const e=t.degree(),s=new b;let n=0;for(const r of t){const o=r.value();let c=0;for(const l of r)c+=(1-l.degree())*i(this,X)[l.index()];t:for(const l of r.domain()){if(o===l||(r.assign(l),t.degree()<=e))continue;let u=c;for(const p of r)if(u-=(1-p.degree())*i(this,X)[p.index()],u<n)continue t;n<u?(n=u,s.clear(),s.addVariable(r,l)):n!==0&&s.addVariable(r,l)}r.assign(o)}if(0<s.size()){const r=i(this,ie)?s.random():s.at(0);return r.apply(),this.monitor.outputDebugString("	"+r),!0}return!1},Di=function(t,e){this.monitor.outputDebugString("Shrink");let s=t,n=!1;for(;;){if(s=s.parent(),e.delete(s)){n=!0;break}if(!s.parent()||!f(this,y,Le).call(this,s.parent().constraint()))break}const r=[];s.getDescendants(r),s.clear();for(const o of r)i(this,O).delete(o),i(this,Vt).delete(o);n||i(this,O).add(s)},ki=function(t){const e=t.constraint(),s=e.index();if(i(this,Mt)[s]===null){const n=[];for(const r of e.neighbors())n.push(i(this,_t)[r.index()]);i(this,Mt)[s]=n}return i(this,Mt)[s]},Ci=function(t){const e=f(this,y,Fi).call(this,f(this,y,Ni).call(this,t));return i(this,ie)?e[Math.floor(Math.random()*e.length)]:e[0]},Fi=function(t){let e=Number.MAX_VALUE,s=[];for(const n of t){const r=i(this,X)[n.constraint().index()];r<e?(e=r,s.length=0,s.push(n)):r===e&&s.push(n)}return s},Ni=function(t){let e=Number.MAX_VALUE,s=[];for(const n of t){const r=n.depth();r<e?(e=r,s.length=0,s.push(n)):r===e&&s.push(n)}return s};var Pe,Pt,ne,Rt;class on{constructor(a){h(this,Pe);h(this,Pt,0);h(this,ne,null);h(this,Rt,[]);g(this,Pe,a)}append(a){g(a,ne,this),g(a,Pt,i(this,Pt)+1),i(this,Rt).push(a)}clear(){g(this,ne,null),g(this,Pt,0);for(const a of i(this,Rt))a.clear();i(this,Rt).length=0}constraint(){return i(this,Pe)}depth(){return i(this,Pt)}parent(){return i(this,ne)}getDescendants(a){a.push(this);for(const t of i(this,Rt))t.getDescendants(a)}}Pe=new WeakMap,Pt=new WeakMap,ne=new WeakMap,Rt=new WeakMap;function an(d,a,t=e=>console.log(e)){t("Start Post-Stabilization");let e,s=0;do{t("	Post-Stabilization: count "+s++),e=!1;let n=d.degree();const r=d.variables();for(let o=0;o<r.length;++o){const c=r[o],l=c.value(),u=a.at(o);l!==u.value()&&(u.apply(),n<=d.degree()?e=!0:c.assign(l))}}while(e);return t("Finish Post-Stabilization"),e}function cn(d,a){return new ln(d,a)}var re;class ln extends F{constructor(t,e){super(t);h(this,re);g(this,re,e),this.setMonitor(e.getMonitor())}name(){return i(this,re).name()+" + PF"}exec(){let t=0,e=0;this.monitor.isDebugMode()&&(t=this.pro.isFuzzy()?this.pro.degree():this.pro.ratio(),e=this.pro.emptyVariableSize());const s=new b;s.setProblem(this.pro);const n=i(this,re).exec();return n&&an(this.pro,s,this.monitor.outputDebugString.bind(this.monitor)),this.monitor.outputDebugString(`Solver result: ${n?"Success":"Failure"}`),this.monitor.outputDebugString(`Evaluation: ${t} -> ${this.pro.isFuzzy()?this.pro.degree():this.pro.ratio()}`),this.monitor.outputDebugString(`Empty variable size: ${e} -> ${this.pro.emptyVariableSize()}`),n}}re=new WeakMap;class us{static crispSolverNames(){return["Forward Checking","Max Forward Checking","Local Changes","Local Changes Ex","Breakout","GENET","Crisp SRS3"]}static fuzzySolverNames(){return["Full Checking","Fuzzy Forward Checking","Flexible Local Changes","Flexible Local Changes Ex","Fuzzy Breakout","Fuzzy GENET","SRS3","SRS3 PF"]}static async createSolver(a,t){const e=await us.createCrispSolver(a,t);if(e)return e;const s=await us.createFuzzySolver(a,t);return s||null}static async createCrispSolver(a,t){switch(a.replaceAll(" ","")){case"ForwardChecking":case"forward-checking":return new $i(t);case"MaxForwardChecking":case"max-forward-checking":return new Ti(t);case"LocalChanges":case"local-changes":return new Li(t);case"LocalChangesEx":case"local-changes-ex":return new Oi(t);case"Breakout":case"breakout":return new Bi(t);case"GENET":case"genet":return new Gi(t);case"CrispSRS3":case"crisp-srs3":return new qi(t)}return null}static async createFuzzySolver(a,t){switch(a.replaceAll(" ","")){case"FullChecking":case"full-checking":return new Ki(t);case"FuzzyForwardChecking":case"fuzzy-forward-checking":return new Ji(t);case"FlexibleLocalChanges":case"flexible-local-changes":return new Qi(t);case"FlexibleLocalChangesEx":case"flexible-local-changes-ex":return new Xi(t);case"FuzzyBreakout":case"fuzzy-breakout":return new en(t);case"FuzzyGENET":case"fuzzy-genet":return new sn(t);case"SRS3":case"srs3":return new Ss(t);case"SRS3PF":case"SRS3_PF":case"srs3-pf":return cn(t,new Ss(t))}return null}}function pn(d){return new Promise(a=>{const t=setInterval(()=>{d()&&(clearInterval(t),a(null))},100)})}function mn(d="output"){const a=document.getElementById(d);return t=>{a.value+=`${t}
`,setTimeout(()=>a.scrollTo(0,a.scrollHeight),100)}}export{us as S,mn as c,pn as w};
