var C=Object.defineProperty;var O=i=>{throw TypeError(i)};var F=(i,t,e)=>t in i?C(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var c=(i,t,e)=>F(i,typeof t!="symbol"?t+"":t,e),R=(i,t,e)=>t.has(i)||O("Cannot "+e);var s=(i,t,e)=>(R(i,t,"read from private field"),e?e.call(i):t.get(i)),h=(i,t,e)=>t.has(i)?O("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(i):t.set(i,e),r=(i,t,e,o)=>(R(i,t,"write to private field"),o?o.call(i,e):t.set(i,e),e);var A=(i,t,e,o)=>({set _(f){r(i,t,f,e)},get _(){return s(i,t,o)}});var S,E;class X{constructor(){h(this,S,-1);h(this,E,"");c(this,"userObject",null)}setIndex(t){r(this,S,t)}setName(t){r(this,E,t)}index(){return s(this,S)}name(){return s(this,E)}}S=new WeakMap,E=new WeakMap;var p;const g=class g extends X{constructor(e){super();c(this,"d");c(this,"es",[]);c(this,"v",s(g,p));this.d=e}toString(){const e=this.name(),o=e?`(${e})`:"",f=this.isEmpty()?"<empty>":""+this.value();return`x${this.index()}${o} = ${f}`}size(){return this.es.length}at(e){return this.es.at(e)}has(e){return this.es.includes(e)}indexOf(e){return this.es.indexOf(e)}neighbors(){const e=[];for(const o of this.es)for(const f of o)f!==this&&e.push(f);return e}[Symbol.iterator](){return this.es[Symbol.iterator]()}connect(e){if(this.es.includes(e))throw new RangeError;this.es.push(e)}disconnect(e){if(!this.es.includes(e))throw new RangeError;this.es=this.es.filter(o=>o!==e)}domain(e){if(e===void 0)return this.d;this.d=e,this.clear()}assign(e){this.v=e}clear(){this.assign(s(g,p))}value(){return this.v}isEmpty(){return this.value()===s(g,p)}};p=new WeakMap,h(g,p,Number.MIN_VALUE);let T=g;var d,w,x,y,b,u,v,D,M,L,N;class G{constructor(){h(this,d,!0);h(this,w,t=>console.log(t));h(this,x,()=>!1);h(this,y,Number.MAX_SAFE_INTEGER);h(this,b,null);h(this,u,.8);h(this,v,null);h(this,D,0);h(this,M,0);h(this,L,-1);h(this,N,0)}initialize(){r(this,D,s(this,b)===null?Number.MAX_VALUE:Date.now()+s(this,b)),r(this,M,0)}check(t=null){if(t!==null&&s(this,u)!==null&&s(this,u)<=t)return this.outputDebugString("Stop: Current evaluation value is above the target"),!0;if(s(this,y)<A(this,M)._++)return this.outputDebugString("Stop: Number of iterations has reached the limit"),!1;if(s(this,D)<Date.now())return this.outputDebugString("Stop: Time limit has been reached"),!1;if(t!==null&&s(this,v)!==null)if(t!==-1&&s(this,L)===t){if(s(this,v)<A(this,N)._++)return this.outputDebugString("Stop: Evaluation value has not changed for a certain number of times"),!1}else r(this,L,t),r(this,N,0);return null}solutionFound(t,e){return s(this,x).call(this,t,e)}outputDebugString(t){s(this,d)&&s(this,w).call(this,t)}isDebugMode(){return s(this,d)}isTargetAssigned(){return s(this,u)!==null}getTarget(){return s(this,u)}setIterationLimit(t=null){r(this,y,t===null?Number.MAX_SAFE_INTEGER:t)}setTimeLimit(t=null){r(this,b,t)}setTarget(t=null){r(this,u,t)}setSameEvaluationLimit(t=null){r(this,v,t)}setListener(t){r(this,x,t)}setDebugMode(t){r(this,d,t)}setDebugOutput(t){r(this,w,t)}}d=new WeakMap,w=new WeakMap,x=new WeakMap,y=new WeakMap,b=new WeakMap,u=new WeakMap,v=new WeakMap,D=new WeakMap,M=new WeakMap,L=new WeakMap,N=new WeakMap;class k{constructor(){c(this,"pro");c(this,"monitor")}name(){return""}solve(t,e=new G){this.pro=t,this.monitor=e,this.preprocess();const o=this.exec();return this.postprocess(),o}preprocess(){}exec(){return!1}postprocess(){}}var l,a;const I=class I{constructor(t,e=null){h(this,l);h(this,a);if(t instanceof I)r(this,l,t.variable()),r(this,a,t.value());else if(t instanceof T)r(this,l,t),r(this,a,e??t.value());else throw new RangeError}apply(){s(this,l).assign(s(this,a))}toString(){return`v${s(this,l).index()} <- ${s(this,a)}`}value(){return s(this,a)}variable(){return s(this,l)}};l=new WeakMap,a=new WeakMap;let m=I,V=Math.random;function U(i){return console.log(V===Math.random),Math.floor(V()*i)}var n;const $=class ${constructor(){h(this,n,[])}static fromVariables(t){const e=new $;return e.setVariables(t),e}setProblem(t){s(this,n).length=0;for(const e of t.variables())s(this,n).push(new m(e))}setAssignmentList(t){s(this,n).length=0;for(const e of t)s(this,n).push(new m(e))}setVariables(t){s(this,n).length=0;for(const e of t)s(this,n).push(new m(e))}addVariable(t,e=null){s(this,n).push(new m(t,e))}apply(){for(const t of s(this,n))t.apply()}clear(){s(this,n).length=0}isEmpty(){return s(this,n).length===0}size(){return s(this,n).length}differenceSize(){let t=0;for(const e of s(this,n))e.variable().value()!==e.value()&&++t;return t}at(t){return s(this,n)[t]}[Symbol.iterator](){return s(this,n)[Symbol.iterator]()}random(){return s(this,n)[U(s(this,n).length)]}};n=new WeakMap;let z=$;export{z as A,k as S,U as r};
