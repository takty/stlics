var Qi=Object.defineProperty;var Ps=p=>{throw TypeError(p)};var Zi=(p,h,t)=>h in p?Qi(p,h,{enumerable:!0,configurable:!0,writable:!0,value:t}):p[h]=t;var x=(p,h,t)=>Zi(p,typeof h!="symbol"?h+"":h,t),cs=(p,h,t)=>h.has(p)||Ps("Cannot "+t);var i=(p,h,t)=>(cs(p,h,"read from private field"),t?t.call(p):h.get(p)),l=(p,h,t)=>h.has(p)?Ps("Cannot add the same private member more than once"):h instanceof WeakSet?h.add(p):h.set(p,t),f=(p,h,t,e)=>(cs(p,h,"write to private field"),e?e.call(p,t):h.set(p,t),t),d=(p,h,t)=>(cs(p,h,"access private method"),t);var C=(p,h,t,e)=>({set _(s){f(p,h,s,t)},get _(){return i(p,h,e)}});(function(){const h=document.createElement("link").relList;if(h&&h.supports&&h.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))e(s);new MutationObserver(s=>{for(const n of s)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&e(r)}).observe(document,{childList:!0,subtree:!0});function t(s){const n={};return s.integrity&&(n.integrity=s.integrity),s.referrerPolicy&&(n.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?n.credentials="include":s.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function e(s){if(s.ep)return;s.ep=!0;const n=t(s);fetch(s.href,n)}})();var ge,pe;class Xi{constructor(){l(this,ge,-1);l(this,pe,"");x(this,"userObject",null);x(this,"solverObject",null)}setIndex(h){f(this,ge,h)}setName(h){f(this,pe,h)}index(){return i(this,ge)}name(){return i(this,pe)}}ge=new WeakMap,pe=new WeakMap;const ss=class ss extends Xi{constructor(t){super();x(this,"rel");this.rel=t}crispRelation(){return this.rel}fuzzyRelation(){return this.rel}isFuzzy(){return"satisfactionDegree"in this.rel}toString(){const t=this.name(),e=t?`(${t})`:"",s=this.satisfactionDegree(),n=s===ss.UNDEFINED?"UNDEFINED":""+s;return`c${this.index()}${e} = ${n}`}};x(ss,"UNDEFINED",-1);let B=ss;var me,St;class j{constructor(h){x(this,"_debug",!0);l(this,me,h=>console.log(h));x(this,"_pro");x(this,"_iterLimit",null);x(this,"_timeLimit",null);x(this,"_targetDeg",.8);l(this,St,[]);this._pro=h}name(){return""}exec(){return!1}setIterationLimit(h=null){this._iterLimit=h}setTimeLimit(h=null){this._timeLimit=h}setTargetRate(h=null){this._targetDeg=h}solve(){return this.exec()}addListener(h){i(this,St).push(h)}removeListener(h){i(this,St).splice(i(this,St).indexOf(h),1)}foundSolution(h,t){let e=!1;for(const s of i(this,St))s.foundSolution(h,t)&&(e=!0);return e}setDebugMode(h){this._debug=h}setDebugOutput(h){f(this,me,h)}_debugOutput(h){this._debug&&i(this,me).call(this,h)}}me=new WeakMap,St=new WeakMap;var ut,lt;class Ye{constructor(h){l(this,ut);l(this,lt);if("assignment"in h)f(this,ut,h.assignment.variable()),f(this,lt,h.assignment.value());else if("variable"in h)f(this,ut,h.variable),f(this,lt,h.value??h.variable.value());else throw new RangeError}apply(){i(this,ut).assign(i(this,lt))}toString(){return`v${i(this,ut).index()} <- ${i(this,lt)}`}value(){return i(this,lt)}variable(){return i(this,ut)}}ut=new WeakMap,lt=new WeakMap;var y;const Fs=class Fs{constructor(){l(this,y,[])}static fromVariables(h){const t=new Fs;return t.setVariables(h),t}setProblem(h){i(this,y).length=0;for(const t of h.variables())i(this,y).push(new Ye({variable:t,value:t.value()}))}setAssignmentList(h){i(this,y).length=0;for(const t of h)i(this,y).push(new Ye({variable:t.variable(),value:t.value()}))}setVariables(h){i(this,y).length=0;for(const t of h)i(this,y).push(new Ye({variable:t,value:t.value()}))}addVariable(h,t=null){i(this,y).push(new Ye({variable:h,value:t}))}apply(){for(const h of i(this,y))h.apply()}clear(){i(this,y).length=0}isEmpty(){return i(this,y).length===0}size(){return i(this,y).length}differenceSize(){let h=0;for(const t of i(this,y))t.variable().value()!==t.value()&&++h;return h}at(h){return i(this,y)[h]}[Symbol.iterator](){return i(this,y)[Symbol.iterator]()}random(){return i(this,y)[Math.floor(Math.random()*i(this,y).length)]}};y=new WeakMap;let D=Fs;var ft,R,dt;const ct=class ct{constructor(h){l(this,R);l(this,dt,0);f(this,R,new Array(h)),i(this,R).fill(i(ct,ft))}hiddenSize(){return i(this,dt)}hide(h,t){i(this,R)[h]===i(ct,ft)&&++C(this,dt)._,i(this,R)[h]=t}isEmpty(){return i(this,R).length===i(this,dt)}isValueHidden(h){return i(this,R)[h]!==i(ct,ft)}reveal(h){for(let t=0;t<i(this,R).length;++t)i(this,R)[t]===h&&(i(this,R)[t]=i(ct,ft),--C(this,dt)._)}revealAll(){i(this,R).fill(i(ct,ft)),f(this,dt,0)}};ft=new WeakMap,R=new WeakMap,dt=new WeakMap,l(ct,ft,-1);let ce=ct;var A,be,gt,_e,Kt,Jt,F,Ys,Ks,Js,Qs,us;class tn extends j{constructor(t){super(t);l(this,F);l(this,A);l(this,be,new D);l(this,gt,[]);l(this,_e,!1);l(this,Kt,0);l(this,Jt,0);f(this,A,[...this._pro.variables()]);for(const e of i(this,A))e.solverObject=new ce(e.domain().size());d(this,F,Ys).call(this)}name(){return"Forward Checking"}setTargetRate(){}setUsingMinimumRemainingValuesHeuristics(t){f(this,_e,t)}exec(){f(this,Jt,this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit),f(this,Kt,0),this._pro.clearAllVariables();const t=d(this,F,us).call(this,0);t||(this._iterLimit&&this._iterLimit<i(this,Kt)&&this._debugOutput("stop: number of iterations has reached the limit"),i(this,Jt)<Date.now()&&this._debugOutput("stop: time limit has been reached"));for(const e of i(this,be))e.apply(),e.variable().solverObject.revealAll();return t}}A=new WeakMap,be=new WeakMap,gt=new WeakMap,_e=new WeakMap,Kt=new WeakMap,Jt=new WeakMap,F=new WeakSet,Ys=function(){f(this,gt,[]);for(let t=0;t<i(this,A).length;++t){i(this,gt).push(new Array(i(this,A).length));for(let e=0;e<i(this,A).length;++e)e<t&&(i(this,gt)[t][e]=this._pro.constraintsBetween(i(this,A)[e],i(this,A)[t]))}},Ks=function(t,e){return t<e?i(this,gt)[e][t]:i(this,gt)[t][e]},Js=function(t,e){for(const s of i(this,A)){if(!s.isEmpty())continue;const n=s.domain(),r=s.solverObject,o=d(this,F,Ks).call(this,e,s.index());for(const a of o)if(a.emptyVariableSize()===1){for(let c=0,u=n.size();c<u;++c)r.isValueHidden(c)||(s.assign(n.at(c)),a.isSatisfied()===0&&r.hide(c,t));if(s.clear(),r.isEmpty())return!1}}return!0},Qs=function(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<i(this,A).length;++s){const n=i(this,A)[s];if(!n.isEmpty())continue;const o=n.domain().size()-n.solverObject.hiddenSize();o<e&&(e=o,t=s)}return t},us=function(t){if(this._iterLimit&&this._iterLimit<C(this,Kt)._++||i(this,Jt)<Date.now())return!1;if(t===this._pro.variableSize())return i(this,be).setProblem(this._pro),!0;const e=i(this,_e)?d(this,F,Qs).call(this):t,s=i(this,A)[e],n=s.domain(),r=s.solverObject;for(let o=0,a=n.size();o<a;++o)if(!r.isValueHidden(o)){if(s.assign(n.at(o)),d(this,F,Js).call(this,t,e)&&d(this,F,us).call(this,t+1))return!0;for(const c of i(this,A))c.solverObject.reveal(t)}return s.clear(),!1};var W,we,st,Ot,Qt,zt,Zt,Xt,K,ls,Zs,Xs,ti;class en extends j{constructor(t){super(t);l(this,K);l(this,W);l(this,we,new D);l(this,st);l(this,Ot,0);l(this,Qt,new Set);l(this,zt,[]);l(this,Zt,0);l(this,Xt,0);f(this,W,[...this._pro.variables()]);for(const e of i(this,W))e.solverObject=new ce(e.domain().size());f(this,st,this._pro.constraintSize())}name(){return"Forward Checking for Max CSPs"}exec(){f(this,Xt,this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit),f(this,Zt,0),this._pro.clearAllVariables();const t=d(this,K,ls).call(this,0,0);t?this._debugOutput("stop: current degree is above the target"):(this._iterLimit&&this._iterLimit<i(this,Zt)&&this._debugOutput("stop: number of iterations has reached the limit"),i(this,Xt)<Date.now()&&this._debugOutput("stop: time limit has been reached"));for(const e of i(this,we))e.apply(),e.variable().solverObject.revealAll();return t}}W=new WeakMap,we=new WeakMap,st=new WeakMap,Ot=new WeakMap,Qt=new WeakMap,zt=new WeakMap,Zt=new WeakMap,Xt=new WeakMap,K=new WeakSet,ls=function(t,e){if(this._iterLimit&&this._iterLimit<C(this,Zt)._++||i(this,Xt)<Date.now())return!1;const s=this._pro;if(t===s.variableSize()){const a=s.violatingConstraintSize();return a<i(this,st)&&(f(this,st,a),i(this,we).setProblem(this._pro),this._debugOutput(`   refreshed ${i(this,st)}`),(this._targetDeg??1)<=s.satisfiedConstraintRate())}const n=i(this,W)[t],r=n.domain(),o=n.solverObject;for(let a=0,c=r.size();a<c;++a)if(!o.isValueHidden(a)&&(n.assign(r.at(a)),f(this,Ot,e+d(this,K,Xs).call(this,t,n)),!(i(this,Ot)>i(this,st)))){if(d(this,K,Zs).call(this,t)&&d(this,K,ls).call(this,t+1,i(this,Ot)))return!0;for(const u of i(this,W))u.solverObject.reveal(t)}return n.clear(),!1},Zs=function(t){const e=i(this,W)[t];for(let s=t+1;s<i(this,W).length;++s){const n=i(this,W)[s];f(this,zt,this._pro.constraintsBetween(e,n));for(const r of i(this,zt))if(r.emptyVariableSize()===1&&d(this,K,ti).call(this,n,r,t)&&n.solverObject.isEmpty())return!1}return!0},Xs=function(t,e){let s=0;i(this,Qt).clear();for(let n=0;n<t;++n){f(this,zt,this._pro.constraintsBetween(e,i(this,W)[n]));for(const r of i(this,zt))i(this,Qt).has(r)||(r.isSatisfied()===0&&++s,i(this,Qt).add(r))}return s},ti=function(t,e,s){let n=!1;const r=t.domain(),o=t.solverObject;for(let a=0,c=r.size();a<c;++a)o.isValueHidden(a)||(t.assign(r.at(a)),e.isSatisfied()===0&&i(this,Ot)+1>i(this,st)&&(o.hide(a,s),n=!0));return n};var xt,ds,gs,De,xe,it,N,ei,Ke,si,ps,Je;const vt=class vt extends j{constructor(t,e=!1){super(t);l(this,N);l(this,De,0);l(this,xe,0);l(this,it,!1);e&&this._pro.clearAllVariables()}name(){return"Local Changes"}exec(){f(this,xe,this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit),f(this,De,0),f(this,it,!1),this._pro.emptyVariableSize()===0&&this._pro.clearAllVariables();const t=new Set,e=new Set;for(const s of this._pro.variables())(s.isEmpty()?e:t).add(s);return d(this,N,Je).call(this,new Set,t,e)}};xt=new WeakSet,ds=function(t,e){return new Set(t).add(e)},gs=function(t,e){const s=new Set(t);return s.delete(e),s},De=new WeakMap,xe=new WeakMap,it=new WeakMap,N=new WeakSet,ei=function(t,e,s){const n=new Set,r=new Set;for(const a of t){const c=this._pro.constraintsBetween(e,a);for(const u of c)r.add(u)}const o=e.value();e.assign(s);for(const a of r)if(a.isSatisfied()===0)for(const c of a)n.add(c);return e.assign(o),n.delete(e),n},Ke=function(t,e,s){const n=new Set;for(const o of t){const a=this._pro.constraintsBetween(e,o);for(const c of a)n.add(c)}const r=e.value();e.assign(s);for(const o of n)if(o.isSatisfied()===0)return e.assign(r),!1;return e.assign(r),!0},si=function(t,e,s,n){var c;if(!d(this,N,Ke).call(this,t,s,n))return!1;const r=t.union(e);if(d(this,N,Ke).call(this,r,s,n))return!0;const o=d(this,N,ei).call(this,r,s,n),a=r.difference(o);d(this,N,Ke).call(this,a,s,n)||this._debugOutput("bug");for(const u of o)u.clear();return t=d(c=vt,xt,ds).call(c,t,s),e=e.difference(o),d(this,N,Je).call(this,t,e,o)},ps=function(t,e,s,n){var c;if(n.size===0)return!1;const r=n.values().next().value,o=D.fromVariables(e);s.assign(r);const a=d(this,N,si).call(this,t,e,s,r);return a||i(this,it)?a:(s.clear(),o.apply(),d(this,N,ps).call(this,t,e,s,d(c=vt,xt,gs).call(c,n,r)))},Je=function(t,e,s){var a,c;if(this._debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),(this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debugOutput("stop: current degree is above the target"),f(this,it,!0),!0;if(this._iterLimit&&this._iterLimit<C(this,De)._++)return this._debugOutput("stop: number of iterations has reached the limit"),f(this,it,!0),!1;if(i(this,xe)<Date.now())return this._debugOutput("stop: time limit has been reached"),f(this,it,!0),!1;if(s.size===0)return!0;const n=s.values().next().value,r=new Set;for(const u of n.domain())r.add(u);const o=d(this,N,ps).call(this,t,e,n,r);return!o||i(this,it)?o:(e=d(a=vt,xt,ds).call(a,e,n),s=d(c=vt,xt,gs).call(c,s,n),d(this,N,Je).call(this,t,e,s))},l(vt,xt);let fs=vt;var is,ii,ve,Se,nt,I,ni,bs,ri,oi,_s;const ns=class ns extends j{constructor(t,e=!1){super(t);l(this,I);l(this,ve,0);l(this,Se,0);l(this,nt,!1);e&&this._pro.clearAllVariables()}name(){return"Local Changes Ex"}exec(){f(this,Se,this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit),f(this,ve,0),f(this,nt,!1),this._pro.emptyVariableSize()===0&&this._pro.clearAllVariables();const t=new Set,e=new Set;for(const s of this._pro.variables())(s.isEmpty()?e:t).add(s);return d(this,I,_s).call(this,new Set,t,e)}};is=new WeakSet,ii=function(t,e){return new Set(t).add(e)},ve=new WeakMap,Se=new WeakMap,nt=new WeakMap,I=new WeakSet,ni=function(t,e,s){const n=new Set,r=new Set;for(const a of t){const c=this._pro.constraintsBetween(e,a);for(const u of c)r.add(u)}const o=e.value();e.assign(s);for(const a of r)if(a.isSatisfied()===0)for(const c of a)n.add(c);return e.assign(o),n.delete(e),n},bs=function(t,e,s){const n=new Set;for(const o of t){const a=this._pro.constraintsBetween(e,o);for(const c of a)n.add(c)}const r=e.value();e.assign(s);for(const o of n)if(o.isSatisfied()===0)return e.assign(r),!1;return e.assign(r),!0},ri=function(t,e,s){var o;if(!d(this,I,bs).call(this,t,s,s.value()))return!1;const n=t.union(e);if(d(this,I,bs).call(this,n,s,s.value()))return!0;const r=d(this,I,ni).call(this,n,s,s.value());return t=d(o=ns,is,ii).call(o,t,s),e=e.difference(r),d(this,I,_s).call(this,t,e,r)},oi=function(t,e,s){for(const n of s.domain()){const r=D.fromVariables(e);s.assign(n);const o=d(this,I,ri).call(this,t,e,s);if(o||i(this,nt))return o;s.clear(),r.apply()}return!1},_s=function(t,e,s){for(e=new Set(e),s=new Set(s);;){if(this._debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),(this._targetDeg??1)<=this._pro.satisfiedConstraintRate())return this._debugOutput("stop: current degree is above the target"),f(this,nt,!0),!0;if(this._iterLimit&&this._iterLimit<C(this,ve)._++)return this._debugOutput("stop: number of iterations has reached the limit"),f(this,nt,!0),!1;if(i(this,Se)<Date.now())return this._debugOutput("stop: time limit has been reached"),f(this,nt,!0),!1;if(s.size===0)return!0;const n=s.values().next().value,r=d(this,I,oi).call(this,t,e,n);if(!r||i(this,nt))return r;e.add(n),s.delete(n)}},l(ns,is);let ms=ns;var Oe,pt,ue,ai,hi;class sn extends j{constructor(t){super(t);l(this,ue);l(this,Oe,!0);l(this,pt);f(this,pt,new Array(this._pro.constraintSize())),i(this,pt).fill(1)}name(){return"Breakout"}setRandomness(t){f(this,Oe,t)}exec(){const t=this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;for(const r of this._pro.variables())r.isEmpty()&&r.assign(r.domain().at(0));const s=new D,n=this._pro;for(;;){const r=n.violatingConstraints();if((this._targetDeg??1)<=n.satisfiedConstraintRate())return this._debugOutput("stop: current degree is above the target"),!0;if(this._iterLimit&&this._iterLimit<e++)return this._debugOutput("stop: number of iterations has reached the limit"),!1;if(t<Date.now())return this._debugOutput("stop: time limit has been reached"),!1;if(this._debugOutput(r.length+" violations"),d(this,ue,ai).call(this,d(this,ue,hi).call(this,r),s),0<s.size()){const o=i(this,Oe)?s.random():s.at(0);o.apply(),s.clear(),this._debugOutput("	"+o)}else{for(const o of r)i(this,pt)[o.index()]+=1;this._debugOutput("breakout")}}}}Oe=new WeakMap,pt=new WeakMap,ue=new WeakSet,ai=function(t,e){let s=0;for(const n of t){const r=n.value();let o=0;for(const a of n)o+=(1-a.isSatisfied())*i(this,pt)[a.index()];t:for(const a of n.domain()){if(r===a)continue;n.assign(a);let c=o;for(const u of n)if(c-=(1-u.isSatisfied())*i(this,pt)[u.index()],c<s)continue t;c>s?(s=c,e.clear(),e.addVariable(n,a)):s!==0&&e.addVariable(n,a)}n.assign(r)}},hi=function(t){const e=new Set;for(const s of t)for(const n of s)e.add(n);return Array.from(e)};var G,ze,le,ci,ui;const Us=class Us extends j{constructor(t){super(t);l(this,le);l(this,G,[]);l(this,ze,[])}static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}name(){return"GENET"}exec(){if(!d(this,le,ci).call(this))throw new Error;const t=this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;const s=new D,n=[];for(let c=0;c<i(this,G).length;++c)n.push(c);const r=this._pro;let o=r.satisfiedConstraintRate(),a=!1;for(;;){if(this._iterLimit&&this._iterLimit<e++){this._debugOutput("stop: number of iterations has reached the limit");break}if(t<Date.now()){this._debugOutput("stop: time limit has been reached");break}let c=!1;for(const u of d(this,le,ui).call(this,n))i(this,G)[u].setActivityMaximumInput()&&(c=!0);if(c){for(const g of i(this,G))g.applyToVariable();const u=r.satisfiedConstraintRate();if(o<u){if(o=u,this._debugOutput(`satisfied constraint rate: ${u}`),s.setProblem(this._pro),this.foundSolution(s,u)){a=!0;break}if(this._targetDeg??1<=o){this._debugOutput("stop: current degree is above the target"),a=!0;break}}}else for(const u of i(this,ze))u.refreshWeight()}return s.apply(),a}};G=new WeakMap,ze=new WeakMap,le=new WeakSet,ci=function(){this._debugOutput("network creation start");const t=[];for(const e of this._pro.variables()){if(e.domain().size()===0)return!1;i(this,G).push(new nn(e))}for(const e of this._pro.constraints())if(e.size()===1){const s=e.at(0),n=i(this,G)[s.index()];for(let r=0;r<n.size();++r){const o=s.value();s.assign(n.get(r)._value),e.isSatisfied()===0&&t.push(new Hs(n.get(r))),s.assign(o)}}else{const s=e.at(0),n=e.at(1),r=i(this,G)[s.index()],o=i(this,G)[n.index()];for(let a=0;a<r.size();++a){const c=s.value();s.assign(r.get(a)._value);for(let u=0;u<o.size();++u){const g=n.value();n.assign(o.get(u)._value),e.isSatisfied()===0&&t.push(new Hs(r.get(a),o.get(u))),n.assign(g)}s.assign(c)}}for(const e of i(this,G))for(const s of e._neurons)s.lockConnections();return f(this,ze,t),this._debugOutput("network creation complete"),!0},ui=function(t){for(let e=t.length;e>1;--e){const s=Us.nextInt(e),n=t[e-1];t[e-1]=t[s],t[s]=n}return t};let ws=Us;var Ee,te,rt,ye,Ds,Gt;let nn=(Gt=class{constructor(h){l(this,ye);l(this,Ee);l(this,te,0);l(this,rt,[]);x(this,"_neurons",[]);f(this,Ee,h);for(const t of h.domain())this._neurons.push(new rn(t));d(this,ye,Ds).call(this,Gt.nextInt(this._neurons.length))}static nextInt(h){return Math.floor(Math.random()*Math.floor(h))}applyToVariable(){i(this,Ee).assign(this._neurons[i(this,te)]._value)}get(h){return this._neurons[h]}neurons(){return this._neurons}setActivityMaximumInput(){i(this,rt).length=0;let h=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const s=this._neurons[e].getInput();h<=s&&(h<s&&(h=s,i(this,rt).length=0,t=!1),i(this,rt).push(e),i(this,te)===e&&(t=!0))}return t||i(this,rt).length===0?!1:(d(this,ye,Ds).call(this,i(this,rt)[Gt.nextInt(i(this,rt).length)]),!0)}size(){return this._neurons.length}},Ee=new WeakMap,te=new WeakMap,rt=new WeakMap,ye=new WeakSet,Ds=function(h){for(const t of this._neurons)t._isActive=!1;this._neurons[h]._isActive=!0,f(this,te,h)},Gt);var mt,Q,Ws;let Hs=(Ws=class{constructor(h,t=null){l(this,mt);l(this,Q);x(this,"_weight");this._weight=-1,f(this,mt,h),i(this,mt).addConnection(this),f(this,Q,t),i(this,Q)&&i(this,Q).addConnection(this)}getNeuron(h){return h===i(this,mt)?i(this,Q):h===i(this,Q)?i(this,mt):null}refreshWeight(){!i(this,mt)._isActive||i(this,Q)!==null&&!i(this,Q)._isActive||(this._weight+=-1)}},mt=new WeakMap,Q=new WeakMap,Ws);var ee,Ve,Gs;let rn=(Gs=class{constructor(h){l(this,ee,[]);l(this,Ve,[]);x(this,"_value");x(this,"_isActive",!1);this._value=h}addConnection(h){i(this,ee).push(h)}lockConnections(){f(this,Ve,[...i(this,ee)]),f(this,ee,null)}getInput(){let h=0;for(const t of i(this,Ve)){const e=t.getNeuron(this);h+=t._weight*(e===null||e._isActive?1:0)}return h}},ee=new WeakMap,Ve=new WeakMap,Gs);var Le,Et,P,se,yt,k,li,Qe,fi,xs,di;class on extends j{constructor(t){super(t);l(this,k);l(this,Le,!0);l(this,Et,new Set);l(this,P,new Set);l(this,se,[]);l(this,yt,[]);for(const e of this._pro.constraints())i(this,se).push(new an(e)),i(this,yt).push(null)}name(){return"SRS 3 for Crisp CSPs"}setRandomness(t){f(this,Le,t)}exec(){const t=this._pro.violatingConstraints(),e=new Set;for(const s of t){const n=i(this,se)[s.index()];e.add(n)}return d(this,k,di).call(this,e)?!0:e.size===0}}Le=new WeakMap,Et=new WeakMap,P=new WeakMap,se=new WeakMap,yt=new WeakMap,k=new WeakSet,li=function(t){const e=t.index();return i(this,yt)[e]===null&&(i(this,yt)[e]=t.neighbors()),i(this,yt)[e]},Qe=function(t){this._debugOutput("repair");const e=new D;let s=0;for(const n of t){const r=n.value();let o=0;for(const a of n)o+=1-a.isSatisfied();t:for(const a of n.domain()){if(r===a||(n.assign(a),t.isSatisfied()!==1))continue;let c=o;for(const u of n)if(c-=1-u.isSatisfied(),c<s)continue t;c>s?(s=c,e.clear(),e.addVariable(n,a)):s!==0&&e.addVariable(n,a)}n.assign(r)}if(e.size()>0){const n=i(this,Le)?e.random():e.at(0);return n.apply(),this._debugOutput("	"+n),!0}return!1},fi=function(t,e){const s=[];let n=t;for(;;){n=n.parent(),s.length=0,n.getDescendants(s),n.clear();for(const r of e)i(this,P).delete(r),i(this,Et).delete(r);if(e.delete(n)||(i(this,P).add(n),n.parent()!==null&&!d(this,k,Qe).call(this,n.parent().getObject())))break}},xs=function(t){this._debugOutput("spread"),i(this,Et).add(t);for(const e of d(this,k,li).call(this,t.getObject())){const s=i(this,se)[e.index()];!i(this,Et).has(s)&&!i(this,P).has(s)&&(s.clear(),t.add(s),i(this,P).add(s))}},di=function(t){this._debugOutput("srs");const e=this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit;let s=0;i(this,Et).clear(),i(this,P).clear();for(const r of t)i(this,P).add(r);const n=this._pro;for(;t.size&&i(this,P).size;){if((this._targetDeg??1)<=n.satisfiedConstraintRate())return this._debugOutput("stop: current degree is above the target"),!0;if(this._iterLimit&&this._iterLimit<s++)return this._debugOutput("stop: number of iterations has reached the limit"),!1;if(e<Date.now())return this._debugOutput("stop: time limit has been reached"),!1;const r=i(this,P).values().next().value;i(this,P).delete(r),d(this,k,Qe).call(this,r.getObject())?t.delete(r)||(r.parent()!==null&&d(this,k,Qe).call(this,r.parent().getObject())?d(this,k,fi).call(this,r,t):d(this,k,xs).call(this,r)):d(this,k,xs).call(this,r)}return!1};var Vt,Lt,Ne,qs;let an=(qs=class{constructor(h){l(this,Vt,[]);l(this,Lt);l(this,Ne);f(this,Lt,null),f(this,Ne,h)}add(h){f(h,Lt,this),i(this,Vt).push(h)}clear(){for(const h of i(this,Vt))f(h,Lt,null);i(this,Vt).length=0}getDescendants(h){h.push(this);for(const t of i(this,Vt))t.getDescendants(h)}getObject(){return i(this,Ne)}parent(){return i(this,Lt)}},Vt=new WeakMap,Lt=new WeakMap,Ne=new WeakMap,qs);var v,Nt,bt,S,Ct,At,ie,Ce,Z,Ae,kt,ke,b,gi,Ze,Ss,pi,mi,bi,_i,wi,Di,xi,Os,zs,vi;const U=class U extends j{constructor(t,e=null){super(t);l(this,b);l(this,v);l(this,Nt,new D);l(this,bt,[]);l(this,S,0);l(this,Ct,0);l(this,At,0);l(this,ie,!1);l(this,Ce,0);l(this,Z);l(this,Ae);l(this,kt);l(this,ke,!1);f(this,v,[...this._pro.variables()]),f(this,Z,new Array(this._pro.variableSize())),d(this,b,gi).call(this),f(this,kt,new Array(this._pro.constraintSize()));const s=[];for(const n of this._pro.constraints())n.size()===1&&s.push(n);f(this,Ae,[...s]),e&&f(this,S,e)}name(){return"Forward Checking for Fuzzy CSPs"}setUsingMinimumRemainingValuesHeuristics(t){f(this,ie,t)}setIncrementStepOfWorstSatisfactionDegree(t){f(this,Ce,t)}setIntensivePruning(t){f(this,ke,t)}setTargetRate(t=null){if(this._targetDeg=t,this._targetDeg===null)f(this,S,0);else{let e=Number.MIN_VALUE;for(f(this,S,this._targetDeg-e);i(this,S)>=this._targetDeg;)e*=10,f(this,S,this._targetDeg-e)}}exec(){f(this,At,this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit),f(this,Ct,0);for(const e of i(this,v))e.solverObject=new ce(e.domain().size());if(this._pro.clearAllVariables(),!d(this,b,Ss).call(this))return!1;let t=!1;for(;;){if(d(this,b,zs).call(this,0)===U.TERMINATE){if(this._iterLimit&&this._iterLimit<C(this,Ct)._++){this._debugOutput("stop: number of iterations has reached the limit");break}if(i(this,At)<Date.now()){this._debugOutput("stop: time limit has been reached");break}}if(i(this,Nt).isEmpty())break;if(this._debugOutput(`	found a solution: ${i(this,S)}`),this.foundSolution(i(this,Nt),i(this,S))){t=!0;break}if(this._targetDeg===null)t=!0,f(this,S,i(this,S)+i(this,Ce));else if(this._targetDeg<=i(this,S)){this._debugOutput("stop: current degree is above the target"),t=!0;break}for(const s of i(this,v))s.solverObject.revealAll()}i(this,Nt).apply();for(const e of i(this,v))e.solverObject=null;return t}};v=new WeakMap,Nt=new WeakMap,bt=new WeakMap,S=new WeakMap,Ct=new WeakMap,At=new WeakMap,ie=new WeakMap,Ce=new WeakMap,Z=new WeakMap,Ae=new WeakMap,kt=new WeakMap,ke=new WeakMap,b=new WeakSet,gi=function(){f(this,bt,[]);for(let t=0;t<i(this,v).length;++t){i(this,bt).push(new Array(i(this,v).length));for(let e=0;e<i(this,v).length;++e)e<t&&(i(this,bt)[t][e]=this._pro.constraintsBetween(i(this,v)[e],i(this,v)[t]))}},Ze=function(t,e){return t<e?i(this,bt)[e][t]:i(this,bt)[t][e]},Ss=function(){for(const t of i(this,Ae)){const e=t.at(0),s=e.value(),n=e.domain(),r=e.solverObject;for(let o=0,a=n.size();o<a;++o)e.assign(n.at(o)),t.satisfactionDegree()<=i(this,S)&&r.hide(o,-1);if(e.assign(s),r.isEmpty())return!1}return!0},pi=function(t,e,s){const n=e.domain(),r=e.solverObject;for(let o=0,a=n.size();o<a;++o)r.isValueHidden(o)||(e.assign(n.at(o)),s.satisfactionDegree()<=i(this,S)&&r.hide(o,t));return e.clear(),!r.isEmpty()},mi=function(t,e,s){const n=e.domain(),r=e.solverObject;let o=null;for(const u of s)if(u.isEmpty()&&u!==e){o=u;break}const a=o.domain(),c=o.solverObject;t:for(let u=0,g=n.size();u<g;++u)if(!r.isValueHidden(u)){e.assign(n.at(u));for(let m=0,_=a.size();m<_;++m){if(c.isValueHidden(m))continue;if(o.assign(a.at(m)),s.satisfactionDegree()>i(this,S))continue t}r.hide(u,t)}return o.clear(),e.clear(),!r.isEmpty()},bi=function(t,e,s){const n=e.domain(),r=e.solverObject;let o=null,a=null;for(const _ of s)if(_.isEmpty()&&_!==e)if(o===null)o=_;else{a=_;break}const c=o.domain(),u=a.domain(),g=o.solverObject,m=a.solverObject;t:for(let _=0,w=n.size();_<w;++_)if(!r.isValueHidden(_)){e.assign(n.at(_));for(let M=0,ht=c.size();M<ht;++M)if(!g.isValueHidden(M)){o.assign(c.at(M));for(let J=0,Ji=u.size();J<Ji;++J){if(m.isValueHidden(J))continue;if(a.assign(u.at(J)),s.satisfactionDegree()>i(this,S))continue t}}r.hide(_,t)}return a.clear(),o.clear(),e.clear(),!r.isEmpty()},_i=function(t,e,s,n){const r=e.domain(),o=e.solverObject,a=new Array(n-1);let c=0;for(const g of s)g.isEmpty()&&g!==e&&(a[c++]=g);const u=new Array(a.length);t:for(let g=0,m=r.size();g<m;++g)if(!o.isValueHidden(g)){e.assign(r.at(g)),u.fill(0);e:for(;;){let _=!1;for(let w=0;w<a.length;++w){const M=a[w].domain();if(a[w].solverObject.isValueHidden(u[w])){_=!0;break}a[w].assign(M.at(u[w]))}if(!_&&s.satisfactionDegree()>i(this,S))continue t;for(let w=0;w<a.length&&(u[w]+=1,!(u[w]<a[w].domain().size()));++w)if(u[w]=0,w===a.length-1)break e}o.hide(g,t)}for(const g of a)g.clear();return e.clear(),!o.isEmpty()},wi=function(t,e){for(const s of i(this,v)){if(!s.isEmpty())continue;const n=d(this,b,Ze).call(this,e,s.index());for(const r of n){const o=r.emptyVariableSize();if(o===1){if(!d(this,b,pi).call(this,t,s,r))return!1}else if(i(this,ke)){if(o===2){if(!d(this,b,mi).call(this,t,s,r))return!1}else if(o===3){if(!d(this,b,bi).call(this,t,s,r))return!1}else if(o>3&&!d(this,b,_i).call(this,t,s,r,o))return!1}}}return!0},Di=function(t){i(this,kt).fill(!1);for(let e=0;e<i(this,v).length;++e){const s=i(this,v)[e];if(s===t||s.isEmpty())continue;const n=d(this,b,Ze).call(this,t.index(),e);for(const r of n){if(i(this,kt)[r.index()])continue;const o=r.satisfactionDegree();if(o!==B.UNDEFINED&&o<=i(this,S))return!1;i(this,kt)[r.index()]=!0}}return!0},xi=function(){for(let t=0;t<i(this,Z).length;++t){const e=i(this,Z)[t].index();for(let s=t+1;s<i(this,Z).length;++s){const n=i(this,Z)[s],r=d(this,b,Ze).call(this,e,n.index());for(const o of r){const a=n.value(),c=n.domain(),u=n.solverObject;for(let g=0,m=c.size();g<m;++g)u.isValueHidden(g)||(n.assign(c.at(g)),o.satisfactionDegree()<=i(this,S)&&u.hide(g,t));n.assign(a)}}}},Os=function(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<i(this,v).length;++s){const n=i(this,v)[s];if(!n.isEmpty())continue;const o=n.domain().size()-n.solverObject.hiddenSize();o<e&&(e=o,t=s)}return t},zs=function(t){let e=U.CONTINUE;const s=i(this,ie)?d(this,b,Os).call(this):t,n=i(this,v)[s],r=n.domain(),o=n.solverObject;i(this,Z)[t]=n;for(let a=0,c=r.size();a<c;++a){if(o.isValueHidden(a))continue;if(this._iterLimit&&this._iterLimit<C(this,Ct)._++||i(this,At)<Date.now()){e=U.TERMINATE;break}n.assign(r.at(a));for(const g of i(this,v))g.solverObject.reveal(t);if(!d(this,b,Di).call(this,n)||!d(this,b,wi).call(this,t,s))continue;const u=t+1;if(e=u===i(this,v).length-1?d(this,b,vi).call(this,u):d(this,b,zs).call(this,u),e===U.TERMINATE)break}if(e===U.CONTINUE)for(const a of i(this,v))a.solverObject.reveal(t);return n.clear(),e},vi=function(t){let e=U.CONTINUE;const s=i(this,v)[i(this,ie)?d(this,b,Os).call(this):t],n=s.domain(),r=s.solverObject;i(this,Z)[t]=s;for(let o=0,a=n.size();o<a;++o){if(r.isValueHidden(o))continue;if(this._iterLimit&&this._iterLimit<C(this,Ct)._++||i(this,At)<Date.now()){e=U.TERMINATE;break}s.assign(n.at(o));const c=this._pro.worstSatisfactionDegree();if(c>i(this,S)){if(f(this,S,c),i(this,Nt).setProblem(this._pro),e=U.TERMINATE,this._targetDeg!==null&&this._targetDeg<=i(this,S))break;d(this,b,Ss).call(this),d(this,b,xi).call(this)}}return s.clear(),e},x(U,"CONTINUE",0),x(U,"TERMINATE",1);let vs=U;var z,Mt,_t,V,Tt,It,ne,jt,L,Si,Oi,zi,Ei,ys,Vs,yi;const $=class $ extends j{constructor(t,e=null){super(t);l(this,L);l(this,z);l(this,Mt,new D);l(this,_t,[]);l(this,V,0);l(this,Tt,0);l(this,It,0);l(this,ne,!1);l(this,jt,0);f(this,z,[...this._pro.variables()]),d(this,L,Si).call(this),f(this,V,Math.max(0,t.worstSatisfactionDegree())),e&&f(this,V,e)}name(){return"Forward Checking for Fuzzy CSPs of Binary Constraints"}setUsingMinimumRemainingValuesHeuristics(t){f(this,ne,t)}setIncrementStepOfWorstSatisfactionDegree(t){f(this,jt,t)}setTargetRate(t=null){if(this._targetDeg=t,this._targetDeg===null)f(this,V,0);else{let e=Number.MIN_VALUE;for(f(this,V,this._targetDeg-e);i(this,V)>=this._targetDeg;)e*=10,f(this,V,this._targetDeg-e)}}exec(){f(this,It,this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit),f(this,Tt,0);for(const s of i(this,z))s.solverObject=new ce(s.domain().size());this._pro.clearAllVariables();const t=new D;let e=!1;for(;;){if(d(this,L,Vs).call(this,0)===$.TERMINATE){if(this._iterLimit&&this._iterLimit<C(this,Tt)._++){this._debugOutput("stop: number of iterations has reached the limit");break}if(i(this,It)<Date.now()){this._debugOutput("stop: time limit has been reached");break}}if(i(this,Mt).isEmpty())break;if(t.setAssignmentList(i(this,Mt)),i(this,Mt).clear(),this._debugOutput(`	found a solution: ${i(this,V)}`),this.foundSolution(t,i(this,V))){e=!0;break}if(this._targetDeg===null){if(e=!0,i(this,V)+i(this,jt)>1)break;f(this,V,i(this,V)+(i(this,V)+i(this,jt)>1?0:i(this,jt)))}else if(this._targetDeg<=i(this,V)){this._debugOutput("stop: current degree is above the target"),e=!0;break}for(const n of i(this,z))n.solverObject.revealAll()}t.apply();for(const s of i(this,z))s.solverObject=null;return e}};z=new WeakMap,Mt=new WeakMap,_t=new WeakMap,V=new WeakMap,Tt=new WeakMap,It=new WeakMap,ne=new WeakMap,jt=new WeakMap,L=new WeakSet,Si=function(){f(this,_t,[]);for(let t=0;t<i(this,z).length;++t){i(this,_t).push(new Array(i(this,z).length));for(let e=0;e<i(this,z).length;++e)e<t&&(i(this,_t)[t][e]=this._pro.constraintsBetween(i(this,z)[e],i(this,z)[t]))}},Oi=function(t,e){return t<e?i(this,_t)[e][t]:i(this,_t)[t][e]},zi=function(t,e,s){const n=e.domain(),r=e.solverObject;for(let o=0,a=n.size();o<a;++o)r.isValueHidden(o)||(e.assign(n.at(o)),s.satisfactionDegree()<=i(this,V)&&r.hide(o,t));return e.clear(),!r.isEmpty()},Ei=function(t,e){for(const s of i(this,z)){if(!s.isEmpty())continue;const n=d(this,L,Oi).call(this,e,s.index());for(const r of n)if(r.size()===2&&!d(this,L,zi).call(this,t,s,r))return!1}return!0},ys=function(){let t=0,e=Number.MAX_VALUE;for(let s=0;s<i(this,z).length;++s){const n=i(this,z)[s];if(!n.isEmpty())continue;const o=n.domain().size()-n.solverObject.hiddenSize();o<e&&(e=o,t=s)}return t},Vs=function(t){let e=$.CONTINUE;const s=i(this,ne)?d(this,L,ys).call(this):t,n=i(this,z)[s],r=n.domain(),o=n.solverObject;for(let a=0,c=r.size();a<c;++a){if(o.isValueHidden(a))continue;if(this._iterLimit&&this._iterLimit<C(this,Tt)._++||i(this,It)<Date.now()){e=$.TERMINATE;break}n.assign(r.at(a));for(const g of i(this,z))g.solverObject.reveal(t);if(!d(this,L,Ei).call(this,t,s))continue;const u=t+1;if(e=u===i(this,z).length-1?d(this,L,yi).call(this,u):d(this,L,Vs).call(this,u),e===$.TERMINATE)break}if(e===$.CONTINUE)for(const a of i(this,z))a.solverObject.reveal(t);return n.clear(),e},yi=function(t){let e=$.CONTINUE;const s=i(this,z)[i(this,ne)?d(this,L,ys).call(this):t],n=s.domain(),r=s.solverObject;for(let o=0,a=n.size();o<a;++o){if(r.isValueHidden(o))continue;if(this._iterLimit&&this._iterLimit<C(this,Tt)._++||i(this,It)<Date.now()){e=$.TERMINATE;break}s.assign(n.at(o));const c=this._pro.worstSatisfactionDegree();if(c>i(this,V)&&(f(this,V,c),i(this,Mt).setProblem(this._pro),e=$.TERMINATE,this._targetDeg!==null&&this._targetDeg<=i(this,V)))break}return s.clear(),e},x($,"CONTINUE",0),x($,"TERMINATE",1);let Es=$;var qt,Ns,Vi,Rt,Ft,Me,Te,X,O,Cs,Li,Ni,Ci,Xe,Ai,ki,Mi;const Yt=class Yt extends j{constructor(t){super(t);l(this,O);l(this,Rt,0);l(this,Ft,0);l(this,Me,0);l(this,Te,0);l(this,X,0);d(this,O,Li).call(this)}name(){return"Flexible Local Changes"}exec(){f(this,Te,this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit),f(this,Me,0),f(this,X,-1);const t=this._pro.worstSatisfactionDegree();this._pro.emptyVariableSize()===0&&this._pro.clearAllVariables();const e=new Set,s=new Set,n=new Set;for(const _ of this._pro.variables())(_.isEmpty()?n:s).add(_);const r=new Set,o=d(this,O,Ai).call(this,s,r);let a,c=null;n.size===0?(a=o,c=D.fromVariables(s)):a=i(this,Ft);const u=d(this,O,Cs).call(this,s,r).union(n),g=s.difference(u);let m=d(this,O,Xe).call(this,e,g,u,i(this,Rt),i(this,Rt),a);return m<a&&c!==null&&c.apply(),m=this._pro.worstSatisfactionDegree(),m>t&&m>0&&(i(this,X)!==0||this._targetDeg===null)}};qt=new WeakSet,Ns=function(t,e){const s=new Set(t);return s.add(e),s},Vi=function(t,e){const s=new Set(t);return s.delete(e),s},Rt=new WeakMap,Ft=new WeakMap,Me=new WeakMap,Te=new WeakMap,X=new WeakMap,O=new WeakSet,Cs=function(t,e){const s=new Map;for(const o of e)if(o.isDefined())for(const a of o)s.has(a)?s.set(a,(s.get(a)??0)+1):s.set(a,1);const n=[...t];n.sort((o,a)=>{let c=0,u=0;return s.has(o)&&(c=s.get(o)??0),s.has(a)&&(u=s.get(a)??0),c<u?1:c>u?-1:0});const r=new Set;for(const o of n){let a=!1;for(const c of e)if(c.isDefined()){a=!0;break}if(!a)break;o.clear(),r.add(o)}return r},Li=function(){let t=1,e=0;for(const s of this._pro.variables())for(const n of s){const r=n.lowestConsistencyDegree(),o=n.highestConsistencyDegree();r<t&&(t=r),o>e&&(e=o)}f(this,Ft,t),f(this,Rt,e)},Ni=function(t,e,s,n,r,o,a){var m;const c=d(this,O,Cs).call(this,e,o),u=d(m=Yt,qt,Ns).call(m,t,s),g=e.difference(c);return d(this,O,Xe).call(this,u,g,c,n,Math.min(r,n),a)},Ci=function(t,e,s,n,r,o){let a=i(this,Ft);if(s.domain().size()===0)return a;let c=D.fromVariables(e),u=s.domain().at(0);const g=D.fromVariables(e);for(let m=0;m<s.domain().size()&&a<r;++m){const _=s.domain().at(m);s.assign(_);const w=Math.min(n,d(this,O,ki).call(this,t,s,a,o));if(w>Math.max(a,o)){const M=new Set,ht=Math.min(Math.min(w,r),d(this,O,Mi).call(this,t,e,s,w,r,M));if(ht>a&&(a=ht,u=_,c=D.fromVariables(e)),M.size){const J=d(this,O,Ni).call(this,t,e,s,w,r,M,Math.max(o,a));if(i(this,X)!==-1)return a;J>a&&(a=J,u=_,c=D.fromVariables(e)),g.apply()}}}return c.apply(),s.assign(u),a},Xe=function(t,e,s,n,r,o){var u,g;if(this._debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),this._targetDeg!==null&&this._targetDeg<=this._pro.worstSatisfactionDegree())return this._debugOutput("stop: current degree is above the target"),f(this,X,1),r;if(this._iterLimit&&this._iterLimit<C(this,Me)._++)return this._debugOutput("stop: number of iterations has reached the limit"),f(this,X,0),r;if(i(this,Te)<Date.now())return this._debugOutput("stop: time limit has been reached"),f(this,X,0),r;if(s.size===0)return r;const a=s.values().next().value,c=d(this,O,Ci).call(this,t,e,a,n,r,o);return i(this,X)!==-1?r:c<o?i(this,Ft):(e=d(u=Yt,qt,Ns).call(u,e,a),s=d(g=Yt,qt,Vi).call(g,s,a),d(this,O,Xe).call(this,t,e,s,n,c,o))},Ai=function(t,e){const s=new Set;for(const r of t)for(const o of r)s.add(o);let n=1;for(const r of s){const o=r.satisfactionDegree();o!==B.UNDEFINED&&o<n&&(n=o)}for(const r of this._pro.constraints())r.lowestConsistencyDegree()<i(this,Rt)&&e.add(r);return n},ki=function(t,e,s,n){let r=1;const o=new Set;for(const a of t){const c=this._pro.constraintsBetween(a,e);for(const u of c)o.add(u)}for(const a of o){const c=a.satisfactionDegree();if(c!==B.UNDEFINED&&(c<r&&(r=c),r<=s||r<=n))return r}return r},Mi=function(t,e,s,n,r,o){let a=1;const c=new Set;for(const u of t){const g=this._pro.constraintsBetween(u,s);for(const m of g)c.add(m)}for(const u of e){const g=this._pro.constraintsBetween(u,s);for(const m of g)c.add(m)}for(const u of c){const g=u.satisfactionDegree();g!==B.UNDEFINED&&g<a&&(a=g)}for(const u of c){const g=u.satisfactionDegree();g!==B.UNDEFINED&&(g<n||g<r)&&o.add(u)}return a},l(Yt,qt);let Ls=Yt;var rs,Ti,Ut,$t,Ie,je,tt,E,ks,Ii,ji,Ri,Ms,Fi,Ui,$i;const os=class os extends j{constructor(t){super(t);l(this,E);l(this,Ut,0);l(this,$t,0);l(this,Ie,0);l(this,je,0);l(this,tt,0);d(this,E,Ii).call(this)}name(){return"Flexible Local Changes Ex"}exec(){f(this,je,this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit),f(this,Ie,0),f(this,tt,-1);const t=this._pro.worstSatisfactionDegree();this._pro.emptyVariableSize()===0&&this._pro.clearAllVariables();const e=new Set,s=new Set,n=new Set;for(const _ of this._pro.variables())(_.isEmpty()?n:s).add(_);const r=new Set,o=d(this,E,Fi).call(this,s,r);let a,c=null;n.size===0?(a=o,c=D.fromVariables(s)):a=i(this,$t);const u=d(this,E,ks).call(this,s,r).union(n),g=s.difference(u);let m=d(this,E,Ms).call(this,e,g,u,i(this,Ut),i(this,Ut),a);return m<a&&c!==null&&c.apply(),m=this._pro.worstSatisfactionDegree(),m>t&&m>0&&(i(this,tt)!==0||this._targetDeg===null)}};rs=new WeakSet,Ti=function(t,e){const s=new Set(t);return s.add(e),s},Ut=new WeakMap,$t=new WeakMap,Ie=new WeakMap,je=new WeakMap,tt=new WeakMap,E=new WeakSet,ks=function(t,e){const s=new Map;for(const o of e)if(o.isDefined())for(const a of o)s.has(a)?s.set(a,(s.get(a)??0)+1):s.set(a,1);const n=[...t];n.sort((o,a)=>{let c=0,u=0;return s.has(o)&&(c=s.get(o)??0),s.has(a)&&(u=s.get(a)??0),c<u?1:c>u?-1:0});const r=new Set;for(const o of n){let a=!1;for(const c of e)if(c.isDefined()){a=!0;break}if(!a)break;o.clear(),r.add(o)}return r},Ii=function(){let t=1,e=0;for(const s of this._pro.variables())for(const n of s){const r=n.lowestConsistencyDegree(),o=n.highestConsistencyDegree();r<t&&(t=r),o>e&&(e=o)}f(this,$t,t),f(this,Ut,e)},ji=function(t,e,s,n,r,o,a){var m;const c=d(this,E,ks).call(this,e,o),u=d(m=os,rs,Ti).call(m,t,s),g=e.difference(c);return d(this,E,Ms).call(this,u,g,c,n,Math.min(r,n),a)},Ri=function(t,e,s,n,r,o){let a=i(this,$t);if(s.domain().size()===0)return a;let c=D.fromVariables(e),u=s.domain().at(0);const g=D.fromVariables(e);for(let m=0;m<s.domain().size()&&a<r;++m){const _=s.domain().at(m);s.assign(_);const w=Math.min(n,d(this,E,Ui).call(this,t,s,a,o));if(w>Math.max(a,o)){const M=new Set,ht=Math.min(Math.min(w,r),d(this,E,$i).call(this,t,e,s,w,r,M));if(ht>a&&(a=ht,u=_,c=D.fromVariables(e)),M.size){const J=d(this,E,ji).call(this,t,e,s,w,r,M,Math.max(o,a));if(i(this,tt)!==-1)return a;J>a&&(a=J,u=_,c=D.fromVariables(e)),g.apply()}}}return c.apply(),s.assign(u),a},Ms=function(t,e,s,n,r,o){for(e=new Set(e),s=new Set(s);;){if(this._debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${s.size}`),this._targetDeg!==null&&this._targetDeg<=this._pro.worstSatisfactionDegree())return this._debugOutput("stop: current degree is above the target"),f(this,tt,1),r;if(this._iterLimit&&this._iterLimit<C(this,Ie)._++)return this._debugOutput("stop: number of iterations has reached the limit"),f(this,tt,0),r;if(i(this,je)<Date.now())return this._debugOutput("stop: time limit has been reached"),f(this,tt,0),r;if(s.size===0)return r;const a=s.values().next().value,c=d(this,E,Ri).call(this,t,e,a,n,r,o);if(i(this,tt)!==-1)return r;if(c<o)return i(this,$t);e.add(a),s.delete(a),r=c}},Fi=function(t,e){const s=new Set;for(const r of t)for(const o of r)s.add(o);let n=1;for(const r of s){const o=r.satisfactionDegree();o!==B.UNDEFINED&&o<n&&(n=o)}for(const r of this._pro.constraints())r.lowestConsistencyDegree()<i(this,Ut)&&e.add(r);return n},Ui=function(t,e,s,n){let r=1;const o=new Set;for(const a of t){const c=this._pro.constraintsBetween(a,e);for(const u of c)o.add(u)}for(const a of o){const c=a.satisfactionDegree();if(c!==B.UNDEFINED&&(c<r&&(r=c),r<=s||r<=n))return r}return r},$i=function(t,e,s,n,r,o){let a=1;const c=new Set;for(const u of t){const g=this._pro.constraintsBetween(u,s);for(const m of g)c.add(m)}for(const u of e){const g=this._pro.constraintsBetween(u,s);for(const m of g)c.add(m)}for(const u of c){const g=u.satisfactionDegree();g!==B.UNDEFINED&&g<a&&(a=g)}for(const u of c){const g=u.satisfactionDegree();g!==B.UNDEFINED&&(g<n||g<r)&&o.add(u)}return a},l(os,rs);let As=os;var Re,wt,re,fe,Pi,Hi;class hn extends j{constructor(t){super(t);l(this,fe);l(this,Re,!0);l(this,wt);l(this,re,0);f(this,wt,new Array(this._pro.constraintSize())),i(this,wt).fill(1)}name(){return"Fuzzy Breakout"}setRandomness(t){f(this,Re,t)}exec(){const t=this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;for(const o of this._pro.variables())o.isEmpty()&&o.assign(o.domain().at(0));const s=this._pro.worstSatisfactionDegree(),n=new D,r=new D;for(;;){const[o,a]=this._pro.constraintsWithWorstSatisfactionDegree();if(this._debugOutput(`worst satisfaction degree: ${a}`),this._targetDeg&&this._targetDeg<=a)return this._debugOutput("stop: current degree is above the target"),!0;if(this._iterLimit&&this._iterLimit<e++){this._debugOutput("stop: number of iterations has reached the limit");break}if(t<Date.now()){this._debugOutput("stop: time limit has been reached");break}if(i(this,re)<a&&(r.setProblem(this._pro),f(this,re,a),this.foundSolution(r,i(this,re))))return!0;if(d(this,fe,Pi).call(this,d(this,fe,Hi).call(this,o),n),0<n.size()){const c=i(this,Re)?n.random():n.at(0);c.apply(),n.clear(),this._debugOutput("	"+c)}else{for(const c of o)i(this,wt)[c.index()]+=1;this._debugOutput("breakout")}}return this._targetDeg===null&&s<this._pro.worstSatisfactionDegree()}}Re=new WeakMap,wt=new WeakMap,re=new WeakMap,fe=new WeakSet,Pi=function(t,e){let s=0;for(const n of t){const r=n.value();let o=0;for(const a of n)o+=(1-a.satisfactionDegree())*i(this,wt)[a.index()];t:for(const a of n.domain()){if(r===a)continue;n.assign(a);let c=o;for(const u of n)if(c-=(1-u.satisfactionDegree())*i(this,wt)[u.index()],c<s)continue t;c>s?(s=c,e.clear(),e.addVariable(n,a)):s!==0&&e.addVariable(n,a)}n.assign(r)}},Hi=function(t){const e=new Set;for(const s of t)for(const n of s)e.add(n);return Array.from(e)};var q,Fe,Ue,de,Bi,Wi;const $s=class $s extends j{constructor(t,e=1){super(t);l(this,de);l(this,q,[]);l(this,Fe,[]);l(this,Ue);f(this,Ue,e)}static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}name(){return"Fuzzy GENET"}exec(){if(!d(this,de,Bi).call(this,i(this,Ue)))throw new Error;const t=this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit;let e=0;const s=new D,n=[];for(let a=0;a<i(this,q).length;++a)n.push(a);let r=this._pro.worstSatisfactionDegree(),o=!1;for(;;){if(this._iterLimit&&this._iterLimit<e++){this._debugOutput("stop: number of iterations has reached the limit");break}if(t<Date.now()){this._debugOutput("stop: time limit has been reached");break}let a=!1;for(const c of d(this,de,Wi).call(this,n))i(this,q)[c].setActivityMaximumInput()&&(a=!0);if(a){for(const u of i(this,q))u.applyToVariable();const c=this._pro.worstSatisfactionDegree();if(r<c){if(r=c,this._debugOutput(`worst satisfaction degree: ${c}`),s.setProblem(this._pro),this.foundSolution(s,c)){o=!0;break}if(this._targetDeg===null)o=!0;else if(this._targetDeg<=r){this._debugOutput("stop: current degree is above the target"),o=!0;break}}}else{for(const c of i(this,Fe))c.refreshWeight();continue}}return s.apply(),o}};q=new WeakMap,Fe=new WeakMap,Ue=new WeakMap,de=new WeakSet,Bi=function(t){this._debugOutput("network creation start");const e=[];for(const s of this._pro.variables()){if(s.domain().size()===0)return!1;i(this,q).push(new Is(s))}for(const s of this._pro.constraints())if(s.size()===1){const n=s.at(0),r=i(this,q)[n.index()];for(let o=0;o<r.size();++o){const a=n.value();n.assign(r.get(o)._value),s.satisfactionDegree()<=t&&e.push(new Bs(s,r.get(o))),n.assign(a)}}else{const n=s.at(0),r=s.at(1),o=i(this,q)[n.index()],a=i(this,q)[r.index()];for(let c=0;c<o.size();++c){const u=n.value();n.assign(o.get(c)._value);for(let g=0;g<a.size();++g){const m=r.value();r.assign(a.get(g)._value),s.satisfactionDegree()<=t&&e.push(new Bs(s,o.get(c),a.get(g))),r.assign(m)}n.assign(u)}}for(const s of i(this,q))for(const n of s._neurons)n.lockConnections();return f(this,Fe,e),this._debugOutput("network creation complete"),!0},Wi=function(t){for(let e=t.length;e>1;--e){const s=$s.nextInt(e),n=t[e-1];t[e-1]=t[s],t[s]=n}return t};let Ts=$s;var $e,oe,ot,Pe,js;const as=class as{constructor(h){l(this,Pe);l(this,$e);l(this,oe,0);l(this,ot,[]);x(this,"_neurons",[]);f(this,$e,h);for(const t of h.domain())this._neurons.push(new cn(t));d(this,Pe,js).call(this,as.nextInt(this._neurons.length))}static nextInt(h){return Math.floor(Math.random()*Math.floor(h))}applyToVariable(){i(this,$e).assign(this._neurons[i(this,oe)]._value)}get(h){return this._neurons[h]}neurons(){return this._neurons}setActivityMaximumInput(){i(this,ot).length=0;let h=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const s=this._neurons[e].getInput();h<=s&&(h<s&&(h=s,i(this,ot).length=0,t=!1),i(this,ot).push(e),i(this,oe)===e&&(t=!0))}return t||i(this,ot).length===0?!1:(d(this,Pe,js).call(this,i(this,ot)[as.nextInt(i(this,ot).length)]),!0)}size(){return this._neurons.length}};$e=new WeakMap,oe=new WeakMap,ot=new WeakMap,Pe=new WeakSet,js=function(h){for(const t of this._neurons)t._isActive=!1;this._neurons[h]._isActive=!0,f(this,oe,h)};let Is=as;var Pt,et,Y;class Bs{constructor(h,t,e=null){l(this,Pt);l(this,et);l(this,Y);x(this,"_weight");this._weight=h.satisfactionDegree()-1,f(this,Pt,h),f(this,et,t),i(this,et).addConnection(this),f(this,Y,e),i(this,Y)!==null&&i(this,Y).addConnection(this)}getNeuron(h){return h===i(this,et)?i(this,Y):h===i(this,Y)?i(this,et):null}refreshWeight(){!i(this,et)._isActive||i(this,Y)!==null&&!i(this,Y)._isActive||(i(this,Pt).size()===1?this._weight+=i(this,Pt).fuzzyRelation().satisfactionDegree(i(this,et)._value)-1:this._weight+=i(this,Pt).fuzzyRelation().satisfactionDegree(i(this,et)._value,i(this,Y)._value)-1)}}Pt=new WeakMap,et=new WeakMap,Y=new WeakMap;var ae,He;class cn{constructor(h){l(this,ae,[]);l(this,He,[]);x(this,"_value");x(this,"_isActive",!1);this._value=h}addConnection(h){i(this,ae).push(h)}lockConnections(){f(this,He,[...i(this,ae)]),f(this,ae,null)}getInput(){let h=0;for(const t of i(this,He)){const e=t.getNeuron(this);h+=t._weight*(e===null||e._isActive?1:0)}return h}}ae=new WeakMap,He=new WeakMap;var Ht,H,he,Bt,at,Be,We,Ge,T,Gi,ts,qi,Yi,Ki;const hs=class hs extends j{constructor(t){super(t);l(this,T);l(this,Ht,new Set);l(this,H,new Set);l(this,he,[]);l(this,Bt,[]);l(this,at,new Set);l(this,Be,0);l(this,We,0);l(this,Ge,!0);for(const e of this._pro.constraints())i(this,he).push(new un(e)),i(this,Bt).push(null)}name(){return"SRS 3"}exec(){if(f(this,We,this._timeLimit===null?Number.MAX_VALUE:Date.now()+this._timeLimit),f(this,Be,0),this._targetDeg&&this._targetDeg<=this._pro.worstSatisfactionDegree())return!0;const t=new D;let e=!1;for(;!(!d(this,T,Ki).call(this)||i(this,at).size);){const n=this._pro.worstSatisfactionDegree();if(n!==-1){if(this._debugOutput(`	found a solution: ${n}	${this._targetDeg}`),t.setProblem(this._pro),this.foundSolution(t,n)){e=!0;break}if(this._targetDeg===null)e=!0;else if(this._targetDeg<=n){this._debugOutput("stop: current degree is above the target"),e=!0;break}}}return e}setRandomness(t){f(this,Ge,t)}};Ht=new WeakMap,H=new WeakMap,he=new WeakMap,Bt=new WeakMap,at=new WeakMap,Be=new WeakMap,We=new WeakMap,Ge=new WeakMap,T=new WeakSet,Gi=function(t){const e=t.index();return i(this,Bt)[e]===null&&(i(this,Bt)[e]=t.neighbors()),i(this,Bt)[e]},ts=function(t){this._debugOutput("repair");const e=new D,s=t.satisfactionDegree(),n=this._pro.worstSatisfactionDegree();let r=t.satisfactionDegree();for(const o of t){const a=o.value();t:for(const c of o.domain()){if(a===c)continue;o.assign(c);const u=t.satisfactionDegree();if(!(s>u||r-u>hs.REPAIR_THRESHOLD)){for(const g of o){if(g===t)continue;const m=g.satisfactionDegree();if(m!==B.UNDEFINED&&m<n)continue t}u>r&&(r=u,e.clear()),e.addVariable(o,c)}}o.assign(a)}if(e.size()>0){const o=i(this,Ge)?e.random():e.at(0);return o.apply(),this._debugOutput("	"+o),!0}return!1},qi=function(t){this._debugOutput("shrink");let e=!1;for(;;){if(t=t.parent(),i(this,at).delete(t)){e=!0;break}if(!d(this,T,ts).call(this,t.parent().getObject()))break}const s=[];t.getDescendants(s);for(const n of s)n.clear(),i(this,H).delete(n),i(this,Ht).delete(n);e||i(this,H).add(t)},Yi=function(t){this._debugOutput("spread"),i(this,Ht).add(t);for(const e of d(this,T,Gi).call(this,t.getObject())){const s=i(this,he)[e.index()];!i(this,Ht).has(s)&&!i(this,H).has(s)&&(t.add(s),i(this,H).add(s))}},Ki=function(){this._debugOutput("srs");const[t]=this._pro.constraintsWithWorstSatisfactionDegree();for(const e of t){const s=i(this,he)[e.index()];s.setParent(null),i(this,at).add(s)}i(this,Ht).clear(),i(this,H).clear();for(const e of i(this,at))i(this,H).add(e);for(;i(this,at).size&&i(this,H).size;){if(this._iterLimit&&this._iterLimit<C(this,Be)._++)return this._debugOutput("stop: number of iterations has reached the limit"),!1;if(i(this,We)<Date.now())return this._debugOutput("stop: time limit has been reached"),!1;const e=i(this,H).values().next().value;if(i(this,H).delete(e),d(this,T,ts).call(this,e.getObject())){if(i(this,at).delete(e))continue;if(d(this,T,ts).call(this,e.parent().getObject())){d(this,T,qi).call(this,e);continue}}d(this,T,Yi).call(this,e)}return!0},x(hs,"REPAIR_THRESHOLD",0);let es=hs;var Wt,Dt,qe;class un{constructor(h){l(this,Wt,[]);l(this,Dt);l(this,qe);f(this,Dt,null),f(this,qe,h)}add(h){f(h,Dt,this),i(this,Wt).push(h)}clear(){for(const h of i(this,Wt))f(h,Dt,null);i(this,Wt).length=0}getDescendants(h){h.push(this);for(const t of i(this,Wt))t.getDescendants(h)}getObject(){return i(this,qe)}parent(){return i(this,Dt)}setParent(h){f(this,Dt,h)}}Wt=new WeakMap,Dt=new WeakMap,qe=new WeakMap;class ln{static apply(h,t){console.log("start post-stabilization");let e,s=0;do{console.log("post-stabilization: count "+s++),e=!1;let n=h.worstSatisfactionDegree();const r=h.variables();for(let o=0;o<r.length;++o){const a=r[o],c=a.value(),u=t.at(o);c!==u.value()&&(u.apply(),h.worstSatisfactionDegree()>=n?e=!0:a.assign(c))}}while(e);return console.log("finish post-stabilization"),!0}}class fn extends es{constructor(h){super(h)}name(){return"SRS 3 + PF"}exec(){let h=0,t=0;this._debug&&(h=this._pro.worstSatisfactionDegree(),t=this._pro.emptyVariableSize());const e=new D;e.setProblem(this._pro);const s=super.exec();return s&&ln.apply(this._pro,e),this._debugOutput(`result: ${s?"success":"failure"}`),this._debugOutput(`satisfaction degree: ${h} -> ${this._pro.worstSatisfactionDegree()}`),this._debugOutput(`unassigned size: ${t} -> ${this._pro.emptyVariableSize()}`),s}}class Rs{static crispSolverNames(){return["Forward Checking","Max Forward Checking","Local Changes","Local Changes Ex","Breakout","GENET","Crisp SRS 3"]}static fuzzySolverNames(){return["Fuzzy Forward Checking","Fuzzy Forward Checking Bc","Flexible Local Changes","Flexible Local Changes Ex","Fuzzy Breakout","Fuzzy GENET","SRS 3","SRS 3 PF"]}static async createSolver(h,t){const e=await Rs.createCrispSolver(h,t);if(e)return e;const s=await Rs.createFuzzySolver(h,t);return s||null}static async createCrispSolver(h,t){switch(h.replaceAll(" ","")){case"ForwardChecking":case"forward-checking":return new tn(t);case"MaxForwardChecking":case"max-forward-checking":return new en(t);case"LocalChanges":case"local-changes":return new fs(t);case"LocalChangesEx":case"local-changes-ex":return new ms(t);case"Breakout":case"breakout":return new sn(t);case"GENET":case"genet":return new ws(t);case"CrispSRS3":case"crisp-srs3":return new on(t)}return null}static async createFuzzySolver(h,t){switch(h.replaceAll(" ","")){case"FuzzyForwardChecking":case"fuzzy-forward-checking":return new vs(t);case"FuzzyForwardCheckingBc":case"fuzzy-forward-checking-bc":return new Es(t);case"FlexibleLocalChanges":case"flexible-local-changes":return new Ls(t);case"FlexibleLocalChangesEx":case"flexible-local-changes-ex":return new As(t);case"FuzzyBreakout":case"fuzzy-breakout":return new hn(t);case"FuzzyGENET":case"fuzzy-genet":return new Ts(t);case"SRS3":case"srs3":return new es(t);case"SRS3PF":case"SRS3_PF":case"srs3-pf":return new fn(t)}return null}}function _n(p){return new Promise(h=>{const t=setInterval(()=>{p()&&(clearInterval(t),h(null))},100)})}function wn(p="output"){const h=document.getElementById(p);return t=>{h.value+=`${t}
`,setTimeout(()=>h.scrollTo(0,h.scrollHeight),100)}}export{Rs as S,wn as c,_n as w};
