var L=e=>{throw TypeError(e)};var E=(e,s,o)=>s.has(e)||L("Cannot "+o);var m=(e,s,o)=>(E(e,s,"read from private field"),o?o.call(e):s.get(e)),w=(e,s,o)=>s.has(e)?L("Cannot add the same private member more than once"):s instanceof WeakSet?s.add(e):s.set(e,o),x=(e,s,o,n)=>(E(e,s,"write to private field"),n?n.call(e,o):s.set(e,o),o),g=(e,s,o)=>(E(e,s,"access private method"),o);var V=(e,s,o,n)=>({set _(t){x(e,s,t,o)},get _(){return m(e,s,n)}});import{S as O,A as b}from"./assignment-list-CBFmm8gu.js";import"./worker-J9DKfxdF.js";function P(e){let s=1,o=0;for(const n of e.constraints()){const t=B(n),i=q(n);t<s&&(s=t),o<i&&(o=i)}return[s,o]}function q(e){const s=e.size();return s===1?G(e):s===2?J(e):s===3?Q(e):W(e)}function B(e){const s=e.size();return s===1?I(e):s===2?K(e):s===3?U(e):Y(e)}function G(e){const s=e.degree();if(0<=s)return s;const o=e.at(0);let n=0;for(const t of o.domain()){const i=e.relation().degree(t);if(n<i&&(n=i),n===1)return 1}return n}function I(e){const s=e.degree();if(0<=s)return s;const o=e.at(0);let n=1;for(const t of o.domain()){const i=e.relation().degree(t);if(i<n&&(n=i),n===0)return 0}return n}function J(e){const s=e.degree();if(0<=s)return s;const o=e.at(0),n=e.at(1),t=o.isEmpty()?o.domain():[o.value()],i=n.isEmpty()?n.domain():[n.value()];let f=0;for(const c of t)for(const r of i){const a=e.relation().degree(c,r);if(f<a&&(f=a),f===1)return 1}return f}function K(e){const s=e.degree();if(0<=s)return s;const o=e.at(0),n=e.at(1),t=o.isEmpty()?o.domain():[o.value()],i=n.isEmpty()?n.domain():[n.value()];let f=1;for(const c of t)for(const r of i){const a=e.relation().degree(c,r);if(a<f&&(f=a),f===0)return 0}return f}function Q(e){const s=e.degree();if(0<=s)return s;const o=e.at(0),n=e.at(1),t=e.at(2),i=o.isEmpty()?o.domain():[o.value()],f=n.isEmpty()?n.domain():[n.value()],c=t.isEmpty()?t.domain():[t.value()];let r=0;for(const a of i)for(const l of f)for(const u of c){const h=e.relation().degree(a,l,u);if(r<h&&(r=h),r===1)return 1}return r}function U(e){const s=e.degree();if(0<=s)return s;const o=e.at(0),n=e.at(1),t=e.at(2),i=o.isEmpty()?o.domain():[o.value()],f=n.isEmpty()?n.domain():[n.value()],c=t.isEmpty()?t.domain():[t.value()];let r=1;for(const a of i)for(const l of f)for(const u of c){const h=e.relation().degree(a,l,u);if(h<r&&(r=h),r===0)return 0}return r}function W(e){const s=e.degree();if(0<=s)return s;const o=new Array(e.emptyVariableSize());let n=0;const t=new Array(e.size());for(let i=0,f=e.size();i<f;++i){const c=e.at(i);c.isEmpty()?o[n++]=i:t[i]=c.value()}return N(e,t,o,0,0)}function Y(e){const s=e.degree();if(0<=s)return s;const o=new Array(e.emptyVariableSize());let n=0;const t=new Array(e.size());for(let i=0,f=e.size();i<f;++i){const c=e.at(i);c.isEmpty()?o[n++]=i:t[i]=c.value()}return $(e,t,o,0,1)}function N(e,s,o,n,t){const i=o[n],f=e.at(i).domain();if(n===o.length-1)for(const c of f){s[i]=c;const r=e.relation().degree(...s);if(t<r&&(t=r),t===1)return 1}else for(const c of f)s[i]=c,t=N(e,s,o,n+1,t);return t}function $(e,s,o,n,t){const i=o[n],f=e.at(i).domain();if(n===o.length-1)for(const c of f){s[i]=c;const r=e.relation().degree(...s);if(r<t&&(t=r),t===0)return 0}else for(const c of f)s[i]=c,t=$(e,s,o,n+1,t);return t}var v,y,z,p,d,A,M,F,H,R,T,_;class ne extends O{constructor(){super();w(this,d);w(this,v);w(this,y);w(this,z);w(this,p)}name(){return"Flexible Local Changes"}preprocess(){[V(this,y)._,V(this,v)._]=P(this.pro),x(this,z,this.pro.degree()),this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables(),x(this,p,-1),this.monitor.initialize()}exec(){const o=new Set,n=new Set,t=new Set;for(const h of this.pro.variables())(h.isEmpty()?t:n).add(h);const i=new Set,f=g(this,d,R).call(this,n,i);let c,r=null;t.size===0?(c=f,r=b.fromVariables(n)):c=m(this,y);const a=g(this,d,A).call(this,n,i).union(t),l=n.difference(a);let u=g(this,d,M).call(this,o,l,a,m(this,v),m(this,v),c);return u<c&&r!==null&&r.apply(),u=this.pro.degree(),m(this,z)<u&&0<u&&(m(this,p)!==0||this.monitor.getTarget()===null)}}v=new WeakMap,y=new WeakMap,z=new WeakMap,p=new WeakMap,d=new WeakSet,A=function(o,n){const t=new Map;for(const c of n)if(c.isDefined())for(const r of c)t.has(r)?t.set(r,(t.get(r)??0)+1):t.set(r,1);const i=[...o];i.sort((c,r)=>{let a=0,l=0;return t.has(c)&&(a=t.get(c)??0),t.has(r)&&(l=t.get(r)??0),a<l?1:l<a?-1:0});const f=new Set;for(const c of i){let r=!1;for(const a of n)if(a.isDefined()){r=!0;break}if(!r)break;c.clear(),f.add(c)}return f},M=function(o,n,t,i,f,c){for(n=new Set(n),t=new Set(t);;){this.monitor.outputDebugString(`X1 ${o.size}, X2' ${n.size}, X3' ${t.size}`);const r=this.monitor.check(this.pro.degree());if(r!==null)return x(this,p,r?1:0),f;if(t.size===0)return f;const a=t.values().next().value,l=g(this,d,F).call(this,o,n,a,i,f,c);if(m(this,p)!==-1)return f;if(l<c)return m(this,y);n.add(a),t.delete(a),f=l}},F=function(o,n,t,i,f,c){let r=m(this,y);if(t.domain().size()===0)return r;let a=b.fromVariables(n),l=t.domain().at(0);const u=b.fromVariables(n);for(let h=0;h<t.domain().size()&&r<f;++h){const D=t.domain().at(h);t.assign(D);const C=Math.min(i,g(this,d,T).call(this,o,t,r,c));if(Math.max(r,c)<C){const S=new Set,j=Math.min(Math.min(C,f),g(this,d,_).call(this,o,n,t,C,f,S));if(r<j&&(r=j,l=D,a=b.fromVariables(n)),S.size){const k=g(this,d,H).call(this,o,n,t,C,f,S,Math.max(c,r));if(m(this,p)!==-1)return r;r<k&&(r=k,l=D,a=b.fromVariables(n)),u.apply()}}}return a.apply(),t.assign(l),r},H=function(o,n,t,i,f,c,r){const a=g(this,d,A).call(this,n,c),l=Z(o,t),u=n.difference(a);return g(this,d,M).call(this,l,u,a,i,Math.min(f,i),r)},R=function(o,n){const t=new Set;for(const f of o)for(const c of f)t.add(c);let i=1;for(const f of t){const c=f.degree();c<0||c<i&&(i=c)}for(const f of this.pro.constraints())B(f)<m(this,v)&&n.add(f);return i},T=function(o,n,t,i){let f=1;const c=new Set;for(const r of o){const a=this.pro.constraintsBetween(r,n);for(const l of a)c.add(l)}for(const r of c){const a=r.degree();if(!(a<0)&&(a<f&&(f=a),f<=t||f<=i))return f}return f},_=function(o,n,t,i,f,c){let r=1;const a=new Set;for(const l of o){const u=this.pro.constraintsBetween(l,t);for(const h of u)a.add(h)}for(const l of n){const u=this.pro.constraintsBetween(l,t);for(const h of u)a.add(h)}for(const l of a){const u=l.degree();u<0||u<r&&(r=u)}for(const l of a){const u=l.degree();u<0||(u<i||u<f)&&c.add(l)}return r};function Z(e,s){return new Set(e).add(s)}export{ne as FlexibleLocalChanges};
