var er=Object.defineProperty;var ai=x=>{throw TypeError(x)};var sr=(x,z,N)=>z in x?er(x,z,{enumerable:!0,configurable:!0,writable:!0,value:N}):x[z]=N;var T=(x,z,N)=>sr(x,typeof z!="symbol"?z+"":z,N),Fs=(x,z,N)=>z.has(x)||ai("Cannot "+N);var s=(x,z,N)=>(Fs(x,z,"read from private field"),N?N.call(x):z.get(x)),l=(x,z,N)=>z.has(x)?ai("Cannot add the same private member more than once"):z instanceof WeakSet?z.add(x):z.set(x,N),f=(x,z,N,ee)=>(Fs(x,z,"write to private field"),ee?ee.call(x,N):z.set(x,N),N),d=(x,z,N)=>(Fs(x,z,"access private method"),N);var cs=(x,z,N,ee)=>({set _(Ss){f(x,z,Ss,N)},get _(){return s(x,z,ee)}});(function(){"use strict";var Ae,Me,se,_e,ie,Ie,O,ot,bt,lt,R,v,p,k,P,re,Re,Rt,M,D,oe,Pe,$e,Te,ae,vt,he,Ue,Oe,Le,je,yt,B,wt,St,xt,I,Y,ce,le,Be,G,Vs,hi,ci,li,ui,J,ue,fe,Ge,zt,W,As,fi,di,mi,gi,Pt,$,vs,Ms,pi,_s,bi,$t,L,Is,vi,yi,Rs,wi,We,Dt,kt,Ei,Si,xi,et,He,Nt,zi,Di,ki,qe,de,ut,Ye,Ps,ii,Tt,at,st,ni,Je,me,ri,ge,ft,Ut,K,Ot,Lt,F,Ni,$s,ys,Ci,Fi,Vi,Ai,Mi,Ke,jt,pe,Bt,oi,H,be,ve,Qe,Q,ye,we,Ze,Xe,ts,C,_i,Ts,Ii,Us,Ri,Pi,$i,Ti,Ui,Z,Ee,Se,es,Ct,xe,q,Os,Oi,Li,ji,Bi,Gt,Wt,Ft,V,Ls,Gi,Wi,Hi,ws,qi,Yi,Ji,Ht,qt,Vt,_,js,Ki,Qi,Zi,Bs,Xi,tn,en,ss,At,Mt,sn,nn,rn,it,is,ze,_t,on,an,hn,ns,De,dt,rs,Gs,Yt,ht,nt,os,ke,Ne,mt,Jt,X,Kt,Qt,A,cn,Ws,Es,ln,un,fn,dn,mn,as,Zt,Ce,Xt,Fe,ps,tt,te,gt,rt,bs,gn,hs;class x{constructor(){l(this,Ae,-1);l(this,Me,"");T(this,"userObject",null);T(this,"solverObject",null)}setIndex(r){f(this,Ae,r)}setName(r){f(this,Me,r)}index(){return s(this,Ae)}name(){return s(this,Me)}}Ae=new WeakMap,Me=new WeakMap;const ne=class ne extends x{constructor(t,e){super();l(this,_e);l(this,ie);l(this,Ie,s(ne,se));l(this,O,[]);f(this,_e,t),f(this,ie,e)}toString(){const t=this.name(),e=t?`(${t})`:"",i=this.isEmpty()?"<empty>":""+this.value();return`x${this.index()}${e} = ${i}`}size(){return s(this,O).length}at(t){return s(this,O).at(t)}has(t){return s(this,O).includes(t)}indexOf(t){return s(this,O).indexOf(t)}neighbors(){const t=[];for(const e of s(this,O))for(const i of e)i!==this&&t.push(i);return t}[Symbol.iterator](){return s(this,O)[Symbol.iterator]()}owner(){return s(this,_e)}connect(t){if(s(this,O).includes(t))throw new RangeError;s(this,O).push(t)}disconnect(t){if(!s(this,O).includes(t))throw new RangeError;f(this,O,s(this,O).filter(e=>e!==t))}domain(t){if(t===void 0)return s(this,ie);f(this,ie,t),this.clear()}assign(t){f(this,Ie,t)}clear(){this.assign(s(ne,se))}value(){return s(this,Ie)}isEmpty(){return this.value()===s(ne,se)}};se=new WeakMap,_e=new WeakMap,ie=new WeakMap,Ie=new WeakMap,O=new WeakMap,l(ne,se,Number.MIN_VALUE);let z=ne;class N{random(){return this.at(Math.floor(Math.random()*this.size()))}}class ee extends N{constructor(t,e){super();l(this,ot);l(this,bt);f(this,ot,t|0),f(this,bt,e|0)}contains(t){return s(this,ot)<=t&&t<=s(this,bt)}indexOf(t){return s(this,ot)<=t&&t<=s(this,bt)?t-s(this,ot):-1}size(){return s(this,bt)-s(this,ot)+1}at(t){return s(this,ot)+t}[Symbol.iterator](){let t=s(this,ot);const e=s(this,bt);return{next(){return t<=e?{value:t++,done:!1}:{value:null,done:!0}}}}}ot=new WeakMap,bt=new WeakMap;class Ss extends N{constructor(t){super();l(this,lt);f(this,lt,[...t])}contains(t){return s(this,lt).includes(t)}indexOf(t){return s(this,lt).indexOf(t)}size(){return s(this,lt).length}at(t){return s(this,lt)[t]}[Symbol.iterator](){return s(this,lt)[Symbol.iterator]()}}lt=new WeakMap;class pn{}class Hs extends pn{isSatisfied(...r){const t=this.degree(...r);return 0<t&&t<1?0:t}}const gs=class gs extends x{constructor(t){super();T(this,"rel");this.rel=t}relation(){return this.rel}isFuzzy(){return this.rel instanceof Hs}toString(){const t=this.name(),e=t?`(${t})`:"",i=this.degree(),n=i===gs.UNDEFINED?"UNDEFINED":""+i;return`c${this.index()}${e} = ${n}`}};T(gs,"UNDEFINED",-1);let w=gs;class bn extends w{constructor(t,e){super(t);l(this,R,[]);f(this,R,[e])}size(){return 1}at(t){return s(this,R).at(t)}has(t){return t===s(this,R)[0]}indexOf(t){return t===s(this,R)[0]?0:-1}neighbors(){const t=[];for(const e of s(this,R)[0])e!==this&&t.push(e);return t}[Symbol.iterator](){return s(this,R)[Symbol.iterator]()}emptyVariableSize(){return s(this,R)[0].isEmpty()?1:0}isDefined(){return!s(this,R)[0].isEmpty()}isSatisfied(){return s(this,R)[0].isEmpty()?w.UNDEFINED:this.rel.isSatisfied(s(this,R)[0].value())?1:0}degree(){return s(this,R)[0].isEmpty()?w.UNDEFINED:this.rel.degree(s(this,R)[0].value())}highestConsistencyDegree(){const t=this.degree();if(t!==w.UNDEFINED)return t;let e=0;const i=n=>{const o=this.rel.degree(n);return o>e&&(e=o),e===1};for(const n of s(this,R)[0].domain())if(i(n))break;return e}lowestConsistencyDegree(){const t=this.degree();if(t!==w.UNDEFINED)return t;let e=1;const i=n=>{const o=this.rel.degree(n);return o<e&&(e=o),e===0};for(const n of s(this,R)[0].domain())if(i(n))break;return e}}R=new WeakMap;class vn extends w{constructor(t,e,i){super(t);l(this,v,[]);f(this,v,[e,i])}size(){return 2}at(t){return s(this,v).at(t)}has(t){return s(this,v)[0]===t||s(this,v)[1]===t}indexOf(t){return t===s(this,v)[0]?0:t===s(this,v)[1]?1:-1}neighbors(){const t=[];for(const e of s(this,v))for(const i of e)i!==this&&t.push(i);return t}[Symbol.iterator](){return s(this,v)[Symbol.iterator]()}emptyVariableSize(){let t=0;return s(this,v)[0].isEmpty()&&++t,s(this,v)[1].isEmpty()&&++t,t}isDefined(){return!s(this,v)[0].isEmpty()&&!s(this,v)[1].isEmpty()}isSatisfied(){return s(this,v)[0].isEmpty()||s(this,v)[1].isEmpty()?w.UNDEFINED:this.rel.isSatisfied(s(this,v)[0].value(),s(this,v)[1].value())?1:0}degree(){return s(this,v)[0].isEmpty()||s(this,v)[1].isEmpty()?w.UNDEFINED:this.rel.degree(s(this,v)[0].value(),s(this,v)[1].value())}highestConsistencyDegree(){const t=this.degree();if(t!==w.UNDEFINED)return t;let e=0;const i=(c,u)=>{const m=this.rel.degree(c,u);return m>e&&(e=m),e===1},n=s(this,v)[0].value(),o=s(this,v)[1].value(),a=s(this,v)[0].domain(),h=s(this,v)[1].domain();if(s(this,v)[0].isEmpty()&&!s(this,v)[1].isEmpty()){for(const c of a)if(i(c,o))break}else if(!s(this,v)[0].isEmpty()&&s(this,v)[1].isEmpty()){for(const c of h)if(i(n,c))break}else for(const c of a)for(const u of h)if(i(c,u))break;return e}lowestConsistencyDegree(){const t=this.degree();if(t!==w.UNDEFINED)return t;let e=1;const i=(c,u)=>{const m=this.rel.degree(c,u);return m<e&&(e=m),e===0},n=s(this,v)[0].value(),o=s(this,v)[1].value(),a=s(this,v)[0].domain(),h=s(this,v)[1].domain();if(s(this,v)[0].isEmpty()&&!s(this,v)[1].isEmpty()){for(const c of a)if(i(c,o))break}else if(!s(this,v)[0].isEmpty()&&s(this,v)[1].isEmpty()){for(const c of h)if(i(n,c))break}else for(const c of a)for(const u of h)if(i(c,u))break;return e}}v=new WeakMap;class yn extends w{constructor(t,e,i,n){super(t);l(this,p,[]);f(this,p,[e,i,n])}size(){return 3}at(t){return s(this,p).at(t)}has(t){return s(this,p)[0]===t||s(this,p)[1]===t||s(this,p)[2]===t}indexOf(t){return t===s(this,p)[0]?0:t===s(this,p)[1]?1:t===s(this,p)[2]?2:-1}neighbors(){const t=[];for(const e of s(this,p))for(const i of e)i!==this&&t.push(i);return t}[Symbol.iterator](){return s(this,p)[Symbol.iterator]()}emptyVariableSize(){let t=0;return s(this,p)[0].isEmpty()&&++t,s(this,p)[1].isEmpty()&&++t,s(this,p)[2].isEmpty()&&++t,t}isDefined(){return!s(this,p)[0].isEmpty()&&!s(this,p)[1].isEmpty()&&!s(this,p)[2].isEmpty()}isSatisfied(){return s(this,p)[0].isEmpty()||s(this,p)[1].isEmpty()||s(this,p)[2].isEmpty()?w.UNDEFINED:this.rel.isSatisfied(s(this,p)[0].value(),s(this,p)[1].value(),s(this,p)[2].value())?1:0}degree(){return s(this,p)[0].isEmpty()||s(this,p)[1].isEmpty()||s(this,p)[2].isEmpty()?w.UNDEFINED:this.rel.degree(s(this,p)[0].value(),s(this,p)[1].value(),s(this,p)[2].value())}highestConsistencyDegree(){const t=this.degree();if(t!==w.UNDEFINED)return t;let e=0;const i=(m,b,y)=>{const E=this.rel.degree(m,b,y);return E>e&&(e=E),e===1},n=s(this,p)[0].value(),o=s(this,p)[1].value(),a=s(this,p)[2].value(),h=s(this,p)[0].domain(),c=s(this,p)[1].domain(),u=s(this,p)[2].domain();if(s(this,p)[0].isEmpty()&&!s(this,p)[1].isEmpty()&&!s(this,p)[2].isEmpty()){for(const m of h)if(i(m,o,a))break}else if(!s(this,p)[0].isEmpty()&&s(this,p)[1].isEmpty()&&!s(this,p)[2].isEmpty()){for(const m of c)if(i(n,m,a))break}else if(!s(this,p)[0].isEmpty()&&!s(this,p)[1].isEmpty()&&s(this,p)[2].isEmpty()){for(const m of u)if(i(n,o,m))break}else if(s(this,p)[0].isEmpty()&&s(this,p)[1].isEmpty()&&!s(this,p)[2].isEmpty()){for(const m of h)for(const b of c)if(i(m,b,a))break}else if(s(this,p)[0].isEmpty()&&!s(this,p)[1].isEmpty()&&s(this,p)[2].isEmpty()){for(const m of h)for(const b of u)if(i(m,o,b))break}else if(!s(this,p)[0].isEmpty()&&s(this,p)[1].isEmpty()&&s(this,p)[2].isEmpty()){for(const m of c)for(const b of u)if(i(n,m,b))break}else for(const m of h)for(const b of c)for(const y of u)if(i(m,b,y))break;return e}lowestConsistencyDegree(){const t=this.degree();if(t!==w.UNDEFINED)return t;let e=1;const i=(m,b,y)=>{const E=this.rel.degree(m,b,y);return E<e&&(e=E),e===0},n=s(this,p)[0].value(),o=s(this,p)[1].value(),a=s(this,p)[2].value(),h=s(this,p)[0].domain(),c=s(this,p)[1].domain(),u=s(this,p)[2].domain();if(s(this,p)[0].isEmpty()&&!s(this,p)[1].isEmpty()&&!s(this,p)[2].isEmpty()){for(const m of h)if(i(m,o,a))break}else if(!s(this,p)[0].isEmpty()&&s(this,p)[1].isEmpty()&&!s(this,p)[2].isEmpty()){for(const m of c)if(i(n,m,a))break}else if(!s(this,p)[0].isEmpty()&&!s(this,p)[1].isEmpty()&&s(this,p)[2].isEmpty()){for(const m of u)if(i(n,o,m))break}else if(s(this,p)[0].isEmpty()&&s(this,p)[1].isEmpty()&&!s(this,p)[2].isEmpty()){for(const m of h)for(const b of c)if(i(m,b,a))break}else if(s(this,p)[0].isEmpty()&&!s(this,p)[1].isEmpty()&&s(this,p)[2].isEmpty()){for(const m of h)for(const b of u)if(i(m,o,b))break}else if(!s(this,p)[0].isEmpty()&&s(this,p)[1].isEmpty()&&s(this,p)[2].isEmpty()){for(const m of c)for(const b of u)if(i(n,m,b))break}else for(const m of h)for(const b of c)for(const y of u)if(i(m,b,y))break;return e}}p=new WeakMap;class wn extends w{constructor(t,...e){super(t);l(this,k);l(this,P);f(this,k,[...e]),f(this,P,new Array(s(this,k).length))}size(){return s(this,k).length}at(t){return s(this,k).at(t)}has(t){return s(this,k).includes(t)}indexOf(t){return s(this,k).indexOf(t)}neighbors(){const t=[];for(const e of s(this,k))for(const i of e)i!==this&&t.push(i);return t}[Symbol.iterator](){return s(this,k)[Symbol.iterator]()}emptyVariableSize(){let t=0;for(const e of s(this,k))t+=e.isEmpty()?1:0;return t}isDefined(){for(const t of s(this,k))if(t.isEmpty())return!1;return!0}isSatisfied(){for(let t=0;t<s(this,k).length;++t){const e=s(this,k)[t];if(e.isEmpty())return w.UNDEFINED;s(this,P)[t]=e.value()}return this.rel.isSatisfied(...s(this,P))?1:0}degree(){for(let t=0;t<s(this,k).length;++t){const e=s(this,k)[t];if(e.isEmpty())return w.UNDEFINED;s(this,P)[t]=e.value()}return this.rel.degree(...s(this,P))}highestConsistencyDegree(){const t=this.degree();if(t!==w.UNDEFINED)return t;const e=new Array(this.emptyVariableSize());let i=0;for(let n=0;n<s(this,k).length;++n){const o=s(this,k)[n];o.isEmpty()?e[i++]=n:s(this,P)[n]=o.value()}return this.checkHCD(e,0,0)}lowestConsistencyDegree(){const t=this.degree();if(t!==w.UNDEFINED)return t;const e=new Array(this.emptyVariableSize());let i=0;for(let n=0;n<s(this,k).length;++n){const o=s(this,k)[n];o.isEmpty()?e[i++]=n:s(this,P)[n]=o.value()}return this.checkLCD(e,0,1)}checkHCD(t,e,i){const n=t[e],o=s(this,k)[n].domain();if(e===t.length-1)for(const a of o){s(this,P)[n]=a;const h=this.rel.degree(...s(this,P));if(h>i&&(i=h),i===1)break}else for(const a of o)s(this,P)[n]=a,i=this.checkHCD(t,e+1,i);return i}checkLCD(t,e,i){const n=t[e],o=s(this,k)[n].domain();if(e===t.length-1)for(const a of o){s(this,P)[n]=a;const h=this.rel.degree(...s(this,P));if(h<i&&(i=h),i===0)break}else for(const a of o)s(this,P)[n]=a,i=this.checkLCD(t,e+1,i);return i}}k=new WeakMap,P=new WeakMap;class En{constructor(){l(this,re,(r,t)=>new z(r,t));l(this,Re,(r,t)=>t.length===1?new bn(r,t[0]):t.length===2?new vn(r,t[0],t[1]):t.length===3?new yn(r,t[0],t[1],t[2]):new wn(r,...t));l(this,Rt,!1);l(this,M,[]);l(this,D,[])}setVariableFactory(r){f(this,re,r)}setConstraintFactory(r){f(this,Re,r)}addVariable(r){r.setIndex(s(this,M).length),s(this,M).push(r)}createDomain(r){return"values"in r?new Ss(r.values):"min"in r&&"max"in r?new ee(r.min,r.max):null}createVariable(r){if("variable"in r){const t=s(this,re).call(this,this,r.variable.domain());return this.addVariable(t),t.setName(t.name()),t.assign(t.value()),t}else{if(r.value!==void 0&&!r.domain.contains(r.value))throw new Error;const t=s(this,re).call(this,this,r.domain);return this.addVariable(t),r.name&&t.setName(r.name),r.value&&t.assign(r.value),t}}createConstraint(r){for(const e of r.variables)if(e.owner()!==this)return null;const t=s(this,Re).call(this,r.relation,r.variables);t.setIndex(s(this,D).length),s(this,D).push(t);for(const e of r.variables)e.connect(t);return t.isFuzzy()&&f(this,Rt,!0),"name"in r&&t.setName(r.name),t}removeConstraint(r){const t=s(this,D).indexOf(r);s(this,D).splice(t,1);for(let e=t;e<s(this,D).length;++e)s(this,D)[e].setIndex(e);for(const e of r)e.disconnect(r);f(this,Rt,!1);for(const e of s(this,D))if(e.isFuzzy()){f(this,Rt,!0);break}}clearAllVariables(){for(const r of s(this,M))r.clear()}reverseVariables(){s(this,M).reverse();for(let r=0;r<s(this,M).length;++r)s(this,M)[r].setIndex(r)}sortVariables(r){s(this,M).sort(r);for(let t=0;t<s(this,M).length;++t)s(this,M)[t].setIndex(t)}variables(){return s(this,M)}variableSize(){return s(this,M).length}variableAt(r){return s(this,M)[r]}variableOf(r){for(const t of s(this,M))if(t.name()===r)return t;return null}hasVariable(r){return s(this,M).includes(r)}constraints(){return s(this,D)}constraintSize(){return s(this,D).length}constraintAt(r){return s(this,D)[r]}constraintOf(r){for(const t of s(this,D))if(t.name()===r)return t;return null}hasConstraint(r){return s(this,D).includes(r)}constraintsBetween(r,t){const e=[];for(const i of r)i.has(t)&&e.push(i);return e}isFuzzy(){return s(this,Rt)}constraintDensity(){return s(this,D).length/s(this,M).length}emptyVariableSize(){let r=0;for(const t of s(this,M))r+=t.isEmpty()?1:0;return r}hasEmptyDomain(){for(const r of s(this,M))if(r.domain().size()===0)return!0;return!1}degree(){let r=1;for(const t of s(this,D)){const e=t.degree();if(e===w.UNDEFINED)return e;e<r&&(r=e)}return r}constraintsWithDegree(){const r=[];let t=1;for(const e of s(this,D)){const i=e.degree();i<t?(t=i,r.length=0,r.push(e)):i-t<Number.MIN_VALUE*10&&r.push(e)}return[r,t]}averageDegree(){let r=0;for(const t of s(this,D))r+=t.degree();return r/s(this,D).length}ratio(){return this.satisfiedConstraintSize()/s(this,D).length}satisfiedConstraintSize(){let r=0;for(const t of s(this,D))r+=t.isSatisfied()===1?1:0;return r}violatingConstraintSize(){return s(this,D).length-this.satisfiedConstraintSize()}satisfiedConstraints(){const r=[];for(const t of s(this,D))t.isSatisfied()===1&&r.push(t);return r}violatingConstraints(){const r=[];for(const t of s(this,D))t.isSatisfied()!==1&&r.push(t);return r}}re=new WeakMap,Re=new WeakMap,Rt=new WeakMap,M=new WeakMap,D=new WeakMap;class qs{constructor(){l(this,oe,!0);l(this,Pe,r=>console.log(r));l(this,$e,()=>!1);l(this,Te,Number.MAX_SAFE_INTEGER);l(this,ae,null);l(this,vt,.8);l(this,he,null);l(this,Ue,0);l(this,Oe,0);l(this,Le,-1);l(this,je,0)}initialize(){f(this,Ue,s(this,ae)===null?Number.MAX_VALUE:Date.now()+s(this,ae)),f(this,Oe,0)}check(r=null){if(r!==null&&s(this,vt)!==null&&s(this,vt)<=r)return this.outputDebugString("Stop: Current evaluation value is above the target"),!0;if(s(this,Te)<cs(this,Oe)._++)return this.outputDebugString("Stop: Number of iterations has reached the limit"),!1;if(s(this,Ue)<Date.now())return this.outputDebugString("Stop: Time limit has been reached"),!1;if(r!==null&&s(this,he)!==null)if(r!==-1&&s(this,Le)===r){if(cs(this,je)._++>s(this,he))return this.outputDebugString("Stop: Evaluation value has not changed for a certain number of times"),!1}else f(this,Le,r),f(this,je,0);return null}solutionFound(r,t){return s(this,$e).call(this,r,t)}outputDebugString(r){s(this,oe)&&s(this,Pe).call(this,r)}isDebugMode(){return s(this,oe)}isTargetAssigned(){return s(this,vt)!==null}getTarget(){return s(this,vt)}setIterationLimit(r=null){f(this,Te,r===null?Number.MAX_SAFE_INTEGER:r)}setTimeLimit(r=null){f(this,ae,r)}setTarget(r=null){f(this,vt,r)}setSameEvaluationLimit(r=null){f(this,he,r)}setListener(r){f(this,$e,r)}setDebugMode(r){f(this,oe,r)}setDebugOutput(r){f(this,Pe,r)}}oe=new WeakMap,Pe=new WeakMap,$e=new WeakMap,Te=new WeakMap,ae=new WeakMap,vt=new WeakMap,he=new WeakMap,Ue=new WeakMap,Oe=new WeakMap,Le=new WeakMap,je=new WeakMap;class U{constructor(r){T(this,"pro");T(this,"monitor",new qs);this.pro=r}setMonitor(r){this.monitor=r}getMonitor(){return this.monitor}name(){return""}exec(){return!1}solve(){return this.exec()}}const Et=class Et{constructor(r){l(this,B);l(this,wt,0);f(this,B,new Array(r)),s(this,B).fill(s(Et,yt))}prunedSize(){return s(this,wt)}prune(r,t){if(s(this,B)[r]===s(Et,yt))++cs(this,wt)._;else throw new Error;s(this,B)[r]=t}isEmpty(){return s(this,B).length===s(this,wt)}isPruned(r){return s(this,B)[r]!==s(Et,yt)}recover(r){for(let t=0;t<s(this,B).length;++t)s(this,B)[t]===r&&(s(this,B)[t]=s(Et,yt),--cs(this,wt)._)}recoverAll(){s(this,B).fill(s(Et,yt)),f(this,wt,0)}};yt=new WeakMap,B=new WeakMap,wt=new WeakMap,l(Et,yt,Number.MIN_SAFE_INTEGER);let xs=Et;function ls(g){for(const r of g)r.solverObject=new xs(r.domain().size())}function us(g){for(const r of g)r.solverObject=null}function pt(g,r){for(const t of g)t.solverObject.recover(r)}function fs(g){let r=0,t=Number.MAX_VALUE;for(let e=0;e<g.length;++e){const i=g[e];if(!i.isEmpty())continue;const o=i.domain().size()-i.solverObject.prunedSize();o<t&&(t=o,r=e)}return r}class ds{constructor(r){l(this,St);l(this,xt);if("assignment"in r)f(this,St,r.assignment.variable()),f(this,xt,r.assignment.value());else if("variable"in r)f(this,St,r.variable),f(this,xt,r.value??r.variable.value());else throw new RangeError}apply(){s(this,St).assign(s(this,xt))}toString(){return`v${s(this,St).index()} <- ${s(this,xt)}`}value(){return s(this,xt)}variable(){return s(this,St)}}St=new WeakMap,xt=new WeakMap;const Cs=class Cs{constructor(){l(this,I,[])}static fromVariables(r){const t=new Cs;return t.setVariables(r),t}setProblem(r){s(this,I).length=0;for(const t of r.variables())s(this,I).push(new ds({variable:t,value:t.value()}))}setAssignmentList(r){s(this,I).length=0;for(const t of r)s(this,I).push(new ds({variable:t.variable(),value:t.value()}))}setVariables(r){s(this,I).length=0;for(const t of r)s(this,I).push(new ds({variable:t,value:t.value()}))}addVariable(r,t=null){s(this,I).push(new ds({variable:r,value:t}))}apply(){for(const r of s(this,I))r.apply()}clear(){s(this,I).length=0}isEmpty(){return s(this,I).length===0}size(){return s(this,I).length}differenceSize(){let r=0;for(const t of s(this,I))t.variable().value()!==t.value()&&++r;return r}at(r){return s(this,I)[r]}[Symbol.iterator](){return s(this,I)[Symbol.iterator]()}random(){return s(this,I)[Math.floor(Math.random()*s(this,I).length)]}};I=new WeakMap;let S=Cs;function ms(g,r){const t=[];for(let e=0;e<r.length;++e){t.push(new Array(r.length));for(let i=0;i<r.length;++i)i<e&&(t[e][i]=g.constraintsBetween(r[i],r[e]))}return t}class Sn extends U{constructor(t){super(t);l(this,G);l(this,Y);l(this,ce,[]);l(this,le,new S);l(this,Be,!0);f(this,Y,[...this.pro.variables()]),f(this,ce,ms(this.pro,s(this,Y)))}name(){return"Forward Checking"}setUsingMinimumRemainingValuesHeuristics(t){f(this,Be,t)}exec(){this.monitor.initialize(),ls(s(this,Y)),this.pro.clearAllVariables();const t=d(this,G,Vs).call(this,0);return s(this,le).apply(),us(s(this,Y)),t===!0}}Y=new WeakMap,ce=new WeakMap,le=new WeakMap,Be=new WeakMap,G=new WeakSet,Vs=function(t){if(t===this.pro.variableSize()){const a=this.pro.ratio();return s(this,le).setProblem(this.pro),this.monitor.outputDebugString(`	Evaluation ${a}`),this.monitor.solutionFound(s(this,le),a),!0}let e=null;if((e=this.monitor.check())!==null)return e;const i=s(this,Y)[s(this,Be)?fs(s(this,Y)):t],n=i.domain(),o=i.solverObject;for(let a=0,h=n.size();a<h;++a)if(!(o.isPruned(a)||(i.assign(n.at(a)),d(this,G,ui).call(this,i)))){if(d(this,G,hi).call(this,t,i)&&(e=d(this,G,Vs).call(this,t+1),e!==null))break;pt(s(this,Y),t)}return e===null&&(pt(s(this,Y),t),i.clear()),e},hi=function(t,e){for(const i of s(this,Y)){if(!i.isEmpty())continue;const n=d(this,G,ci).call(this,e.index(),i.index()),o=i.solverObject,a=i.domain();for(const h of n)if(h.emptyVariableSize()===1&&!d(this,G,li).call(this,t,i,a,o,h))return!1}return!0},ci=function(t,e){return t<e?s(this,ce)[e][t]:s(this,ce)[t][e]},li=function(t,e,i,n,o){for(let a=0,h=i.size();a<h;++a)n.isPruned(a)||(e.assign(i.at(a)),o.isSatisfied()===0&&n.prune(a,t));return e.clear(),!n.isEmpty()},ui=function(t){let e=0;for(const i of t)i.isSatisfied()===0&&++e;return e};class xn extends U{constructor(t){super(t);l(this,W);l(this,J);l(this,ue,[]);l(this,fe,new S);l(this,Ge,!0);l(this,zt,0);f(this,J,[...this.pro.variables()]),f(this,ue,ms(this.pro,s(this,J)))}name(){return"Forward Checking for Max CSPs"}setUsingMinimumRemainingValuesHeuristics(t){f(this,Ge,t)}exec(){this.monitor.initialize(),f(this,zt,this.pro.constraintSize()),ls(s(this,J)),this.pro.clearAllVariables();const t=d(this,W,As).call(this,0);return s(this,fe).apply(),us(s(this,J)),t===!0}}J=new WeakMap,ue=new WeakMap,fe=new WeakMap,Ge=new WeakMap,zt=new WeakMap,W=new WeakSet,As=function(t,e=0){if(t===this.pro.variableSize()){const h=this.pro.ratio();return s(this,fe).setProblem(this.pro),this.monitor.outputDebugString(`	Evaluation ${h}`),e<s(this,zt)&&(f(this,zt,e),this.monitor.solutionFound(s(this,fe),h))?!0:this.monitor.check(h)}let i=null;if((i=this.monitor.check())!==null)return i;const n=s(this,J)[s(this,Ge)?fs(s(this,J)):t],o=n.domain(),a=n.solverObject;for(let h=0,c=o.size();h<c;++h){if(a.isPruned(h))continue;n.assign(o.at(h));const u=e+d(this,W,gi).call(this,n);if(!(s(this,zt)<=u)){if((e+1<s(this,zt)||d(this,W,fi).call(this,t,n))&&(i=d(this,W,As).call(this,t+1,u),i!==null))break;pt(s(this,J),t)}}return i===null&&(pt(s(this,J),t),n.clear()),i},fi=function(t,e){for(const i of s(this,J)){if(!i.isEmpty())continue;const n=d(this,W,di).call(this,e.index(),i.index()),o=i.solverObject,a=i.domain();for(const h of n)if(h.emptyVariableSize()===1&&!d(this,W,mi).call(this,t,i,a,o,h))return!1}return!0},di=function(t,e){return t<e?s(this,ue)[e][t]:s(this,ue)[t][e]},mi=function(t,e,i,n,o){for(let a=0,h=i.size();a<h;++a)n.isPruned(a)||(e.assign(i.at(a)),o.isSatisfied()===0&&n.prune(a,t));return e.clear(),!n.isEmpty()},gi=function(t){let e=0;for(const i of t)i.isSatisfied()===0&&++e;return e};class zn extends U{constructor(t,e=!1){super(t);l(this,$);l(this,Pt,!1);e&&this.pro.clearAllVariables()}name(){return"Local Changes"}exec(){this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables(),f(this,Pt,!1);const t=new Set,e=new Set;for(const a of this.pro.variables())(a.isEmpty()?e:t).add(a);this.monitor.initialize();const i=new S,n=d(this,$,vs).call(this,new Set,t,e),o=this.pro.ratio();return this.monitor.outputDebugString(`Evaluation: ${o}`),n&&(i.setProblem(this.pro),this.monitor.solutionFound(i,o))?!0:n}}Pt=new WeakMap,$=new WeakSet,vs=function(t,e,i){{this.monitor.outputDebugString(`X1 ${t.size}, X2' ${e.size}, X3' ${i.size}`);const n=this.monitor.check(this.pro.degree());if(n!==null)return f(this,Pt,!0),n;if(i.size===0)return!0;const o=i.values().next().value,a=d(this,$,Ms).call(this,t,e,o,Dn(o));return!a||s(this,Pt)?a:(e=Ys(e,o),i=Js(i,o),d(this,$,vs).call(this,t,e,i))}},Ms=function(t,e,i,n){if(n.size){const o=n.values().next().value,a=S.fromVariables(e);i.assign(o);const h=d(this,$,pi).call(this,t,e,i,o);return h||s(this,Pt)?h:(i.clear(),a.apply(),d(this,$,Ms).call(this,t,e,i,Js(n,o)))}return!1},pi=function(t,e,i,n){if(!d(this,$,_s).call(this,t,i,n))return!1;const o=t.union(e);if(d(this,$,_s).call(this,o,i,n))return!0;const a=d(this,$,bi).call(this,o,i,n);return t=Ys(t,i),e=e.difference(a),d(this,$,vs).call(this,t,e,a)},_s=function(t,e,i){const n=new Set;for(const a of t){const h=this.pro.constraintsBetween(e,a);for(const c of h)n.add(c)}const o=e.value();e.assign(i);for(const a of n)if(a.isSatisfied()!==1)return e.assign(o),!1;return e.assign(o),!0},bi=function(t,e,i){const n=new Set,o=new Set;for(const h of t)for(const c of this.pro.constraintsBetween(e,h))o.add(c);const a=e.value();e.assign(i);for(const h of o)if(h.isSatisfied()!==1)for(const c of h)n.add(c);return e.assign(a),n.delete(e),n};function Ys(g,r){return new Set(g).add(r)}function Js(g,r){const t=new Set(g);return t.delete(r),t}function Dn(g){return new Set(g.domain())}class kn extends U{constructor(t,e=!1){super(t);l(this,L);l(this,$t,!1);e&&this.pro.clearAllVariables()}name(){return"Local Changes Ex"}exec(){this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables(),f(this,$t,!1);const t=new Set,e=new Set;for(const a of this.pro.variables())(a.isEmpty()?e:t).add(a);this.monitor.initialize();const i=new S,n=d(this,L,Is).call(this,new Set,t,e),o=this.pro.ratio();return this.monitor.outputDebugString(`Evaluation: ${o}`),n&&(i.setProblem(this.pro),this.monitor.solutionFound(i,o))?!0:n}}$t=new WeakMap,L=new WeakSet,Is=function(t,e,i){for(e=new Set(e),i=new Set(i);;){this.monitor.outputDebugString(`X1 ${t.size}, X2' ${e.size}, X3' ${i.size}`);const n=this.monitor.check(this.pro.degree());if(n!==null)return f(this,$t,!0),n;if(i.size===0)return!0;const o=i.values().next().value,a=d(this,L,vi).call(this,t,e,o);if(!a||s(this,$t))return a;e.add(o),i.delete(o)}},vi=function(t,e,i){for(const n of i.domain()){const o=S.fromVariables(e);i.assign(n);const a=d(this,L,yi).call(this,t,e,i);if(a||s(this,$t))return a;i.clear(),o.apply()}return!1},yi=function(t,e,i){if(!d(this,L,Rs).call(this,t,i,i.value()))return!1;const n=t.union(e);if(d(this,L,Rs).call(this,n,i,i.value()))return!0;const o=d(this,L,wi).call(this,n,i,i.value());return t=Nn(t,i),e=e.difference(o),d(this,L,Is).call(this,t,e,o)},Rs=function(t,e,i){const n=new Set;for(const a of t){const h=this.pro.constraintsBetween(e,a);for(const c of h)n.add(c)}const o=e.value();e.assign(i);for(const a of n)if(a.isSatisfied()!==1)return e.assign(o),!1;return e.assign(o),!0},wi=function(t,e,i){const n=new Set,o=new Set;for(const h of t)for(const c of this.pro.constraintsBetween(e,h))o.add(c);const a=e.value();e.assign(i);for(const h of o)if(h.isSatisfied()!==1)for(const c of h)n.add(c);return e.assign(a),n.delete(e),n};function Nn(g,r){return new Set(g).add(r)}class Cn extends U{constructor(t){super(t);l(this,kt);l(this,We,!0);l(this,Dt);f(this,Dt,new Array(this.pro.constraintSize())),s(this,Dt).fill(1)}name(){return"Breakout"}setRandomness(t){f(this,We,t)}exec(){for(const a of this.pro.variables())a.isEmpty()&&a.assign(a.domain().at(0));const t=this.pro.ratio(),e=new S;let i=t;this.monitor.initialize();const n=new S;let o=null;for(;;){const a=this.pro.violatingConstraints(),h=this.pro.ratio();if(this.monitor.outputDebugString(`Evaluation: ${h}`),i<h&&(e.setProblem(this.pro),i=h,this.monitor.solutionFound(e,i)))return!0;if((o=this.monitor.check(h))!==null)break;d(this,kt,Ei).call(this,a,n)}return o===!1&&!this.monitor.isTargetAssigned()&&t<i&&(e.apply(),o=!0),o}}We=new WeakMap,Dt=new WeakMap,kt=new WeakSet,Ei=function(t,e){if(d(this,kt,Si).call(this,d(this,kt,xi).call(this,t),e),0<e.size()){const i=s(this,We)?e.random():e.at(0);i.apply(),e.clear(),this.monitor.outputDebugString("	"+i)}else{for(const i of t)s(this,Dt)[i.index()]+=1;this.monitor.outputDebugString("Breakout")}},Si=function(t,e){let i=0;for(const n of t){const o=n.value();let a=0;for(const h of n)a+=(1-h.isSatisfied())*s(this,Dt)[h.index()];t:for(const h of n.domain()){if(o===h)continue;n.assign(h);let c=a;for(const u of n)if(c-=(1-u.isSatisfied())*s(this,Dt)[u.index()],c<i)continue t;i<c?(i=c,e.clear(),e.addVariable(n,h)):i!==0&&e.addVariable(n,h)}n.assign(o)}},xi=function(t){const e=new Set;for(const i of t)for(const n of i)e.add(n);return Array.from(e)};class Fn extends U{constructor(t){super(t);l(this,Nt);l(this,et,[]);l(this,He,[])}name(){return"GENET"}exec(){if(!d(this,Nt,zi).call(this))throw new Error;const t=[...Array(s(this,et).length).keys()],e=this.pro.ratio(),i=new S;let n=e;this.monitor.initialize();let o=null;for(;;){const a=this.pro.ratio();if(this.monitor.outputDebugString(`Evaluation: ${a}`),n<a&&(i.setProblem(this.pro),n=a,this.monitor.solutionFound(i,n)))return!0;if((o=this.monitor.check(a))!==null)break;d(this,Nt,Di).call(this,t)}return o===!1&&!this.monitor.isTargetAssigned()&&e<n&&(i.apply(),o=!0),o}}et=new WeakMap,He=new WeakMap,Nt=new WeakSet,zi=function(){this.monitor.outputDebugString("Start of Network Generation");const t=[];for(const e of this.pro.variables()){if(e.domain().size()===0)return!1;s(this,et).push(new Vn(e))}for(const e of this.pro.constraints())if(e.size()===1){const i=e.at(0),n=s(this,et)[i.index()];for(const o of n){const a=i.value();i.assign(o._value),e.isSatisfied()!==1&&t.push(new Ks(e,o)),i.assign(a)}}else{const i=e.at(0),n=e.at(1),o=s(this,et)[i.index()],a=s(this,et)[n.index()];for(const h of o){const c=i.value();i.assign(h._value);for(const u of a){const m=n.value();n.assign(u._value),e.isSatisfied()!==1&&t.push(new Ks(e,h,u)),n.assign(m)}i.assign(c)}}for(const e of s(this,et))for(const i of e._neurons)i.lockConnections();return f(this,He,t),this.monitor.outputDebugString("End of Network Generation"),!0},Di=function(t){let e=!1;for(const i of d(this,Nt,ki).call(this,t))s(this,et)[i].setActivityMaximumInput()&&(e=!0);if(e)for(const i of s(this,et))i.applyToVariable();else for(const i of s(this,He))i.refreshWeight()},ki=function(t){for(let e=t.length;e>1;--e){const i=zs(e),n=t[e-1];t[e-1]=t[i],t[i]=n}return t};let Vn=(ii=class{constructor(r){l(this,Ye);l(this,qe);l(this,de,0);l(this,ut,[]);T(this,"_neurons",[]);f(this,qe,r);for(const t of r.domain())this._neurons.push(new An(t));d(this,Ye,Ps).call(this,zs(this._neurons.length))}applyToVariable(){s(this,qe).assign(this._neurons[s(this,de)]._value)}setActivityMaximumInput(){s(this,ut).length=0;let r=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const i=this._neurons[e].getInput();r<=i&&(r<i&&(r=i,s(this,ut).length=0,t=!1),s(this,ut).push(e),s(this,de)===e&&(t=!0))}return t||s(this,ut).length===0?!1:(d(this,Ye,Ps).call(this,s(this,ut)[zs(s(this,ut).length)]),!0)}[Symbol.iterator](){return this._neurons[Symbol.iterator]()}},qe=new WeakMap,de=new WeakMap,ut=new WeakMap,Ye=new WeakSet,Ps=function(r){for(const t of this._neurons)t._isActive=!1;this._neurons[r]._isActive=!0,f(this,de,r)},ii),Ks=(ni=class{constructor(r,t,e=null){l(this,Tt);l(this,at);l(this,st);T(this,"_weight");f(this,Tt,r),f(this,at,t),f(this,st,e),this._weight=r.isSatisfied()-1,s(this,at).addConnection(this),s(this,st)&&s(this,st).addConnection(this)}getNeuron(r){return r===s(this,at)?s(this,st):r===s(this,st)?s(this,at):null}refreshWeight(){!s(this,at)._isActive||s(this,st)!==null&&!s(this,st)._isActive||(s(this,Tt).size()===1?this._weight+=s(this,Tt).relation().isSatisfied(s(this,at)._value)-1:this._weight+=s(this,Tt).relation().isSatisfied(s(this,at)._value,s(this,st)._value)-1)}},Tt=new WeakMap,at=new WeakMap,st=new WeakMap,ni),An=(ri=class{constructor(r){l(this,Je,[]);l(this,me,[]);T(this,"_value");T(this,"_isActive",!1);this._value=r}addConnection(r){s(this,me).push(r)}lockConnections(){f(this,Je,[...s(this,me)]),f(this,me,null)}getInput(){let r=0;for(const t of s(this,Je)){const e=t.getNeuron(this);r+=t._weight*(e===null||e._isActive?1:0)}return r}},Je=new WeakMap,me=new WeakMap,ri);function zs(g){return Math.floor(Math.random()*Math.floor(g))}class Mn extends U{constructor(t){super(t);l(this,F);l(this,ge,!0);l(this,ft);l(this,Ut,new Set);l(this,K,new Set);l(this,Ot,[]);l(this,Lt,[]);for(const e of this.pro.constraints())s(this,Ot).push(new _n(e)),s(this,Lt).push(null);f(this,ft,new Array(this.pro.constraintSize())),s(this,ft).fill(1)}name(){return"SRS3 for Crisp CSPs"}setRandomness(t){f(this,ge,t)}exec(){for(const o of this.pro.variables())o.isEmpty()&&o.assign(o.domain().at(0));const t=this.pro.degree(),e=new S;let i=t;this.monitor.initialize();let n=null;for(;;){const o=this.pro.violatingConstraints(),a=this.pro.ratio();if(this.monitor.outputDebugString(`Evaluation: ${a}`),i<a&&(e.setProblem(this.pro),i=a,this.monitor.solutionFound(e,i)))return!0;if((n=this.monitor.check(a))!==null)break;for(const c of s(this,Ot))c.clear();const h=new Set;for(const c of o){const u=s(this,Ot)[c.index()];h.add(u)}d(this,F,Ni).call(this,h)}return n===!1&&!this.monitor.isTargetAssigned()&&t<i&&(e.apply(),n=!0),n}}ge=new WeakMap,ft=new WeakMap,Ut=new WeakMap,K=new WeakMap,Ot=new WeakMap,Lt=new WeakMap,F=new WeakSet,Ni=function(t){this.monitor.outputDebugString("SRS"),s(this,Ut).clear(),s(this,K).clear();for(const e of t)s(this,K).add(e);for(;t.size&&s(this,K).size;){const e=d(this,F,Vi).call(this,s(this,K));s(this,K).delete(e),d(this,F,ys).call(this,e.constraint())?t.delete(e)||(e.parent()&&d(this,F,ys).call(this,e.parent().constraint())?d(this,F,Ci).call(this,e,t):d(this,F,$s).call(this,e)):d(this,F,$s).call(this,e)}return t.size===0},$s=function(t){this.monitor.outputDebugString("Spread"),s(this,Ut).add(t);for(const e of d(this,F,Fi).call(this,t))!s(this,Ut).has(e)&&!s(this,K).has(e)&&(e.clear(),t.append(e),s(this,K).add(e))},ys=function(t){this.monitor.outputDebugString("Repair"),s(this,ft)[t.index()]+=1;const e=new S;let i=0;for(const n of t){const o=n.value();let a=0;for(const h of n)a+=(1-h.isSatisfied())*s(this,ft)[h.index()];t:for(const h of n.domain()){if(o===h||(n.assign(h),t.isSatisfied()!==1))continue;let c=a;for(const u of n)if(c-=(1-u.isSatisfied())*s(this,ft)[u.index()],c<i)continue t;i<c?(i=c,e.clear(),e.addVariable(n,h)):i!==0&&e.addVariable(n,h)}n.assign(o)}if(0<e.size()){const n=s(this,ge)?e.random():e.at(0);return n.apply(),this.monitor.outputDebugString("	"+n),!0}return!1},Ci=function(t,e){this.monitor.outputDebugString("Shrink");let i=t,n=!1;for(;;){if(i=i.parent(),e.delete(i)){n=!0;break}if(!i.parent()||!d(this,F,ys).call(this,i.parent().constraint()))break}const o=[];i.getDescendants(o),i.clear();for(const a of o)s(this,K).delete(a),s(this,Ut).delete(a);n||s(this,K).add(i)},Fi=function(t){const e=t.constraint(),i=e.index();if(s(this,Lt)[i]===null){const n=[];for(const o of e.neighbors())n.push(s(this,Ot)[o.index()]);s(this,Lt)[i]=n}return s(this,Lt)[i]},Vi=function(t){const e=d(this,F,Ai).call(this,d(this,F,Mi).call(this,t));return s(this,ge)?e[Math.floor(Math.random()*e.length)]:e[0]},Ai=function(t){let e=Number.MAX_VALUE,i=[];for(const n of t){const o=s(this,ft)[n.constraint().index()];o<e?(e=o,i.length=0,i.push(n)):o===e&&i.push(n)}return i},Mi=function(t){let e=Number.MAX_VALUE,i=[];for(const n of t){const o=n.depth();o<e?(e=o,i.length=0,i.push(n)):o===e&&i.push(n)}return i};let _n=(oi=class{constructor(r){l(this,Ke);l(this,jt,0);l(this,pe,null);l(this,Bt,[]);f(this,Ke,r)}append(r){f(r,pe,this),f(r,jt,s(this,jt)+1),s(this,Bt).push(r)}clear(){f(this,pe,null),f(this,jt,0);for(const r of s(this,Bt))r.clear();s(this,Bt).length=0}constraint(){return s(this,Ke)}depth(){return s(this,jt)}parent(){return s(this,pe)}getDescendants(r){r.push(this);for(const t of s(this,Bt))t.getDescendants(r)}},Ke=new WeakMap,jt=new WeakMap,pe=new WeakMap,Bt=new WeakMap,oi);class In extends U{constructor(t){super(t);l(this,C);l(this,H);l(this,be,[]);l(this,ve,new S);l(this,Qe,!0);l(this,Q,0);l(this,ye,!1);l(this,we,new Set);l(this,Ze);l(this,Xe,[]);l(this,ts,!1);f(this,H,[...this.pro.variables()]),f(this,be,ms(this.pro,s(this,H))),f(this,Ze,new Array(this.pro.variableSize())),f(this,Xe,this.pro.constraints().filter(e=>e.size()===1))}name(){return"Full Checking for Fuzzy CSPs"}setUsingMinimumRemainingValuesHeuristics(t){f(this,Qe,t)}setIntensivePruning(t){f(this,ts,t)}exec(){this.monitor.initialize(),f(this,Q,0),ls(s(this,H));let t=null;for(;t===null;){if(!d(this,C,_i).call(this)){t=!1;break}this.pro.clearAllVariables(),t=d(this,C,Ts).call(this,0),s(this,ve).apply(),f(this,ye,!1)}return us(s(this,H)),t===!0}}H=new WeakMap,be=new WeakMap,ve=new WeakMap,Qe=new WeakMap,Q=new WeakMap,ye=new WeakMap,we=new WeakMap,Ze=new WeakMap,Xe=new WeakMap,ts=new WeakMap,C=new WeakSet,_i=function(){for(const t of s(this,Xe)){const e=t.at(0),i=e.value(),n=e.domain(),o=e.solverObject;for(let a=0,h=n.size();a<h;++a)e.assign(n.at(a)),t.degree()<=s(this,Q)&&o.prune(a,-1);if(e.assign(i),o.isEmpty())return!1}return!0},Ts=function(t,e=1){if(t===this.pro.variableSize()){const h=this.pro.degree();return s(this,ve).setProblem(this.pro),this.monitor.outputDebugString(`	Evaluation ${h}`),s(this,Q)<h&&(f(this,Q,h),f(this,ye,!0),this.monitor.solutionFound(s(this,ve),h))?!0:this.monitor.check(h)}let i=null;if((i=this.monitor.check())!==null)return i;const n=s(this,H)[s(this,Qe)?fs(s(this,H)):t],o=n.domain(),a=n.solverObject;s(this,Ze)[t]=n;for(let h=0,c=o.size();h<c;++h){if(a.isPruned(h))continue;n.assign(o.at(h));const u=Math.min(e,d(this,C,Ui).call(this,n));if(!(u<=s(this,Q))){if(d(this,C,Ii).call(this,t,n)&&(i=d(this,C,Ts).call(this,t+1,u),i!==null||s(this,ye)))break;pt(s(this,H),t)}}return i===null&&(pt(s(this,H),t),n.clear()),i},Ii=function(t,e){for(const i of s(this,H)){if(!i.isEmpty())continue;const n=d(this,C,Us).call(this,e.index(),i.index()),o=i.solverObject,a=i.domain();for(const h of n){const c=h.emptyVariableSize();if(c===1){if(!d(this,C,Ri).call(this,t,i,a,o,h))return!1}else if(s(this,ts)){if(c===2){if(!d(this,C,Pi).call(this,t,i,a,o,h))return!1}else if(c===3){if(!d(this,C,$i).call(this,t,i,a,o,h))return!1}else if(c>3&&!d(this,C,Ti).call(this,t,i,a,o,h,c))return!1}}}return!0},Us=function(t,e){return t<e?s(this,be)[e][t]:s(this,be)[t][e]},Ri=function(t,e,i,n,o){for(let a=0,h=i.size();a<h;++a)n.isPruned(a)||(e.assign(i.at(a)),o.degree()<=s(this,Q)&&n.prune(a,t));return e.clear(),!n.isEmpty()},Pi=function(t,e,i,n,o){let a=null;for(const u of o)if(u.isEmpty()&&u!==e){a=u;break}const h=a.domain(),c=a.solverObject;t:for(let u=0,m=i.size();u<m;++u)if(!n.isPruned(u)){e.assign(i.at(u));for(let b=0,y=h.size();b<y;++b)if(!c.isPruned(b)&&(a.assign(h.at(b)),o.degree()>s(this,Q)))continue t;n.prune(u,t)}return a.clear(),e.clear(),!n.isEmpty()},$i=function(t,e,i,n,o){let a=null,h=null;for(const y of o)if(y.isEmpty()&&y!==e)if(a===null)a=y;else{h=y;break}const c=a.domain(),u=h.domain(),m=a.solverObject,b=h.solverObject;t:for(let y=0,E=i.size();y<E;++y)if(!n.isPruned(y)){e.assign(i.at(y));for(let j=0,It=c.size();j<It;++j)if(!m.isPruned(j)){a.assign(c.at(j));for(let ct=0,tr=u.size();ct<tr;++ct)if(!b.isPruned(ct)&&(h.assign(u.at(ct)),o.degree()>s(this,Q)))continue t}n.prune(y,t)}return h.clear(),a.clear(),e.clear(),!n.isEmpty()},Ti=function(t,e,i,n,o,a){const h=new Array(a-1);let c=0;for(const m of o)m.isEmpty()&&m!==e&&(h[c++]=m);const u=new Array(h.length);t:for(let m=0,b=i.size();m<b;++m)if(!n.isPruned(m)){e.assign(i.at(m)),u.fill(0);e:for(;;){let y=!1;for(let E=0;E<h.length;++E){const j=h[E].domain();if(h[E].solverObject.isPruned(u[E])){y=!0;break}h[E].assign(j.at(u[E]))}if(!y&&o.degree()>s(this,Q))continue t;for(let E=0;E<h.length&&(u[E]+=1,!(u[E]<h[E].domain().size()));++E)if(u[E]=0,E===h.length-1)break e}n.prune(m,t)}for(const m of h)m.clear();return e.clear(),!n.isEmpty()},Ui=function(t){let e=Number.MAX_VALUE;s(this,we).clear();for(const i of s(this,H)){if(i===t||i.isEmpty())continue;const n=d(this,C,Us).call(this,t.index(),i.index());for(const o of n)if(!s(this,we).has(o)){const a=o.degree();a!==w.UNDEFINED&&a<e&&(e=a),s(this,we).add(o)}}return e};class Rn extends U{constructor(t){super(t);l(this,q);l(this,Z);l(this,Ee,[]);l(this,Se,new S);l(this,es,!0);l(this,Ct,0);l(this,xe,!1);f(this,Z,[...this.pro.variables()]),f(this,Ee,ms(this.pro,s(this,Z)))}name(){return"Forward Checking for Fuzzy CSPs"}setUsingMinimumRemainingValuesHeuristics(t){f(this,es,t)}exec(){this.monitor.initialize(),f(this,Ct,0),ls(s(this,Z));let t=null;for(;t===null;)this.pro.clearAllVariables(),t=d(this,q,Os).call(this,0),s(this,Se).apply(),f(this,xe,!1);return us(s(this,Z)),t===!0}}Z=new WeakMap,Ee=new WeakMap,Se=new WeakMap,es=new WeakMap,Ct=new WeakMap,xe=new WeakMap,q=new WeakSet,Os=function(t,e=1){if(t===this.pro.variableSize()){const h=this.pro.degree();return s(this,Se).setProblem(this.pro),this.monitor.outputDebugString(`	Evaluation ${h}`),s(this,Ct)<h&&(f(this,Ct,h),f(this,xe,!0),this.monitor.solutionFound(s(this,Se),h))?!0:this.monitor.check(h)}let i=null;if((i=this.monitor.check())!==null)return i;const n=s(this,Z)[s(this,es)?fs(s(this,Z)):t],o=n.domain(),a=n.solverObject;for(let h=0,c=o.size();h<c;++h){if(a.isPruned(h))continue;n.assign(o.at(h));const u=Math.min(e,d(this,q,Bi).call(this,n));if(!(u<=s(this,Ct))){if(d(this,q,Oi).call(this,t,n)&&(i=d(this,q,Os).call(this,t+1,u),i!==null||s(this,xe)))break;pt(s(this,Z),t)}}return i===null&&(pt(s(this,Z),t),n.clear()),i},Oi=function(t,e){for(const i of s(this,Z)){if(!i.isEmpty())continue;const n=d(this,q,Li).call(this,e.index(),i.index()),o=i.solverObject,a=i.domain();for(const h of n)if(h.emptyVariableSize()===1&&!d(this,q,ji).call(this,t,i,a,o,h))return!1}return!0},Li=function(t,e){return t<e?s(this,Ee)[e][t]:s(this,Ee)[t][e]},ji=function(t,e,i,n,o){for(let a=0,h=i.size();a<h;++a)n.isPruned(a)||(e.assign(i.at(a)),o.degree()<=s(this,Ct)&&n.prune(a,t));return e.clear(),!n.isEmpty()},Bi=function(t){let e=Number.MAX_VALUE;for(const i of t){const n=i.degree();n!==w.UNDEFINED&&n<e&&(e=n)}return e};class Pn extends U{constructor(t){super(t);l(this,V);l(this,Gt,0);l(this,Wt,0);l(this,Ft,0);d(this,V,Gi).call(this)}name(){return"Flexible Local Changes"}exec(){this.monitor.initialize(),f(this,Ft,-1);const t=this.pro.degree();this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const e=new Set,i=new Set,n=new Set;for(const y of this.pro.variables())(y.isEmpty()?n:i).add(y);const o=new Set,a=d(this,V,qi).call(this,i,o);let h,c=null;n.size===0?(h=a,c=S.fromVariables(i)):h=s(this,Wt);const u=d(this,V,Ls).call(this,i,o).union(n),m=i.difference(u);let b=d(this,V,ws).call(this,e,m,u,s(this,Gt),s(this,Gt),h);return b<h&&c!==null&&c.apply(),b=this.pro.degree(),b>t&&b>0&&(s(this,Ft)!==0||this.targetDeg===null)}}Gt=new WeakMap,Wt=new WeakMap,Ft=new WeakMap,V=new WeakSet,Ls=function(t,e){const i=new Map;for(const a of e)if(a.isDefined())for(const h of a)i.has(h)?i.set(h,(i.get(h)??0)+1):i.set(h,1);const n=[...t];n.sort((a,h)=>{let c=0,u=0;return i.has(a)&&(c=i.get(a)??0),i.has(h)&&(u=i.get(h)??0),c<u?1:c>u?-1:0});const o=new Set;for(const a of n){let h=!1;for(const c of e)if(c.isDefined()){h=!0;break}if(!h)break;a.clear(),o.add(a)}return o},Gi=function(){let t=1,e=0;for(const i of this.pro.variables())for(const n of i){const o=n.lowestConsistencyDegree(),a=n.highestConsistencyDegree();o<t&&(t=o),a>e&&(e=a)}f(this,Wt,t),f(this,Gt,e)},Wi=function(t,e,i,n,o,a,h){const c=d(this,V,Ls).call(this,e,a),u=Qs(t,i),m=e.difference(c);return d(this,V,ws).call(this,u,m,c,n,Math.min(o,n),h)},Hi=function(t,e,i,n,o,a){let h=s(this,Wt);if(i.domain().size()===0)return h;let c=S.fromVariables(e),u=i.domain().at(0);const m=S.fromVariables(e);for(let b=0;b<i.domain().size()&&h<o;++b){const y=i.domain().at(b);i.assign(y);const E=Math.min(n,d(this,V,Yi).call(this,t,i,h,a));if(E>Math.max(h,a)){const j=new Set,It=Math.min(Math.min(E,o),d(this,V,Ji).call(this,t,e,i,E,o,j));if(It>h&&(h=It,u=y,c=S.fromVariables(e)),j.size){const ct=d(this,V,Wi).call(this,t,e,i,E,o,j,Math.max(a,h));if(s(this,Ft)!==-1)return h;ct>h&&(h=ct,u=y,c=S.fromVariables(e)),m.apply()}}}return c.apply(),i.assign(u),h},ws=function(t,e,i,n,o,a){{this.monitor.outputDebugString(`X1 ${t.size}, X2' ${e.size}, X3' ${i.size}`);const h=this.monitor.check(this.pro.degree());if(h!==null)return f(this,Ft,h?1:0),o;if(i.size===0)return o;const c=i.values().next().value,u=d(this,V,Hi).call(this,t,e,c,n,o,a);return s(this,Ft)!==-1?o:u<a?s(this,Wt):(e=Qs(e,c),i=$n(i,c),d(this,V,ws).call(this,t,e,i,n,u,a))}},qi=function(t,e){const i=new Set;for(const o of t)for(const a of o)i.add(a);let n=1;for(const o of i){const a=o.degree();a!==w.UNDEFINED&&a<n&&(n=a)}for(const o of this.pro.constraints())o.lowestConsistencyDegree()<s(this,Gt)&&e.add(o);return n},Yi=function(t,e,i,n){let o=1;const a=new Set;for(const h of t){const c=this.pro.constraintsBetween(h,e);for(const u of c)a.add(u)}for(const h of a){const c=h.degree();if(c!==w.UNDEFINED&&(c<o&&(o=c),o<=i||o<=n))return o}return o},Ji=function(t,e,i,n,o,a){let h=1;const c=new Set;for(const u of t){const m=this.pro.constraintsBetween(u,i);for(const b of m)c.add(b)}for(const u of e){const m=this.pro.constraintsBetween(u,i);for(const b of m)c.add(b)}for(const u of c){const m=u.degree();m!==w.UNDEFINED&&m<h&&(h=m)}for(const u of c){const m=u.degree();m!==w.UNDEFINED&&(m<n||m<o)&&a.add(u)}return h};function Qs(g,r){return new Set(g).add(r)}function $n(g,r){const t=new Set(g);return t.delete(r),t}class Tn extends U{constructor(t){super(t);l(this,_);l(this,Ht,0);l(this,qt,0);l(this,Vt,0);d(this,_,Ki).call(this)}name(){return"Flexible Local Changes Ex"}exec(){this.monitor.initialize(),f(this,Vt,-1);const t=this.pro.degree();this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const e=new Set,i=new Set,n=new Set;for(const y of this.pro.variables())(y.isEmpty()?n:i).add(y);const o=new Set,a=d(this,_,Xi).call(this,i,o);let h,c=null;n.size===0?(h=a,c=S.fromVariables(i)):h=s(this,qt);const u=d(this,_,js).call(this,i,o).union(n),m=i.difference(u);let b=d(this,_,Bs).call(this,e,m,u,s(this,Ht),s(this,Ht),h);return b<h&&c!==null&&c.apply(),b=this.pro.degree(),b>t&&b>0&&(s(this,Vt)!==0||this.targetDeg===null)}}Ht=new WeakMap,qt=new WeakMap,Vt=new WeakMap,_=new WeakSet,js=function(t,e){const i=new Map;for(const a of e)if(a.isDefined())for(const h of a)i.has(h)?i.set(h,(i.get(h)??0)+1):i.set(h,1);const n=[...t];n.sort((a,h)=>{let c=0,u=0;return i.has(a)&&(c=i.get(a)??0),i.has(h)&&(u=i.get(h)??0),c<u?1:c>u?-1:0});const o=new Set;for(const a of n){let h=!1;for(const c of e)if(c.isDefined()){h=!0;break}if(!h)break;a.clear(),o.add(a)}return o},Ki=function(){let t=1,e=0;for(const i of this.pro.variables())for(const n of i){const o=n.lowestConsistencyDegree(),a=n.highestConsistencyDegree();o<t&&(t=o),a>e&&(e=a)}f(this,qt,t),f(this,Ht,e)},Qi=function(t,e,i,n,o,a,h){const c=d(this,_,js).call(this,e,a),u=Un(t,i),m=e.difference(c);return d(this,_,Bs).call(this,u,m,c,n,Math.min(o,n),h)},Zi=function(t,e,i,n,o,a){let h=s(this,qt);if(i.domain().size()===0)return h;let c=S.fromVariables(e),u=i.domain().at(0);const m=S.fromVariables(e);for(let b=0;b<i.domain().size()&&h<o;++b){const y=i.domain().at(b);i.assign(y);const E=Math.min(n,d(this,_,tn).call(this,t,i,h,a));if(E>Math.max(h,a)){const j=new Set,It=Math.min(Math.min(E,o),d(this,_,en).call(this,t,e,i,E,o,j));if(It>h&&(h=It,u=y,c=S.fromVariables(e)),j.size){const ct=d(this,_,Qi).call(this,t,e,i,E,o,j,Math.max(a,h));if(s(this,Vt)!==-1)return h;ct>h&&(h=ct,u=y,c=S.fromVariables(e)),m.apply()}}}return c.apply(),i.assign(u),h},Bs=function(t,e,i,n,o,a){for(e=new Set(e),i=new Set(i);;){this.monitor.outputDebugString(`X1 ${t.size}, X2' ${e.size}, X3' ${i.size}`);const h=this.monitor.check(this.pro.degree());if(h!==null)return f(this,Vt,h?1:0),o;if(i.size===0)return o;const c=i.values().next().value,u=d(this,_,Zi).call(this,t,e,c,n,o,a);if(s(this,Vt)!==-1)return o;if(u<a)return s(this,qt);e.add(c),i.delete(c),o=u}},Xi=function(t,e){const i=new Set;for(const o of t)for(const a of o)i.add(a);let n=1;for(const o of i){const a=o.degree();a!==w.UNDEFINED&&a<n&&(n=a)}for(const o of this.pro.constraints())o.lowestConsistencyDegree()<s(this,Ht)&&e.add(o);return n},tn=function(t,e,i,n){let o=1;const a=new Set;for(const h of t){const c=this.pro.constraintsBetween(h,e);for(const u of c)a.add(u)}for(const h of a){const c=h.degree();if(c!==w.UNDEFINED&&(c<o&&(o=c),o<=i||o<=n))return o}return o},en=function(t,e,i,n,o,a){let h=1;const c=new Set;for(const u of t){const m=this.pro.constraintsBetween(u,i);for(const b of m)c.add(b)}for(const u of e){const m=this.pro.constraintsBetween(u,i);for(const b of m)c.add(b)}for(const u of c){const m=u.degree();m!==w.UNDEFINED&&m<h&&(h=m)}for(const u of c){const m=u.degree();m!==w.UNDEFINED&&(m<n||m<o)&&a.add(u)}return h};function Un(g,r){return new Set(g).add(r)}class On extends U{constructor(t){super(t);l(this,Mt);l(this,ss,!0);l(this,At);f(this,At,new Array(this.pro.constraintSize())),s(this,At).fill(1)}name(){return"Fuzzy Breakout"}setRandomness(t){f(this,ss,t)}exec(){for(const a of this.pro.variables())a.isEmpty()&&a.assign(a.domain().at(0));const t=this.pro.degree(),e=new S;let i=t;this.monitor.initialize();const n=new S;let o=null;for(;;){const[a,h]=this.pro.constraintsWithDegree();if(this.monitor.outputDebugString(`Evaluation: ${h}`),i<h&&(e.setProblem(this.pro),i=h,this.monitor.solutionFound(e,i)))return!0;if((o=this.monitor.check(h))!==null)break;d(this,Mt,sn).call(this,a,n)}return o===!1&&!this.monitor.isTargetAssigned()&&t<i&&(e.apply(),o=!0),o}}ss=new WeakMap,At=new WeakMap,Mt=new WeakSet,sn=function(t,e){if(d(this,Mt,nn).call(this,d(this,Mt,rn).call(this,t),e),0<e.size()){const i=s(this,ss)?e.random():e.at(0);i.apply(),e.clear(),this.monitor.outputDebugString("	"+i)}else{for(const i of t)s(this,At)[i.index()]+=1;this.monitor.outputDebugString("Breakout")}},nn=function(t,e){let i=0;for(const n of t){const o=n.value();let a=0;for(const h of n)a+=(1-h.degree())*s(this,At)[h.index()];t:for(const h of n.domain()){if(o===h)continue;n.assign(h);let c=a;for(const u of n)if(c-=(1-u.degree())*s(this,At)[u.index()],c<i)continue t;i<c?(i=c,e.clear(),e.addVariable(n,h)):i!==0&&e.addVariable(n,h)}n.assign(o)}},rn=function(t){const e=new Set;for(const i of t)for(const n of i)e.add(n);return Array.from(e)};class Ln extends U{constructor(t,e=1){super(t);l(this,_t);l(this,it,[]);l(this,is,[]);l(this,ze);f(this,ze,e)}name(){return"Fuzzy GENET"}exec(){if(!d(this,_t,on).call(this))throw new Error;const t=[...Array(s(this,it).length).keys()],e=this.pro.degree(),i=new S;let n=e;this.monitor.initialize();let o=null;for(;;){const a=this.pro.degree();if(this.monitor.outputDebugString(`Evaluation: ${a}`),n<a&&(i.setProblem(this.pro),n=a,this.monitor.solutionFound(i,n)))return!0;if((o=this.monitor.check(a))!==null)break;d(this,_t,an).call(this,t)}return o===!1&&!this.monitor.isTargetAssigned()&&e<n&&(i.apply(),o=!0),o}}it=new WeakMap,is=new WeakMap,ze=new WeakMap,_t=new WeakSet,on=function(){this.monitor.outputDebugString("Start of Network Generation");const t=[];for(const e of this.pro.variables()){if(e.domain().size()===0)return!1;s(this,it).push(new jn(e))}for(const e of this.pro.constraints())if(e.size()===1){const i=e.at(0),n=s(this,it)[i.index()];for(const o of n){const a=i.value();i.assign(o._value),e.degree()<=s(this,ze)&&t.push(new Zs(e,o)),i.assign(a)}}else{const i=e.at(0),n=e.at(1),o=s(this,it)[i.index()],a=s(this,it)[n.index()];for(const h of o){const c=i.value();i.assign(h._value);for(const u of a){const m=n.value();n.assign(u._value),e.degree()<=s(this,ze)&&t.push(new Zs(e,h,u)),n.assign(m)}i.assign(c)}}for(const e of s(this,it))for(const i of e._neurons)i.lockConnections();return f(this,is,t),this.monitor.outputDebugString("End of Network Generation"),!0},an=function(t){let e=!1;for(const i of d(this,_t,hn).call(this,t))s(this,it)[i].setActivityMaximumInput()&&(e=!0);if(e)for(const i of s(this,it))i.applyToVariable();else for(const i of s(this,is))i.refreshWeight()},hn=function(t){for(let e=t.length;e>1;--e){const i=Ds(e),n=t[e-1];t[e-1]=t[i],t[i]=n}return t};class jn{constructor(r){l(this,rs);l(this,ns);l(this,De,0);l(this,dt,[]);T(this,"_neurons",[]);f(this,ns,r);for(const t of r.domain())this._neurons.push(new Bn(t));d(this,rs,Gs).call(this,Ds(this._neurons.length))}applyToVariable(){s(this,ns).assign(this._neurons[s(this,De)]._value)}setActivityMaximumInput(){s(this,dt).length=0;let r=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const i=this._neurons[e].getInput();r<=i&&(r<i&&(r=i,s(this,dt).length=0,t=!1),s(this,dt).push(e),s(this,De)===e&&(t=!0))}return t||s(this,dt).length===0?!1:(d(this,rs,Gs).call(this,s(this,dt)[Ds(s(this,dt).length)]),!0)}[Symbol.iterator](){return this._neurons[Symbol.iterator]()}}ns=new WeakMap,De=new WeakMap,dt=new WeakMap,rs=new WeakSet,Gs=function(r){for(const t of this._neurons)t._isActive=!1;this._neurons[r]._isActive=!0,f(this,De,r)};class Zs{constructor(r,t,e=null){l(this,Yt);l(this,ht);l(this,nt);T(this,"_weight");f(this,Yt,r),f(this,ht,t),f(this,nt,e),this._weight=r.degree()-1,s(this,ht).addConnection(this),s(this,nt)&&s(this,nt).addConnection(this)}getNeuron(r){return r===s(this,ht)?s(this,nt):r===s(this,nt)?s(this,ht):null}refreshWeight(){!s(this,ht)._isActive||s(this,nt)!==null&&!s(this,nt)._isActive||(s(this,Yt).size()===1?this._weight+=s(this,Yt).relation().degree(s(this,ht)._value)-1:this._weight+=s(this,Yt).relation().degree(s(this,ht)._value,s(this,nt)._value)-1)}}Yt=new WeakMap,ht=new WeakMap,nt=new WeakMap;class Bn{constructor(r){l(this,os,[]);l(this,ke,[]);T(this,"_value");T(this,"_isActive",!1);this._value=r}addConnection(r){s(this,ke).push(r)}lockConnections(){f(this,os,[...s(this,ke)]),f(this,ke,null)}getInput(){let r=0;for(const t of s(this,os)){const e=t.getNeuron(this);r+=t._weight*(e===null||e._isActive?1:0)}return r}}os=new WeakMap,ke=new WeakMap;function Ds(g){return Math.floor(Math.random()*Math.floor(g))}class Xs extends U{constructor(t){super(t);l(this,A);l(this,Ne,!0);l(this,mt);l(this,Jt,new Set);l(this,X,new Set);l(this,Kt,[]);l(this,Qt,[]);for(const e of this.pro.constraints())s(this,Kt).push(new Gn(e)),s(this,Qt).push(null);f(this,mt,new Array(this.pro.constraintSize())),s(this,mt).fill(1)}name(){return"SRS3"}setRandomness(t){f(this,Ne,t)}exec(){for(const o of this.pro.variables())o.isEmpty()&&o.assign(o.domain().at(0));const t=this.pro.degree(),e=new S;let i=t;this.monitor.initialize();let n=null;for(;;){const[o,a]=this.pro.constraintsWithDegree();if(this.monitor.outputDebugString(`Evaluation: ${a}`),i<a&&(e.setProblem(this.pro),i=a,this.monitor.solutionFound(e,i)))return!0;if((n=this.monitor.check(a))!==null)break;for(const c of s(this,Kt))c.clear();const h=new Set;for(const c of o){const u=s(this,Kt)[c.index()];h.add(u)}d(this,A,cn).call(this,h)}return n===!1&&!this.monitor.isTargetAssigned()&&t<i&&(e.apply(),n=!0),n}}Ne=new WeakMap,mt=new WeakMap,Jt=new WeakMap,X=new WeakMap,Kt=new WeakMap,Qt=new WeakMap,A=new WeakSet,cn=function(t){this.monitor.outputDebugString("SRS"),s(this,Jt).clear(),s(this,X).clear();for(const e of t)s(this,X).add(e);for(;t.size&&s(this,X).size;){const e=d(this,A,fn).call(this,s(this,X));s(this,X).delete(e),d(this,A,Es).call(this,e.constraint())?t.delete(e)||(e.parent()&&d(this,A,Es).call(this,e.parent().constraint())?d(this,A,ln).call(this,e,t):d(this,A,Ws).call(this,e)):d(this,A,Ws).call(this,e)}return t.size===0},Ws=function(t){this.monitor.outputDebugString("Spread"),s(this,Jt).add(t);for(const e of d(this,A,un).call(this,t))!s(this,Jt).has(e)&&!s(this,X).has(e)&&(e.clear(),t.append(e),s(this,X).add(e))},Es=function(t){this.monitor.outputDebugString("Repair"),s(this,mt)[t.index()]+=1;const e=t.degree(),i=new S;let n=0;for(const o of t){const a=o.value();let h=0;for(const c of o)h+=(1-c.degree())*s(this,mt)[c.index()];t:for(const c of o.domain()){if(a===c||(o.assign(c),t.degree()<=e))continue;let u=h;for(const m of o)if(u-=(1-m.degree())*s(this,mt)[m.index()],u<n)continue t;n<u?(n=u,i.clear(),i.addVariable(o,c)):n!==0&&i.addVariable(o,c)}o.assign(a)}if(0<i.size()){const o=s(this,Ne)?i.random():i.at(0);return o.apply(),this.monitor.outputDebugString("	"+o),!0}return!1},ln=function(t,e){this.monitor.outputDebugString("Shrink");let i=t,n=!1;for(;;){if(i=i.parent(),e.delete(i)){n=!0;break}if(!i.parent()||!d(this,A,Es).call(this,i.parent().constraint()))break}const o=[];i.getDescendants(o),i.clear();for(const a of o)s(this,X).delete(a),s(this,Jt).delete(a);n||s(this,X).add(i)},un=function(t){const e=t.constraint(),i=e.index();if(s(this,Qt)[i]===null){const n=[];for(const o of e.neighbors())n.push(s(this,Kt)[o.index()]);s(this,Qt)[i]=n}return s(this,Qt)[i]},fn=function(t){const e=d(this,A,dn).call(this,d(this,A,mn).call(this,t));return s(this,Ne)?e[Math.floor(Math.random()*e.length)]:e[0]},dn=function(t){let e=Number.MAX_VALUE,i=[];for(const n of t){const o=s(this,mt)[n.constraint().index()];o<e?(e=o,i.length=0,i.push(n)):o===e&&i.push(n)}return i},mn=function(t){let e=Number.MAX_VALUE,i=[];for(const n of t){const o=n.depth();o<e?(e=o,i.length=0,i.push(n)):o===e&&i.push(n)}return i};class Gn{constructor(r){l(this,as);l(this,Zt,0);l(this,Ce,null);l(this,Xt,[]);f(this,as,r)}append(r){f(r,Ce,this),f(r,Zt,s(this,Zt)+1),s(this,Xt).push(r)}clear(){f(this,Ce,null),f(this,Zt,0);for(const r of s(this,Xt))r.clear();s(this,Xt).length=0}constraint(){return s(this,as)}depth(){return s(this,Zt)}parent(){return s(this,Ce)}getDescendants(r){r.push(this);for(const t of s(this,Xt))t.getDescendants(r)}}as=new WeakMap,Zt=new WeakMap,Ce=new WeakMap,Xt=new WeakMap;function Wn(g,r,t=e=>console.log(e)){t("Start Post-Stabilization");let e,i=0;do{t("	Post-Stabilization: count "+i++),e=!1;let n=g.degree();const o=g.variables();for(let a=0;a<o.length;++a){const h=o[a],c=h.value(),u=r.at(a);c!==u.value()&&(u.apply(),n<=g.degree()?e=!0:h.assign(c))}}while(e);return t("Finish Post-Stabilization"),e}function Hn(g,r){return new qn(g,r)}class qn extends U{constructor(t,e){super(t);l(this,Fe);f(this,Fe,e),this.setMonitor(e.getMonitor())}name(){return s(this,Fe).name()+" + PF"}exec(){let t=0,e=0;this.monitor.isDebugMode()&&(t=this.pro.isFuzzy()?this.pro.degree():this.pro.ratio(),e=this.pro.emptyVariableSize());const i=new S;i.setProblem(this.pro);const n=s(this,Fe).exec();return n&&Wn(this.pro,i,this.monitor.outputDebugString.bind(this.monitor)),this.monitor.outputDebugString(`Solver result: ${n?"Success":"Failure"}`),this.monitor.outputDebugString(`Evaluation: ${t} -> ${this.pro.isFuzzy()?this.pro.degree():this.pro.ratio()}`),this.monitor.outputDebugString(`Empty variable size: ${e} -> ${this.pro.emptyVariableSize()}`),n}}Fe=new WeakMap;class Ve{static crispSolverNames(){return["Forward Checking","Max Forward Checking","Local Changes","Local Changes Ex","Breakout","GENET","Crisp SRS3"]}static fuzzySolverNames(){return["Full Checking","Fuzzy Forward Checking","Flexible Local Changes","Flexible Local Changes Ex","Fuzzy Breakout","Fuzzy GENET","SRS3","SRS3 PF"]}static async createSolver(r,t){const e=await Ve.createCrispSolver(r,t);if(e)return e;const i=await Ve.createFuzzySolver(r,t);return i||null}static async createCrispSolver(r,t){switch(r.replaceAll(" ","")){case"ForwardChecking":case"forward-checking":return new Sn(t);case"MaxForwardChecking":case"max-forward-checking":return new xn(t);case"LocalChanges":case"local-changes":return new zn(t);case"LocalChangesEx":case"local-changes-ex":return new kn(t);case"Breakout":case"breakout":return new Cn(t);case"GENET":case"genet":return new Fn(t);case"CrispSRS3":case"crisp-srs3":return new Mn(t)}return null}static async createFuzzySolver(r,t){switch(r.replaceAll(" ","")){case"FullChecking":case"full-checking":return new In(t);case"FuzzyForwardChecking":case"fuzzy-forward-checking":return new Rn(t);case"FlexibleLocalChanges":case"flexible-local-changes":return new Pn(t);case"FlexibleLocalChangesEx":case"flexible-local-changes-ex":return new Tn(t);case"FuzzyBreakout":case"fuzzy-breakout":return new On(t);case"FuzzyGENET":case"fuzzy-genet":return new Ln(t);case"SRS3":case"srs3":return new Xs(t);case"SRS3PF":case"SRS3_PF":case"srs3-pf":return Hn(t,new Xs(t))}return null}}function Yn(g,r){const t=ti(g);return t/(t+ti(r))}function ti(g){let r,t,e,i,n;if(g>1){r=Math.sqrt(2*g-1);do do{do{do t=Math.random(),e=2*Math.random()-1;while(t*t+e*e>=1||t===0);e=e/t,t=r*e+g-1}while(t<=0);i=(g-1)*Math.log(t/(g-1))-r*e}while(i<=-50);while((1+e*e)*Math.exp(i)<=Math.random())}else{r=Math.E/(g+Math.E);do Math.random()<r?(t=0,e=1,n=Math.random(),n>0&&(t=Math.exp(Math.log(n)/g),e=Math.exp(-t))):(n=Math.random(),t=1,e=0,n>0&&(t=1-Math.log(n),e=Math.exp((g-1)*Math.log(t))));while(Math.random()>=e)}return t}class Jn{constructor(){T(this,"_debug",!0);l(this,ps,r=>console.log(r))}setDebugMode(r){this._debug=r}setDebugOutput(r){this._debugOutput=r}_debugOutput(r){this._debug&&s(this,ps).call(this,r)}}ps=new WeakMap;class Kn extends Jn{constructor(t,e,i,n=null){super();l(this,bs);l(this,tt);l(this,te);l(this,gt);l(this,rt);f(this,tt,t),f(this,te,e),f(this,gt,i),f(this,rt,n??t)}getVariableCount(){return s(this,tt)}setVariableCount(t){f(this,tt,t)}getDensity(){return s(this,te)}setDensity(t){f(this,te,t)}getAverageTightness(){return s(this,gt)}setAverageTightness(t){f(this,gt,t)}getDomainSize(){return s(this,rt)}setDomainSize(t){f(this,rt,t)}isFuzzy(){return!0}createProblem(t){const e=s(this,te)*((s(this,tt)*s(this,tt)-s(this,tt))/2)|0,i=[];for(let n=0;n<s(this,tt);++n){const o=t.createVariable({domain:t.createDomain({min:0,max:s(this,rt)-1}),value:0,name:""});i.push(o)}for(;t.constraintSize()<e;){const n=ei(s(this,tt)),o=ei(s(this,tt));n!==o&&t.constraintsBetween(i[n],i[o]).length===0&&t.createConstraint({relation:new Qn(d(this,bs,gn).call(this)),variables:[i[n],i[o]]})}return t}}tt=new WeakMap,te=new WeakMap,gt=new WeakMap,rt=new WeakMap,bs=new WeakSet,gn=function(){const t=[];for(let e=0;e<s(this,rt);++e)t.push(new Array(s(this,rt)));for(let e=0;e<s(this,rt);++e)for(let i=0;i<s(this,rt);++i){const n=s(this,gt)===0?Number.MAX_VALUE:(1-s(this,gt))/s(this,gt);t[e][i]=Yn(1,n)}return t};function ei(g){return Math.floor(Math.random()*Math.floor(g))}class Qn extends Hs{constructor(t){super();l(this,hs);f(this,hs,t)}degree(t,e){return s(this,hs)[t][e]}}hs=new WeakMap,onmessage=async g=>{const{task:r,args:t}=g.data;switch(r){case"create":Zn(...t);break;case"solve":Xn(...t);break}};let ks=null,Ns=null;function Zn(g,r,t){ks=new Kn(g,r,t),ks.setDebugOutput(si),Ns=ks.createProblem(new En)}async function Xn(g,r){const t=Date.now(),e=Ve.fuzzySolverNames()[g],i=new qs;i.setTimeLimit(5e3),i.setTarget(r),i.setDebugOutput(si),i.setDebugMode(!0);const n=await Ve.createSolver(e,Ns);n.setMonitor(i);const o=n.solve(),a=Date.now()-t,h=Ns.degree();postMessage({result:o,time:a,deg:h,solver:n.name()})}function si(g){postMessage({log:g})}})();
