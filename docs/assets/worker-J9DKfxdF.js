var ot=Object.defineProperty;var et=n=>{throw TypeError(n)};var ut=(n,e,t)=>e in n?ot(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var A=(n,e,t)=>ut(n,typeof e!="symbol"?e+"":e,t),st=(n,e,t)=>e.has(n)||et("Cannot "+t);var s=(n,e,t)=>(st(n,e,"read from private field"),t?t.call(n):e.get(n)),o=(n,e,t)=>e.has(n)?et("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),a=(n,e,t,i)=>(st(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t);var Z=(n,e,t,i)=>({set _(r){a(n,e,r,t)},get _(){return s(n,e,i)}});var L,T;class it{constructor(){o(this,L,-1);o(this,T,"");A(this,"userObject",null)}setIndex(e){a(this,L,e)}setName(e){a(this,T,e)}index(){return s(this,L)}name(){return s(this,T)}}L=new WeakMap,T=new WeakMap;var z,I,v,$,l;const E=class E extends it{constructor(t,i){super();o(this,I);o(this,v);o(this,$,s(E,z));o(this,l,[]);a(this,I,t),a(this,v,i)}toString(){const t=this.name(),i=t?`(${t})`:"",r=this.isEmpty()?"<empty>":""+this.value();return`x${this.index()}${i} = ${r}`}size(){return s(this,l).length}at(t){return s(this,l).at(t)}has(t){return s(this,l).includes(t)}indexOf(t){return s(this,l).indexOf(t)}neighbors(){const t=[];for(const i of s(this,l))for(const r of i)r!==this&&t.push(r);return t}[Symbol.iterator](){return s(this,l)[Symbol.iterator]()}owner(){return s(this,I)}connect(t){if(s(this,l).includes(t))throw new RangeError;s(this,l).push(t)}disconnect(t){if(!s(this,l).includes(t))throw new RangeError;a(this,l,s(this,l).filter(i=>i!==t))}domain(t){if(t===void 0)return s(this,v);a(this,v,t),this.clear()}assign(t){a(this,$,t)}clear(){this.assign(s(E,z))}value(){return s(this,$)}isEmpty(){return this.value()===s(E,z)}};z=new WeakMap,I=new WeakMap,v=new WeakMap,$=new WeakMap,l=new WeakMap,o(E,z,Number.MIN_VALUE);let O=E;class M{static createRangedDomain(e,t){return new ct(e,t)}static createArbitraryDomain(e){return new ht(e)}random(){return this.at(Math.floor(Math.random()*this.size()))}}var m;class ht extends M{constructor(t){super();o(this,m);a(this,m,[...t])}contains(t){return s(this,m).includes(t)}indexOf(t){return s(this,m).indexOf(t)}size(){return s(this,m).length}at(t){return s(this,m)[t]}[Symbol.iterator](){return s(this,m)[Symbol.iterator]()}}m=new WeakMap;var g,p;class ct extends M{constructor(t,i){super();o(this,g);o(this,p);a(this,g,t|0),a(this,p,i|0)}contains(t){return s(this,g)<=t&&t<=s(this,p)}indexOf(t){return s(this,g)<=t&&t<=s(this,p)?t-s(this,g):-1}size(){return s(this,p)-s(this,g)+1}at(t){return s(this,g)+t}[Symbol.iterator](){let t=s(this,g);const i=s(this,p);return{next(){return t<=i?{value:t++,done:!1}:{value:null,done:!0}}}}}g=new WeakMap,p=new WeakMap;class rt{}class lt extends rt{degree(...e){return this.isSatisfied(...e)}}class ft extends rt{isSatisfied(...e){const t=this.degree(...e);return 0<t&&t<1?0:t}}class W extends it{constructor(t){super();A(this,"r");A(this,"xs",[]);this.r=t}static create(t,i){return i.length===1?new gt(t,i[0]):i.length===2?new dt(t,i[0],i[1]):i.length===3?new mt(t,i[0],i[1],i[2]):new pt(t,...i)}toString(){const t=this.name(),i=t?`(${t})`:"",r=this.degree(),u=r<0?"UNDEFINED":""+r;return`c${this.index()}${i} = ${u}`}size(){return this.xs.length}at(t){return this.xs.at(t)}has(t){return this.xs.includes(t)}indexOf(t){return this.xs.indexOf(t)}neighbors(){const t=[];for(const i of this.xs)for(const r of i)r!==this&&t.push(r);return t}[Symbol.iterator](){return this.xs[Symbol.iterator]()}relation(){return this.r}isFuzzy(){return this.r instanceof ft}}class gt extends W{constructor(e,t){super(e),this.xs=[t]}emptyVariableSize(){return this.xs[0].isEmpty()?1:0}isDefined(){return!this.xs[0].isEmpty()}isSatisfied(){return this.xs[0].isEmpty()?-1:this.r.isSatisfied(this.xs[0].value())?1:0}degree(){return this.xs[0].isEmpty()?-1:this.r.degree(this.xs[0].value())}}class dt extends W{constructor(e,t,i){super(e),this.xs=[t,i]}emptyVariableSize(){let e=0;return this.xs[0].isEmpty()&&++e,this.xs[1].isEmpty()&&++e,e}isDefined(){return!this.xs[0].isEmpty()&&!this.xs[1].isEmpty()}isSatisfied(){return this.xs[0].isEmpty()||this.xs[1].isEmpty()?-1:this.r.isSatisfied(this.xs[0].value(),this.xs[1].value())?1:0}degree(){return this.xs[0].isEmpty()||this.xs[1].isEmpty()?-1:this.r.degree(this.xs[0].value(),this.xs[1].value())}}class mt extends W{constructor(e,t,i,r){super(e),this.xs=[t,i,r]}emptyVariableSize(){let e=0;return this.xs[0].isEmpty()&&++e,this.xs[1].isEmpty()&&++e,this.xs[2].isEmpty()&&++e,e}isDefined(){return!this.xs[0].isEmpty()&&!this.xs[1].isEmpty()&&!this.xs[2].isEmpty()}isSatisfied(){return this.xs[0].isEmpty()||this.xs[1].isEmpty()||this.xs[2].isEmpty()?-1:this.r.isSatisfied(this.xs[0].value(),this.xs[1].value(),this.xs[2].value())?1:0}degree(){return this.xs[0].isEmpty()||this.xs[1].isEmpty()||this.xs[2].isEmpty()?-1:this.r.degree(this.xs[0].value(),this.xs[1].value(),this.xs[2].value())}}var x;class pt extends W{constructor(t,...i){super(t);o(this,x);this.xs=[...i],a(this,x,new Array(this.xs.length))}emptyVariableSize(){let t=0;for(const i of this.xs)t+=i.isEmpty()?1:0;return t}isDefined(){for(const t of this.xs)if(t.isEmpty())return!1;return!0}isSatisfied(){for(let t=0;t<this.xs.length;++t){const i=this.xs[t];if(i.isEmpty())return-1;s(this,x)[t]=i.value()}return this.r.isSatisfied(...s(this,x))?1:0}degree(){for(let t=0;t<this.xs.length;++t){const i=this.xs[t];if(i.isEmpty())return-1;s(this,x)[t]=i.value()}return this.r.degree(...s(this,x))}}x=new WeakMap;var C,G,w,c,h;class xt{constructor(){o(this,C,(e,t)=>new O(e,t));o(this,G,(e,t)=>W.create(e,t));o(this,w,!1);o(this,c,[]);o(this,h,[])}setVariableFactory(e){a(this,C,e)}setConstraintFactory(e){a(this,G,e)}addVariable(e){e.setIndex(s(this,c).length),s(this,c).push(e)}createDomain(e,t=null){if(Array.isArray(e))return M.createArbitraryDomain(e);if(t!==null)return M.createRangedDomain(e,t);throw new RangeError}createVariable(e,t=null,i){if(e instanceof O){const r=s(this,C).call(this,this,e.domain());return this.addVariable(r),r.setName(r.name()),r.assign(r.value()),r}else if(e instanceof M){if(t!==null&&!e.contains(t))throw new Error;const r=s(this,C).call(this,this,e);return this.addVariable(r),t!==null&&r.assign(t),i&&r.setName(i),r}throw new RangeError}createConstraint(e,t,i){for(const u of t)if(u.owner()!==this)throw new RangeError;const r=s(this,G).call(this,e,t);r.setIndex(s(this,h).length),s(this,h).push(r);for(const u of t)u.connect(r);return r.isFuzzy()&&a(this,w,!0),i&&r.setName(i),r}removeConstraint(e){const t=s(this,h).indexOf(e);s(this,h).splice(t,1);for(let i=t;i<s(this,h).length;++i)s(this,h)[i].setIndex(i);for(const i of e)i.disconnect(e);a(this,w,!1);for(const i of s(this,h))if(i.isFuzzy()){a(this,w,!0);break}}clearAllVariables(){for(const e of s(this,c))e.clear()}reverseVariables(){s(this,c).reverse();for(let e=0;e<s(this,c).length;++e)s(this,c)[e].setIndex(e)}sortVariables(e){s(this,c).sort(e);for(let t=0;t<s(this,c).length;++t)s(this,c)[t].setIndex(t)}variables(){return s(this,c)}variableSize(){return s(this,c).length}variableAt(e){return s(this,c)[e]}variableOf(e){for(const t of s(this,c))if(t.name()===e)return t;return null}hasVariable(e){return s(this,c).includes(e)}constraints(){return s(this,h)}constraintSize(){return s(this,h).length}constraintAt(e){return s(this,h)[e]}constraintOf(e){for(const t of s(this,h))if(t.name()===e)return t;return null}hasConstraint(e){return s(this,h).includes(e)}constraintsBetween(e,t){const i=[];for(const r of e)r.has(t)&&i.push(r);return i}isFuzzy(){return s(this,w)}constraintDensity(){return s(this,h).length/s(this,c).length}emptyVariableSize(){let e=0;for(const t of s(this,c))e+=t.isEmpty()?1:0;return e}hasEmptyDomain(){for(const e of s(this,c))if(e.domain().size()===0)return!0;return!1}degree(){let e=1;for(const t of s(this,h)){const i=t.degree();if(i<0)return i;i<e&&(e=i)}return e}constraintsWithDegree(){const e=[];let t=1;for(const i of s(this,h)){const r=i.degree();r<t?(t=r,e.length=0,e.push(i)):r-t<Number.MIN_VALUE*10&&e.push(i)}return[e,t]}averageDegree(){let e=0;for(const t of s(this,h))e+=t.degree();return e/s(this,h).length}ratio(){return this.satisfiedConstraintSize()/s(this,h).length}satisfiedConstraintSize(){let e=0;for(const t of s(this,h))e+=t.isSatisfied()===1?1:0;return e}violatingConstraintSize(){return s(this,h).length-this.satisfiedConstraintSize()}satisfiedConstraints(){const e=[];for(const t of s(this,h))t.isSatisfied()===1&&e.push(t);return e}violatingConstraints(){const e=[];for(const t of s(this,h))t.isSatisfied()===0&&e.push(t);return e}}C=new WeakMap,G=new WeakMap,w=new WeakMap,c=new WeakMap,h=new WeakMap;var F,B,P,Q,D,b,k,U,X,_,j;class bt{constructor(){o(this,F,!0);o(this,B,e=>console.log(e));o(this,P,()=>!1);o(this,Q,Number.MAX_SAFE_INTEGER);o(this,D,null);o(this,b,.8);o(this,k,null);o(this,U,0);o(this,X,0);o(this,_,-1);o(this,j,0)}initialize(){a(this,U,s(this,D)===null?Number.MAX_VALUE:Date.now()+s(this,D)),a(this,X,0)}check(e=null){if(e!==null&&s(this,b)!==null&&s(this,b)<=e)return this.outputDebugString("Stop: Current evaluation value is above the target"),!0;if(s(this,Q)<Z(this,X)._++)return this.outputDebugString("Stop: Number of iterations has reached the limit"),!1;if(s(this,U)<Date.now())return this.outputDebugString("Stop: Time limit has been reached"),!1;if(e!==null&&s(this,k)!==null)if(e!==-1&&s(this,_)===e){if(s(this,k)<Z(this,j)._++)return this.outputDebugString("Stop: Evaluation value has not changed for a certain number of times"),!1}else a(this,_,e),a(this,j,0);return null}solutionFound(e,t){return s(this,P).call(this,e,t)}outputDebugString(e){s(this,F)&&s(this,B).call(this,e)}isDebugMode(){return s(this,F)}isTargetAssigned(){return s(this,b)!==null}getTarget(){return s(this,b)}setIterationLimit(e=null){a(this,Q,e===null?Number.MAX_SAFE_INTEGER:e)}setTimeLimit(e=null){a(this,D,e)}setTarget(e=null){a(this,b,e)}setSameEvaluationLimit(e=null){a(this,k,e)}setListener(e){a(this,P,e)}setDebugMode(e){a(this,F,e)}setDebugOutput(e){a(this,B,e)}}F=new WeakMap,B=new WeakMap,P=new WeakMap,Q=new WeakMap,D=new WeakMap,b=new WeakMap,k=new WeakMap,U=new WeakMap,X=new WeakMap,_=new WeakMap,j=new WeakMap;var N;class yt extends O{constructor(t,i,r){super(t,i);o(this,N);a(this,N,r)}assign(t){super.assign(t),s(this,N)&&s(this,N).call(this,this,t)}}N=new WeakMap;class V{static crispSolverNames(){return["Forward Checking","Max Forward Checking","Local Changes","Breakout","GENET","Crisp SRS3"]}static fuzzySolverNames(){return["Full Checking","Fuzzy Forward Checking","Flexible Local Changes","Fuzzy Breakout","Fuzzy GENET","SRS3","SRS3 PF"]}static async createSolver(e){const t=await V.createCrispSolver(e);if(t)return t;const i=await V.createFuzzySolver(e);return i||null}static async createCrispSolver(e){switch(e.replaceAll(" ","")){case"ForwardChecking":case"forward-checking":const{ForwardChecking:t}=await import("./forward-checking-BRf2PZrI.js");return new t;case"MaxForwardChecking":case"max-forward-checking":const{MaxForwardChecking:i}=await import("./max-forward-checking-D_6XgnNM.js");return new i;case"LocalChanges":case"local-changes":const{LocalChanges:r}=await import("./local-changes-B7OM290E.js");return new r;case"Breakout":case"breakout":const{Breakout:u}=await import("./breakout-P9qAfL0O.js");return new u;case"GENET":case"genet":const{GENET:d}=await import("./genet-Cxz8W9nj.js");return new d;case"CrispSRS3":case"crisp-srs3":const{CrispSRS3:S}=await import("./crisp-srs3-eVadZ53Y.js");return new S}return null}static async createFuzzySolver(e){switch(e.replaceAll(" ","")){case"FullChecking":case"full-checking":const{FullChecking:t}=await import("./full-checking-D1lU-3uH.js");return new t;case"FuzzyForwardChecking":case"fuzzy-forward-checking":const{FuzzyForwardChecking:i}=await import("./fuzzy-forward-checking-CqLqHL_K.js");return new i;case"FlexibleLocalChanges":case"flexible-local-changes":const{FlexibleLocalChanges:r}=await import("./flexible-local-changes-Bw0Y-OTQ.js");return new r;case"FuzzyBreakout":case"fuzzy-breakout":const{FuzzyBreakout:u}=await import("./fuzzy-breakout-DBpwmBwb.js");return new u;case"FuzzyGENET":case"fuzzy-genet":const{FuzzyGENET:d}=await import("./fuzzy-genet-B51E4UiM.js");return new d;case"SRS3":case"srs3":const{SRS3:S}=await import("./srs3-aUX5hif5.js");return new S;case"SRS3PF":case"SRS3_PF":case"srs3-pf":{const{SRS3:K}=await import("./srs3-aUX5hif5.js"),{wrapWithPostStabilizer:Y}=await import("./post-stabilizer-CZp1NwKo.js");return Y(new K)}}return null}}var J;class wt{constructor(){A(this,"_debug",!0);o(this,J,e=>console.log(e))}setDebugMode(e){this._debug=e}setDebugOutput(e){this._debugOutput=e}_debugOutput(e){this._debug&&s(this,J).call(this,e)}}J=new WeakMap;var f;class St extends wt{constructor(t){super();o(this,f);a(this,f,t)}getQueenSize(){return s(this,f)}setQueenSize(t){a(this,f,t)}isFuzzy(){return!1}createProblem(t){const i=[];for(let r=0;r<s(this,f);++r){const u=t.createVariable(t.createDomain(1,s(this,f)),1,`Queen ${r}`);i.push(u)}for(let r=0;r<s(this,f);++r)for(let u=r+1;u<s(this,f);++u)t.createConstraint(new Et(r,u),[i[r],i[u]]);return t}printResult(t){for(let i=0;i<s(this,f);++i){let r="";if(t.variableAt(i).isEmpty())for(let u=0;u<s(this,f);++u)r+="- ";else for(let u=0;u<s(this,f);++u)r+=t.variableAt(i).value()-1===u?"o ":"- ";this._debugOutput(r)}}}f=new WeakMap;var R;class Et extends lt{constructor(t,i){super();o(this,R);a(this,R,i-t)}isSatisfied(t,i){return t!==i&&t!==i+s(this,R)&&t!==i-s(this,R)?1:0}}R=new WeakMap;onmessage=async n=>{const{task:e,args:t}=n.data;switch(e){case"create":zt(...t);break;case"solve":vt(...t);break}};let q=null,y=null,H=!1;function zt(n){q=new St(n),q.setDebugOutput(nt);const e=(t,i)=>Ct(i-1,t.index());y=new xt,y.setVariableFactory((t,i)=>new yt(t,i,e)),y=q.createProblem(y)}async function vt(n,e,t,i){const r=Date.now(),u=V.crispSolverNames()[n],d=new bt;d.setTarget(e===-1?null:e),d.setTimeLimit(t===-1?null:t),d.setDebugOutput(nt),d.setDebugMode(i);const S=await V.createSolver(u);H=i;const K=S.solve(y,d),Y=Date.now()-r,at=y.ratio();H=!0,q.printResult(y);for(const tt of y.variables())tt.assign(tt.value());postMessage({result:K,time:Y,ev:at,solver:S.name()})}function nt(n){H&&postMessage({log:n})}function Ct(n,e){H&&postMessage({board:{x:n,y:e}})}export{bt as M,O as V};
