var or=Object.defineProperty;var Mi=E=>{throw TypeError(E)};var ar=(E,z,V)=>z in E?or(E,z,{enumerable:!0,configurable:!0,writable:!0,value:V}):E[z]=V;var O=(E,z,V)=>ar(E,typeof z!="symbol"?z+"":z,V),oi=(E,z,V)=>z.has(E)||Mi("Cannot "+V);var s=(E,z,V)=>(oi(E,z,"read from private field"),V?V.call(E):z.get(E)),f=(E,z,V)=>z.has(E)?Mi("Cannot add the same private member more than once"):z instanceof WeakSet?z.add(E):z.set(E,V),l=(E,z,V,de)=>(oi(E,z,"write to private field"),de?de.call(E,V):z.set(E,V),V),d=(E,z,V)=>(oi(E,z,"access private method"),V);var H=(E,z,V,de)=>({set _(Ps){l(E,z,Ps,V)},get _(){return s(E,z,de)}});(function(){"use strict";var _e,Ue,me,$e,pe,He,G,ct,xt,pt,_,b,m,N,$,we,Pe,_t,R,I,Be,Ut,St,Ot,T,Nt,K,Vt,P,We,Ct,Ge,De,ve,Q,Ri,Ii,Ti,ji,ai,it,qe,bt,$t,ye,Ht,Ee,ze,nt,hi,Fi,_i,Ui,Lt,ci,ui,Ye,Je,wt,U,$i,js,Hi,fi,Fs,Vs,Pi,Ke,Qe,Dt,q,Bi,li,Wi,Gi,di,Ze,At,xe,qi,Yi,rt,Xe,Se,Ji,Ki,ts,Oe,vt,es,gi,Bt,Mt,ut,Ci,Ne,ss,Li,is,Wt,Z,Ve,Gt,B,Qi,_s,Zi,mi,Xi,qt,Yt,ns,Ai,k,Jt,Rt,C,Kt,Qt,ke,rs,ft,os,Zt,as,v,tn,Us,pi,en,sn,nn,rn,on,an,hn,bi,wi,cn,A,Xt,It,j,te,ee,Ce,se,F,un,fn,ln,dn,Di,vi,gn,ie,yi,mn,ne,re,hs,cs,lt,L,Ei,pn,bn,wn,$s,Dn,vn,yn,Cs,En,oe,ae,us,fs,dt,M,zi,zn,xn,Sn,xi,On,Nn,Vn,ls,Tt,Ae,Me,kn,Cn,ot,ds,gs,Re,Ln,An,ms,Ie,yt,ps,Si,he,gt,at,Te,bs,ce,et,je,ue,Et,ws,Ds,vs,Y,Mn,Hs,Rn,In,Tn,fe,jt,ys,Es,Oi,Rs,st,le,zt,ht,Is,jn,xs;class E{constructor(){f(this,_e,-1);f(this,Ue,"");O(this,"userObject",null);O(this,"solverObject",null)}setIndex(r){l(this,_e,r)}setName(r){l(this,Ue,r)}index(){return s(this,_e)}name(){return s(this,Ue)}}_e=new WeakMap,Ue=new WeakMap;const be=class be extends E{constructor(t,e){super();f(this,$e);f(this,pe);f(this,He,s(be,me));f(this,G,[]);l(this,$e,t),l(this,pe,e)}toString(){const t=this.name(),e=t?`(${t})`:"",i=this.isEmpty()?"<empty>":""+this.value();return`x${this.index()}${e} = ${i}`}size(){return s(this,G).length}at(t){return s(this,G).at(t)}has(t){return s(this,G).includes(t)}indexOf(t){return s(this,G).indexOf(t)}neighbors(){const t=[];for(const e of s(this,G))for(const i of e)i!==this&&t.push(i);return t}[Symbol.iterator](){return s(this,G)[Symbol.iterator]()}owner(){return s(this,$e)}connect(t){if(s(this,G).includes(t))throw new RangeError;s(this,G).push(t)}disconnect(t){if(!s(this,G).includes(t))throw new RangeError;l(this,G,s(this,G).filter(e=>e!==t))}domain(t){if(t===void 0)return s(this,pe);l(this,pe,t),this.clear()}assign(t){l(this,He,t)}clear(){this.assign(s(be,me))}value(){return s(this,He)}isEmpty(){return this.value()===s(be,me)}};me=new WeakMap,$e=new WeakMap,pe=new WeakMap,He=new WeakMap,G=new WeakMap,f(be,me,Number.MIN_VALUE);let z=be;class V{random(){return this.at(Math.floor(Math.random()*this.size()))}}class de extends V{constructor(t,e){super();f(this,ct);f(this,xt);l(this,ct,t|0),l(this,xt,e|0)}contains(t){return s(this,ct)<=t&&t<=s(this,xt)}indexOf(t){return s(this,ct)<=t&&t<=s(this,xt)?t-s(this,ct):-1}size(){return s(this,xt)-s(this,ct)+1}at(t){return s(this,ct)+t}[Symbol.iterator](){let t=s(this,ct);const e=s(this,xt);return{next(){return t<=e?{value:t++,done:!1}:{value:null,done:!0}}}}}ct=new WeakMap,xt=new WeakMap;class Ps extends V{constructor(t){super();f(this,pt);l(this,pt,[...t])}contains(t){return s(this,pt).includes(t)}indexOf(t){return s(this,pt).indexOf(t)}size(){return s(this,pt).length}at(t){return s(this,pt)[t]}[Symbol.iterator](){return s(this,pt)[Symbol.iterator]()}}pt=new WeakMap;const Ns=class Ns extends E{constructor(t){super();O(this,"rel");this.rel=t}crispRelation(){return this.rel}fuzzyRelation(){return this.rel}isFuzzy(){return"satisfactionDegree"in this.rel}toString(){const t=this.name(),e=t?`(${t})`:"",i=this.satisfactionDegree(),n=i===Ns.UNDEFINED?"UNDEFINED":""+i;return`c${this.index()}${e} = ${n}`}};O(Ns,"UNDEFINED",-1);let D=Ns;class Fn extends D{constructor(t,e){super(t);f(this,_,[]);l(this,_,[e])}size(){return 1}at(t){return s(this,_).at(t)}has(t){return t===s(this,_)[0]}indexOf(t){return t===s(this,_)[0]?0:-1}neighbors(){const t=[];for(const e of s(this,_)[0])e!==this&&t.push(e);return t}[Symbol.iterator](){return s(this,_)[Symbol.iterator]()}emptyVariableSize(){return s(this,_)[0].isEmpty()?1:0}isDefined(){return!s(this,_)[0].isEmpty()}isSatisfied(){return s(this,_)[0].isEmpty()?D.UNDEFINED:this.crispRelation().isSatisfied(s(this,_)[0].value())?1:0}satisfactionDegree(){return s(this,_)[0].isEmpty()?D.UNDEFINED:this.fuzzyRelation().satisfactionDegree(s(this,_)[0].value())}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==D.UNDEFINED)return t;let e=0;for(const i of s(this,_)[0].domain()){const n=this.fuzzyRelation().satisfactionDegree(i);if(n>e&&(e=n),e===1)break}return e}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==D.UNDEFINED)return t;let e=1;for(const i of s(this,_)[0].domain()){const n=this.fuzzyRelation().satisfactionDegree(i);if(n<e&&(e=n),e===0)break}return e}}_=new WeakMap;class _n extends D{constructor(t,e,i){super(t);f(this,b,[]);l(this,b,[e,i])}size(){return 2}at(t){return s(this,b).at(t)}has(t){return s(this,b)[0]===t||s(this,b)[1]===t}indexOf(t){return t===s(this,b)[0]?0:t===s(this,b)[1]?1:-1}neighbors(){const t=[];for(const e of s(this,b)[0])e!==this&&t.push(e);for(const e of s(this,b)[1])e!==this&&t.push(e);return t}[Symbol.iterator](){return s(this,b)[Symbol.iterator]()}emptyVariableSize(){let t=0;return s(this,b)[0].isEmpty()&&++t,s(this,b)[1].isEmpty()&&++t,t}isDefined(){return!s(this,b)[0].isEmpty()&&!s(this,b)[1].isEmpty()}isSatisfied(){return s(this,b)[0].isEmpty()||s(this,b)[1].isEmpty()?D.UNDEFINED:this.crispRelation().isSatisfied(s(this,b)[0].value(),s(this,b)[1].value())?1:0}satisfactionDegree(){return s(this,b)[0].isEmpty()||s(this,b)[1].isEmpty()?D.UNDEFINED:this.fuzzyRelation().satisfactionDegree(s(this,b)[0].value(),s(this,b)[1].value())}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==D.UNDEFINED)return t;let e=0;const i=s(this,b)[0].value(),n=s(this,b)[1].value(),o=s(this,b)[0].domain(),a=s(this,b)[1].domain();if(s(this,b)[0].isEmpty()&&!s(this,b)[1].isEmpty())for(const h of o){const c=this.fuzzyRelation().satisfactionDegree(h,n);if(c>e&&(e=c),e===1)break}else if(!s(this,b)[0].isEmpty()&&s(this,b)[1].isEmpty())for(const h of a){const c=this.fuzzyRelation().satisfactionDegree(i,h);if(c>e&&(e=c),e===1)break}else for(const h of o)for(const c of a){const u=this.fuzzyRelation().satisfactionDegree(h,c);if(u>e&&(e=u),e===1)break}return e}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==D.UNDEFINED)return t;let e=1;const i=s(this,b)[0].value(),n=s(this,b)[1].value(),o=s(this,b)[0].domain(),a=s(this,b)[1].domain();if(s(this,b)[0].isEmpty()&&!s(this,b)[1].isEmpty())for(const h of o){const c=this.fuzzyRelation().satisfactionDegree(h,n);if(c<e&&(e=c),e===0)break}else if(!s(this,b)[0].isEmpty()&&s(this,b)[1].isEmpty())for(const h of a){const c=this.fuzzyRelation().satisfactionDegree(i,h);if(c<e&&(e=c),e===0)break}else for(const h of o)for(const c of a){const u=this.fuzzyRelation().satisfactionDegree(h,c);if(u<e&&(e=u),e===0)break}return e}}b=new WeakMap;class Un extends D{constructor(t,e,i,n){super(t);f(this,m,[]);l(this,m,[e,i,n])}size(){return 3}at(t){return s(this,m).at(t)}has(t){return s(this,m)[0]===t||s(this,m)[1]===t||s(this,m)[2]===t}indexOf(t){return t===s(this,m)[0]?0:t===s(this,m)[1]?1:t===s(this,m)[2]?2:-1}neighbors(){const t=[];for(const e of s(this,m)[0])e!==this&&t.push(e);for(const e of s(this,m)[1])e!==this&&t.push(e);for(const e of s(this,m)[2])e!==this&&t.push(e);return t}[Symbol.iterator](){return s(this,m)[Symbol.iterator]()}emptyVariableSize(){let t=0;return s(this,m)[0].isEmpty()&&++t,s(this,m)[1].isEmpty()&&++t,s(this,m)[2].isEmpty()&&++t,t}isDefined(){return!s(this,m)[0].isEmpty()&&!s(this,m)[1].isEmpty()&&!s(this,m)[2].isEmpty()}isSatisfied(){return s(this,m)[0].isEmpty()||s(this,m)[1].isEmpty()||s(this,m)[2].isEmpty()?D.UNDEFINED:this.crispRelation().isSatisfied(s(this,m)[0].value(),s(this,m)[1].value(),s(this,m)[2].value())?1:0}satisfactionDegree(){return s(this,m)[0].isEmpty()||s(this,m)[1].isEmpty()||s(this,m)[2].isEmpty()?D.UNDEFINED:this.fuzzyRelation().satisfactionDegree(s(this,m)[0].value(),s(this,m)[1].value(),s(this,m)[2].value())}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==D.UNDEFINED)return t;let e=1;const i=s(this,m)[0].value(),n=s(this,m)[1].value(),o=s(this,m)[2].value(),a=s(this,m)[0].domain(),h=s(this,m)[1].domain(),c=s(this,m)[2].domain();if(s(this,m)[0].isEmpty()&&!s(this,m)[1].isEmpty()&&!s(this,m)[2].isEmpty())for(const u of a){const g=this.fuzzyRelation().satisfactionDegree(u,n,o);if(g>e&&(e=g),e===1)break}else if(!s(this,m)[0].isEmpty()&&s(this,m)[1].isEmpty()&&!s(this,m)[2].isEmpty())for(const u of h){const g=this.fuzzyRelation().satisfactionDegree(i,u,o);if(g>e&&(e=g),e===1)break}else if(!s(this,m)[0].isEmpty()&&!s(this,m)[1].isEmpty()&&s(this,m)[2].isEmpty())for(const u of c){const g=this.fuzzyRelation().satisfactionDegree(i,n,u);if(g>e&&(e=g),e===1)break}else if(s(this,m)[0].isEmpty()&&s(this,m)[1].isEmpty()&&!s(this,m)[2].isEmpty())for(const u of a)for(const g of h){const p=this.fuzzyRelation().satisfactionDegree(u,g,o);if(p>e&&(e=p),e===1)break}else if(s(this,m)[0].isEmpty()&&!s(this,m)[1].isEmpty()&&s(this,m)[2].isEmpty())for(const u of a)for(const g of c){const p=this.fuzzyRelation().satisfactionDegree(u,n,g);if(p>e&&(e=p),e===1)break}else if(!s(this,m)[0].isEmpty()&&s(this,m)[1].isEmpty()&&s(this,m)[2].isEmpty())for(const u of h)for(const g of c){const p=this.fuzzyRelation().satisfactionDegree(i,u,g);if(p>e&&(e=p),e===1)break}else for(const u of a)for(const g of h)for(const p of c){const w=this.fuzzyRelation().satisfactionDegree(u,g,p);if(w>e&&(e=w),e===1)break}return e}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==D.UNDEFINED)return t;let e=1;const i=s(this,m)[0].value(),n=s(this,m)[1].value(),o=s(this,m)[2].value(),a=s(this,m)[0].domain(),h=s(this,m)[1].domain(),c=s(this,m)[2].domain();if(s(this,m)[0].isEmpty()&&!s(this,m)[1].isEmpty()&&!s(this,m)[2].isEmpty())for(const u of a){const g=this.fuzzyRelation().satisfactionDegree(u,n,o);if(g<e&&(e=g),e===0)break}else if(!s(this,m)[0].isEmpty()&&s(this,m)[1].isEmpty()&&!s(this,m)[2].isEmpty())for(const u of h){const g=this.fuzzyRelation().satisfactionDegree(i,u,o);if(g<e&&(e=g),e===0)break}else if(!s(this,m)[0].isEmpty()&&!s(this,m)[1].isEmpty()&&s(this,m)[2].isEmpty())for(const u of c){const g=this.fuzzyRelation().satisfactionDegree(i,n,u);if(g<e&&(e=g),e===0)break}else if(s(this,m)[0].isEmpty()&&s(this,m)[1].isEmpty()&&!s(this,m)[2].isEmpty())for(const u of a)for(const g of h){const p=this.fuzzyRelation().satisfactionDegree(u,g,o);if(p<e&&(e=p),e===0)break}else if(s(this,m)[0].isEmpty()&&!s(this,m)[1].isEmpty()&&s(this,m)[2].isEmpty())for(const u of a)for(const g of c){const p=this.fuzzyRelation().satisfactionDegree(u,n,g);if(p<e&&(e=p),e===0)break}else if(!s(this,m)[0].isEmpty()&&s(this,m)[1].isEmpty()&&s(this,m)[2].isEmpty())for(const u of h)for(const g of c){const p=this.fuzzyRelation().satisfactionDegree(i,u,g);if(p<e&&(e=p),e===0)break}else for(const u of a)for(const g of h)for(const p of c){const w=this.fuzzyRelation().satisfactionDegree(u,g,p);if(w<e&&(e=w),e===0)break}return e}}m=new WeakMap;class $n extends D{constructor(t,...e){super(t);f(this,N);f(this,$);l(this,N,[...e]),l(this,$,new Array(s(this,N).length))}size(){return s(this,N).length}at(t){return s(this,N).at(t)}has(t){return s(this,N).includes(t)}indexOf(t){return s(this,N).indexOf(t)}neighbors(){const t=[];for(const e of s(this,N))for(const i of e)i!==this&&t.push(i);return t}[Symbol.iterator](){return s(this,N)[Symbol.iterator]()}emptyVariableSize(){let t=0;for(const e of s(this,N))e.isEmpty()&&++t;return t}isDefined(){for(const t of s(this,N))if(t.isEmpty())return!1;return!0}isSatisfied(){for(let t=0;t<s(this,N).length;++t){const e=s(this,N)[t];if(e.isEmpty())return-1;s(this,$)[t]=e.value()}return this.crispRelation().isSatisfied(...s(this,$))?1:0}satisfactionDegree(){for(let t=0;t<s(this,N).length;++t){const e=s(this,N)[t];if(e.isEmpty())return D.UNDEFINED;s(this,$)[t]=e.value()}return this.fuzzyRelation().satisfactionDegree(...s(this,$))}highestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==D.UNDEFINED)return t;const e=new Array(this.emptyVariableSize());let i=0;for(let n=0;n<s(this,N).length;++n){const o=s(this,N)[n];o.isEmpty()?e[i++]=n:s(this,$)[n]=o.value()}return this.checkHCD(e,0,0)}lowestConsistencyDegree(){const t=this.satisfactionDegree();if(t!==D.UNDEFINED)return t;const e=new Array(this.emptyVariableSize());let i=0;for(let n=0;n<s(this,N).length;++n){const o=s(this,N)[n];o.isEmpty()?e[i++]=n:s(this,$)[n]=o.value()}return this.checkLCD(e,0,1)}checkHCD(t,e,i){const n=t[e],o=s(this,N)[n].domain();if(e===t.length-1)for(const a of o){s(this,$)[n]=a;const h=this.fuzzyRelation().satisfactionDegree(...s(this,$));if(h>i&&(i=h),i===1)break}else for(const a of o)s(this,$)[n]=a,i=this.checkLCD(t,e+1,i);return i}checkLCD(t,e,i){const n=t[e],o=s(this,N)[n].domain();if(e===t.length-1)for(const a of o){s(this,$)[n]=a;const h=this.fuzzyRelation().satisfactionDegree(...s(this,$));if(h<i&&(i=h),i===0)break}else for(const a of o)s(this,$)[n]=a,i=this.checkLCD(t,e+1,i);return i}}N=new WeakMap,$=new WeakMap;class Hn{constructor(){f(this,we,(r,t)=>new z(r,t));f(this,Pe,(r,t)=>t.length===1?new Fn(r,t[0]):t.length===2?new _n(r,t[0],t[1]):t.length===3?new Un(r,t[0],t[1],t[2]):new $n(r,...t));f(this,_t,!1);f(this,R,[]);f(this,I,[])}setVariableFactory(r){l(this,we,r)}setConstraintFactory(r){l(this,Pe,r)}addVariable(r){r.setIndex(s(this,R).length),s(this,R).push(r)}createDomain(r){return"values"in r?new Ps(r.values):"min"in r&&"max"in r?new de(r.min,r.max):null}createVariable(r){if("variable"in r){const t=s(this,we).call(this,this,r.variable.domain());return this.addVariable(t),t.setName(t.name()),t.assign(t.value()),t}else{if(r.value!==void 0&&!r.domain.contains(r.value))throw new Error;const t=s(this,we).call(this,this,r.domain);return this.addVariable(t),r.name&&t.setName(r.name),r.value&&t.assign(r.value),t}}createConstraint(r){for(const e of r.variables)if(e.owner()!==this)return null;const t=s(this,Pe).call(this,r.relation,r.variables);t.setIndex(s(this,I).length),s(this,I).push(t);for(const e of r.variables)e.connect(t);return t.isFuzzy()&&l(this,_t,!0),"name"in r&&t.setName(r.name),t}removeConstraint(r){const t=s(this,I).indexOf(r);s(this,I).splice(t,1);for(let e=t;e<s(this,I).length;++e)s(this,I)[e].setIndex(e);for(const e of r)e.disconnect(r);l(this,_t,!1);for(const e of s(this,I))if(e.isFuzzy()){l(this,_t,!0);break}}clearAllVariables(){for(const r of s(this,R))r.clear()}reverseVariables(){s(this,R).reverse();for(let r=0;r<s(this,R).length;++r)s(this,R)[r].setIndex(r)}sortVariables(r){s(this,R).sort(r);for(let t=0;t<s(this,R).length;++t)s(this,R)[t].setIndex(t)}variableSize(){return s(this,R).length}variableAt(r){return s(this,R)[r]}variableOf(r){for(const t of s(this,R))if(t.name()===r)return t;return null}hasVariable(r){return s(this,R).includes(r)}variables(){return s(this,R)}constraintSize(){return s(this,I).length}constraintAt(r){return s(this,I)[r]}constraintOf(r){for(const t of s(this,I))if(t.name()===r)return t;return null}hasConstraint(r){return s(this,I).includes(r)}constraints(){return s(this,I)}constraintsBetween(r,t){const e=[];for(const i of r)i.has(t)&&e.push(i);return e}constraintsWithWorstSatisfactionDegree(){const r=[];let t=1;for(const e of s(this,I)){const i=e.satisfactionDegree();i<t?(t=i,r.length=0,r.push(e)):i-t<Number.MIN_VALUE*10&&r.push(e)}return[r,t]}worstSatisfactionDegree(){let r=1;for(const t of s(this,I)){const e=t.satisfactionDegree();if(e===D.UNDEFINED)return D.UNDEFINED;e<r&&(r=e)}return r}averageSatisfactionDegree(){let r=0;for(const t of s(this,I))r+=t.satisfactionDegree();return r=r/s(this,I).length,r}emptyVariableSize(){let r=0;for(const t of s(this,R))t.isEmpty()&&r++;return r}constraintDensity(){return this.constraintSize()/this.variableSize()}hasEmptyDomain(){for(const r of s(this,R))if(r.domain().size()===0)return!0;return!1}isFuzzy(){return s(this,_t)}}we=new WeakMap,Pe=new WeakMap,_t=new WeakMap,R=new WeakMap,I=new WeakMap;class W{constructor(r){O(this,"debug",!0);f(this,Be,r=>console.log(r));O(this,"pro");O(this,"iterLimit",null);O(this,"timeLimit",null);O(this,"targetDeg",.8);f(this,Ut,[]);this.pro=r}name(){return""}exec(){return!1}setIterationLimit(r=null){this.iterLimit=r}setTimeLimit(r=null){this.timeLimit=r}setTargetRate(r=null){this.targetDeg=r}solve(){return this.exec()}addListener(r){s(this,Ut).push(r)}removeListener(r){s(this,Ut).splice(s(this,Ut).indexOf(r),1)}foundSolution(r,t){let e=!1;for(const i of s(this,Ut))i(r,t)&&(e=!0);return e}setDebugMode(r){this.debug=r}setDebugOutput(r){l(this,Be,r)}debugOutput(r){this.debug&&s(this,Be).call(this,r)}}Be=new WeakMap,Ut=new WeakMap;class Ss{constructor(r){f(this,St);f(this,Ot);if("assignment"in r)l(this,St,r.assignment.variable()),l(this,Ot,r.assignment.value());else if("variable"in r)l(this,St,r.variable),l(this,Ot,r.value??r.variable.value());else throw new RangeError}apply(){s(this,St).assign(s(this,Ot))}toString(){return`v${s(this,St).index()} <- ${s(this,Ot)}`}value(){return s(this,Ot)}variable(){return s(this,St)}}St=new WeakMap,Ot=new WeakMap;const ii=class ii{constructor(){f(this,T,[])}static fromVariables(r){const t=new ii;return t.setVariables(r),t}setProblem(r){s(this,T).length=0;for(const t of r.variables())s(this,T).push(new Ss({variable:t,value:t.value()}))}setAssignmentList(r){s(this,T).length=0;for(const t of r)s(this,T).push(new Ss({variable:t.variable(),value:t.value()}))}setVariables(r){s(this,T).length=0;for(const t of r)s(this,T).push(new Ss({variable:t,value:t.value()}))}addVariable(r,t=null){s(this,T).push(new Ss({variable:r,value:t}))}apply(){for(const r of s(this,T))r.apply()}clear(){s(this,T).length=0}isEmpty(){return s(this,T).length===0}size(){return s(this,T).length}differenceSize(){let r=0;for(const t of s(this,T))t.variable().value()!==t.value()&&++r;return r}at(r){return s(this,T)[r]}[Symbol.iterator](){return s(this,T)[Symbol.iterator]()}random(){return s(this,T)[Math.floor(Math.random()*s(this,T).length)]}};T=new WeakMap;let S=ii;const kt=class kt{constructor(r){f(this,K);f(this,Vt,0);l(this,K,new Array(r)),s(this,K).fill(s(kt,Nt))}hiddenSize(){return s(this,Vt)}hide(r,t){s(this,K)[r]===s(kt,Nt)&&++H(this,Vt)._,s(this,K)[r]=t}isEmpty(){return s(this,K).length===s(this,Vt)}isValueHidden(r){return s(this,K)[r]!==s(kt,Nt)}reveal(r){for(let t=0;t<s(this,K).length;++t)s(this,K)[t]===r&&(s(this,K)[t]=s(kt,Nt),--H(this,Vt)._)}revealAll(){s(this,K).fill(s(kt,Nt)),l(this,Vt,0)}};Nt=new WeakMap,K=new WeakMap,Vt=new WeakMap,f(kt,Nt,-1);let ge=kt;class Pn extends W{constructor(t){super(t);f(this,Q);f(this,P);f(this,We,new S);f(this,Ct,[]);f(this,Ge,!1);f(this,De,0);f(this,ve,0);l(this,P,[...this.pro.variables()]);for(const e of s(this,P))e.solverObject=new ge(e.domain().size());d(this,Q,Ri).call(this)}name(){return"Forward Checking"}setTargetRate(){}setUsingMinimumRemainingValuesHeuristics(t){l(this,Ge,t)}exec(){l(this,ve,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),l(this,De,0),this.pro.clearAllVariables();const t=d(this,Q,ai).call(this,0);t||(this.iterLimit&&this.iterLimit<s(this,De)&&this.debugOutput("stop: number of iterations has reached the limit"),s(this,ve)<Date.now()&&this.debugOutput("stop: time limit has been reached"));for(const e of s(this,We))e.apply(),e.variable().solverObject.revealAll();return t}}P=new WeakMap,We=new WeakMap,Ct=new WeakMap,Ge=new WeakMap,De=new WeakMap,ve=new WeakMap,Q=new WeakSet,Ri=function(){l(this,Ct,[]);for(let t=0;t<s(this,P).length;++t){s(this,Ct).push(new Array(s(this,P).length));for(let e=0;e<s(this,P).length;++e)e<t&&(s(this,Ct)[t][e]=this.pro.constraintsBetween(s(this,P)[e],s(this,P)[t]))}},Ii=function(t,e){return t<e?s(this,Ct)[e][t]:s(this,Ct)[t][e]},Ti=function(t,e){for(const i of s(this,P)){if(!i.isEmpty())continue;const n=i.domain(),o=i.solverObject,a=d(this,Q,Ii).call(this,e,i.index());for(const h of a)if(h.emptyVariableSize()===1){for(let c=0,u=n.size();c<u;++c)o.isValueHidden(c)||(i.assign(n.at(c)),h.isSatisfied()===0&&o.hide(c,t));if(i.clear(),o.isEmpty())return!1}}return!0},ji=function(){let t=0,e=Number.MAX_VALUE;for(let i=0;i<s(this,P).length;++i){const n=s(this,P)[i];if(!n.isEmpty())continue;const a=n.domain().size()-n.solverObject.hiddenSize();a<e&&(e=a,t=i)}return t},ai=function(t){if(this.iterLimit&&this.iterLimit<H(this,De)._++||s(this,ve)<Date.now())return!1;if(t===this.pro.variableSize())return s(this,We).setProblem(this.pro),!0;const e=s(this,Ge)?d(this,Q,ji).call(this):t,i=s(this,P)[e],n=i.domain(),o=i.solverObject;for(let a=0,h=n.size();a<h;++a)if(!o.isValueHidden(a)){if(i.assign(n.at(a)),d(this,Q,Ti).call(this,t,e)&&d(this,Q,ai).call(this,t+1))return!0;for(const c of s(this,P))c.solverObject.reveal(t)}return i.clear(),!1};class Bn extends W{constructor(t){super(t);f(this,nt);f(this,it);f(this,qe,new S);f(this,bt);f(this,$t,0);f(this,ye,new Set);f(this,Ht,[]);f(this,Ee,0);f(this,ze,0);l(this,it,[...this.pro.variables()]);for(const e of s(this,it))e.solverObject=new ge(e.domain().size());l(this,bt,this.pro.constraintSize())}name(){return"Forward Checking for Max CSPs"}exec(){l(this,ze,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),l(this,Ee,0),this.pro.clearAllVariables();const t=d(this,nt,hi).call(this,0,0);t?this.debugOutput("stop: current degree is above the target"):(this.iterLimit&&this.iterLimit<s(this,Ee)&&this.debugOutput("stop: number of iterations has reached the limit"),s(this,ze)<Date.now()&&this.debugOutput("stop: time limit has been reached"));for(const e of s(this,qe))e.apply(),e.variable().solverObject.revealAll();return t}}it=new WeakMap,qe=new WeakMap,bt=new WeakMap,$t=new WeakMap,ye=new WeakMap,Ht=new WeakMap,Ee=new WeakMap,ze=new WeakMap,nt=new WeakSet,hi=function(t,e){if(this.iterLimit&&this.iterLimit<H(this,Ee)._++||s(this,ze)<Date.now())return!1;const i=this.pro;if(t===i.variableSize()){const h=i.violatingConstraintSize();return h<s(this,bt)&&(l(this,bt,h),s(this,qe).setProblem(this.pro),this.debugOutput(`   refreshed ${s(this,bt)}`),(this.targetDeg??1)<=i.satisfiedConstraintRate())}const n=s(this,it)[t],o=n.domain(),a=n.solverObject;for(let h=0,c=o.size();h<c;++h)if(!a.isValueHidden(h)&&(n.assign(o.at(h)),l(this,$t,e+d(this,nt,_i).call(this,t,n)),!(s(this,$t)>s(this,bt)))){if(d(this,nt,Fi).call(this,t)&&d(this,nt,hi).call(this,t+1,s(this,$t)))return!0;for(const u of s(this,it))u.solverObject.reveal(t)}return n.clear(),!1},Fi=function(t){const e=s(this,it)[t];for(let i=t+1;i<s(this,it).length;++i){const n=s(this,it)[i];l(this,Ht,this.pro.constraintsBetween(e,n));for(const o of s(this,Ht))if(o.emptyVariableSize()===1&&d(this,nt,Ui).call(this,n,o,t)&&n.solverObject.isEmpty())return!1}return!0},_i=function(t,e){let i=0;s(this,ye).clear();for(let n=0;n<t;++n){l(this,Ht,this.pro.constraintsBetween(e,s(this,it)[n]));for(const o of s(this,Ht))s(this,ye).has(o)||(o.isSatisfied()===0&&++i,s(this,ye).add(o))}return i},Ui=function(t,e,i){let n=!1;const o=t.domain(),a=t.solverObject;for(let h=0,c=o.size();h<c;++h)a.isValueHidden(h)||(t.assign(o.at(h)),e.isSatisfied()===0&&s(this,$t)+1>s(this,bt)&&(a.hide(h,i),n=!0));return n};const Pt=class Pt extends W{constructor(t,e=!1){super(t);f(this,U);f(this,Ye,0);f(this,Je,0);f(this,wt,!1);e&&this.pro.clearAllVariables()}name(){return"Local Changes"}exec(){l(this,Je,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),l(this,Ye,0),l(this,wt,!1),this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const t=new Set,e=new Set;for(const i of this.pro.variables())(i.isEmpty()?e:t).add(i);return d(this,U,Fs).call(this,new Set,t,e)}};Lt=new WeakSet,ci=function(t,e){return new Set(t).add(e)},ui=function(t,e){const i=new Set(t);return i.delete(e),i},Ye=new WeakMap,Je=new WeakMap,wt=new WeakMap,U=new WeakSet,$i=function(t,e,i){const n=new Set,o=new Set;for(const h of t){const c=this.pro.constraintsBetween(e,h);for(const u of c)o.add(u)}const a=e.value();e.assign(i);for(const h of o)if(h.isSatisfied()===0)for(const c of h)n.add(c);return e.assign(a),n.delete(e),n},js=function(t,e,i){const n=new Set;for(const a of t){const h=this.pro.constraintsBetween(e,a);for(const c of h)n.add(c)}const o=e.value();e.assign(i);for(const a of n)if(a.isSatisfied()===0)return e.assign(o),!1;return e.assign(o),!0},Hi=function(t,e,i,n){var c;if(!d(this,U,js).call(this,t,i,n))return!1;const o=t.union(e);if(d(this,U,js).call(this,o,i,n))return!0;const a=d(this,U,$i).call(this,o,i,n),h=o.difference(a);d(this,U,js).call(this,h,i,n)||this.debugOutput("bug");for(const u of a)u.clear();return t=d(c=Pt,Lt,ci).call(c,t,i),e=e.difference(a),d(this,U,Fs).call(this,t,e,a)},fi=function(t,e,i,n){var c;if(n.size===0)return!1;const o=n.values().next().value,a=S.fromVariables(e);i.assign(o);const h=d(this,U,Hi).call(this,t,e,i,o);return h||s(this,wt)?h:(i.clear(),a.apply(),d(this,U,fi).call(this,t,e,i,d(c=Pt,Lt,ui).call(c,n,o)))},Fs=function(t,e,i){var h,c;if(this.debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${i.size}`),(this.targetDeg??1)<=this.pro.satisfiedConstraintRate())return this.debugOutput("stop: current degree is above the target"),l(this,wt,!0),!0;if(this.iterLimit&&this.iterLimit<H(this,Ye)._++)return this.debugOutput("stop: number of iterations has reached the limit"),l(this,wt,!0),!1;if(s(this,Je)<Date.now())return this.debugOutput("stop: time limit has been reached"),l(this,wt,!0),!1;if(i.size===0)return!0;const n=i.values().next().value,o=new Set;for(const u of n.domain())o.add(u);const a=d(this,U,fi).call(this,t,e,n,o);return!a||s(this,wt)?a:(e=d(h=Pt,Lt,ci).call(h,e,n),i=d(c=Pt,Lt,ui).call(c,i,n),d(this,U,Fs).call(this,t,e,i))},f(Pt,Lt);let Bs=Pt;const ks=class ks extends W{constructor(t,e=!1){super(t);f(this,q);f(this,Ke,0);f(this,Qe,0);f(this,Dt,!1);e&&this.pro.clearAllVariables()}name(){return"Local Changes Ex"}exec(){l(this,Qe,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),l(this,Ke,0),l(this,Dt,!1),this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const t=new Set,e=new Set;for(const i of this.pro.variables())(i.isEmpty()?e:t).add(i);return d(this,q,di).call(this,new Set,t,e)}};Vs=new WeakSet,Pi=function(t,e){return new Set(t).add(e)},Ke=new WeakMap,Qe=new WeakMap,Dt=new WeakMap,q=new WeakSet,Bi=function(t,e,i){const n=new Set,o=new Set;for(const h of t){const c=this.pro.constraintsBetween(e,h);for(const u of c)o.add(u)}const a=e.value();e.assign(i);for(const h of o)if(h.isSatisfied()===0)for(const c of h)n.add(c);return e.assign(a),n.delete(e),n},li=function(t,e,i){const n=new Set;for(const a of t){const h=this.pro.constraintsBetween(e,a);for(const c of h)n.add(c)}const o=e.value();e.assign(i);for(const a of n)if(a.isSatisfied()===0)return e.assign(o),!1;return e.assign(o),!0},Wi=function(t,e,i){var a;if(!d(this,q,li).call(this,t,i,i.value()))return!1;const n=t.union(e);if(d(this,q,li).call(this,n,i,i.value()))return!0;const o=d(this,q,Bi).call(this,n,i,i.value());return t=d(a=ks,Vs,Pi).call(a,t,i),e=e.difference(o),d(this,q,di).call(this,t,e,o)},Gi=function(t,e,i){for(const n of i.domain()){const o=S.fromVariables(e);i.assign(n);const a=d(this,q,Wi).call(this,t,e,i);if(a||s(this,Dt))return a;i.clear(),o.apply()}return!1},di=function(t,e,i){for(e=new Set(e),i=new Set(i);;){if(this.debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${i.size}`),(this.targetDeg??1)<=this.pro.satisfiedConstraintRate())return this.debugOutput("stop: current degree is above the target"),l(this,Dt,!0),!0;if(this.iterLimit&&this.iterLimit<H(this,Ke)._++)return this.debugOutput("stop: number of iterations has reached the limit"),l(this,Dt,!0),!1;if(s(this,Qe)<Date.now())return this.debugOutput("stop: time limit has been reached"),l(this,Dt,!0),!1;if(i.size===0)return!0;const n=i.values().next().value,o=d(this,q,Gi).call(this,t,e,n);if(!o||s(this,Dt))return o;e.add(n),i.delete(n)}},f(ks,Vs);let Ws=ks;class Wn extends W{constructor(t){super(t);f(this,xe);f(this,Ze,!0);f(this,At);l(this,At,new Array(this.pro.constraintSize())),s(this,At).fill(1)}name(){return"Breakout"}setRandomness(t){l(this,Ze,t)}exec(){const t=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let e=0;for(const o of this.pro.variables())o.isEmpty()&&o.assign(o.domain().at(0));const i=new S,n=this.pro;for(;;){const o=n.violatingConstraints();if((this.targetDeg??1)<=n.satisfiedConstraintRate())return this.debugOutput("stop: current degree is above the target"),!0;if(this.iterLimit&&this.iterLimit<e++)return this.debugOutput("stop: number of iterations has reached the limit"),!1;if(t<Date.now())return this.debugOutput("stop: time limit has been reached"),!1;if(this.debugOutput(o.length+" violations"),d(this,xe,qi).call(this,d(this,xe,Yi).call(this,o),i),0<i.size()){const a=s(this,Ze)?i.random():i.at(0);a.apply(),i.clear(),this.debugOutput("	"+a)}else{for(const a of o)s(this,At)[a.index()]+=1;this.debugOutput("breakout")}}}}Ze=new WeakMap,At=new WeakMap,xe=new WeakSet,qi=function(t,e){let i=0;for(const n of t){const o=n.value();let a=0;for(const h of n)a+=(1-h.isSatisfied())*s(this,At)[h.index()];t:for(const h of n.domain()){if(o===h)continue;n.assign(h);let c=a;for(const u of n)if(c-=(1-u.isSatisfied())*s(this,At)[u.index()],c<i)continue t;c>i?(i=c,e.clear(),e.addVariable(n,h)):i!==0&&e.addVariable(n,h)}n.assign(o)}},Yi=function(t){const e=new Set;for(const i of t)for(const n of i)e.add(n);return Array.from(e)};const ni=class ni extends W{constructor(t){super(t);f(this,Se);f(this,rt,[]);f(this,Xe,[])}static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}name(){return"GENET"}exec(){if(!d(this,Se,Ji).call(this))throw new Error;const t=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let e=0;const i=new S,n=[];for(let c=0;c<s(this,rt).length;++c)n.push(c);const o=this.pro;let a=o.satisfiedConstraintRate(),h=!1;for(;;){if(this.iterLimit&&this.iterLimit<e++){this.debugOutput("stop: number of iterations has reached the limit");break}if(t<Date.now()){this.debugOutput("stop: time limit has been reached");break}let c=!1;for(const u of d(this,Se,Ki).call(this,n))s(this,rt)[u].setActivityMaximumInput()&&(c=!0);if(c){for(const g of s(this,rt))g.applyToVariable();const u=o.satisfiedConstraintRate();if(a<u){if(a=u,this.debugOutput(`satisfied constraint rate: ${u}`),i.setProblem(this.pro),this.foundSolution(i,u)){h=!0;break}if(this.targetDeg??1<=a){this.debugOutput("stop: current degree is above the target"),h=!0;break}}}else for(const u of s(this,Xe))u.refreshWeight()}return i.apply(),h}};rt=new WeakMap,Xe=new WeakMap,Se=new WeakSet,Ji=function(){this.debugOutput("network creation start");const t=[];for(const e of this.pro.variables()){if(e.domain().size()===0)return!1;s(this,rt).push(new Gn(e))}for(const e of this.pro.constraints())if(e.size()===1){const i=e.at(0),n=s(this,rt)[i.index()];for(let o=0;o<n.size();++o){const a=i.value();i.assign(n.get(o)._value),e.isSatisfied()===0&&t.push(new Ni(n.get(o))),i.assign(a)}}else{const i=e.at(0),n=e.at(1),o=s(this,rt)[i.index()],a=s(this,rt)[n.index()];for(let h=0;h<o.size();++h){const c=i.value();i.assign(o.get(h)._value);for(let u=0;u<a.size();++u){const g=n.value();n.assign(a.get(u)._value),e.isSatisfied()===0&&t.push(new Ni(o.get(h),a.get(u))),n.assign(g)}i.assign(c)}}for(const e of s(this,rt))for(const i of e._neurons)i.lockConnections();return l(this,Xe,t),this.debugOutput("network creation complete"),!0},Ki=function(t){for(let e=t.length;e>1;--e){const i=ni.nextInt(e),n=t[e-1];t[e-1]=t[i],t[i]=n}return t};let Gs=ni,Gn=(Bt=class{constructor(r){f(this,es);f(this,ts);f(this,Oe,0);f(this,vt,[]);O(this,"_neurons",[]);l(this,ts,r);for(const t of r.domain())this._neurons.push(new qn(t));d(this,es,gi).call(this,Bt.nextInt(this._neurons.length))}static nextInt(r){return Math.floor(Math.random()*Math.floor(r))}applyToVariable(){s(this,ts).assign(this._neurons[s(this,Oe)]._value)}get(r){return this._neurons[r]}neurons(){return this._neurons}setActivityMaximumInput(){s(this,vt).length=0;let r=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const i=this._neurons[e].getInput();r<=i&&(r<i&&(r=i,s(this,vt).length=0,t=!1),s(this,vt).push(e),s(this,Oe)===e&&(t=!0))}return t||s(this,vt).length===0?!1:(d(this,es,gi).call(this,s(this,vt)[Bt.nextInt(s(this,vt).length)]),!0)}size(){return this._neurons.length}},ts=new WeakMap,Oe=new WeakMap,vt=new WeakMap,es=new WeakSet,gi=function(r){for(const t of this._neurons)t._isActive=!1;this._neurons[r]._isActive=!0,l(this,Oe,r)},Bt),Ni=(Ci=class{constructor(r,t=null){f(this,Mt);f(this,ut);O(this,"_weight");this._weight=-1,l(this,Mt,r),s(this,Mt).addConnection(this),l(this,ut,t),s(this,ut)&&s(this,ut).addConnection(this)}getNeuron(r){return r===s(this,Mt)?s(this,ut):r===s(this,ut)?s(this,Mt):null}refreshWeight(){!s(this,Mt)._isActive||s(this,ut)!==null&&!s(this,ut)._isActive||(this._weight+=-1)}},Mt=new WeakMap,ut=new WeakMap,Ci),qn=(Li=class{constructor(r){f(this,Ne,[]);f(this,ss,[]);O(this,"_value");O(this,"_isActive",!1);this._value=r}addConnection(r){s(this,Ne).push(r)}lockConnections(){l(this,ss,[...s(this,Ne)]),l(this,Ne,null)}getInput(){let r=0;for(const t of s(this,ss)){const e=t.getNeuron(this);r+=t._weight*(e===null||e._isActive?1:0)}return r}},Ne=new WeakMap,ss=new WeakMap,Li);class Yn extends W{constructor(t){super(t);f(this,B);f(this,is,!0);f(this,Wt,new Set);f(this,Z,new Set);f(this,Ve,[]);f(this,Gt,[]);for(const e of this.pro.constraints())s(this,Ve).push(new Jn(e)),s(this,Gt).push(null)}name(){return"SRS 3 for Crisp CSPs"}setRandomness(t){l(this,is,t)}exec(){const t=this.pro.violatingConstraints(),e=new Set;for(const i of t){const n=s(this,Ve)[i.index()];e.add(n)}return d(this,B,Xi).call(this,e)?!0:e.size===0}}is=new WeakMap,Wt=new WeakMap,Z=new WeakMap,Ve=new WeakMap,Gt=new WeakMap,B=new WeakSet,Qi=function(t){const e=t.index();return s(this,Gt)[e]===null&&(s(this,Gt)[e]=t.neighbors()),s(this,Gt)[e]},_s=function(t){this.debugOutput("repair");const e=new S;let i=0;for(const n of t){const o=n.value();let a=0;for(const h of n)a+=1-h.isSatisfied();t:for(const h of n.domain()){if(o===h||(n.assign(h),t.isSatisfied()!==1))continue;let c=a;for(const u of n)if(c-=1-u.isSatisfied(),c<i)continue t;c>i?(i=c,e.clear(),e.addVariable(n,h)):i!==0&&e.addVariable(n,h)}n.assign(o)}if(e.size()>0){const n=s(this,is)?e.random():e.at(0);return n.apply(),this.debugOutput("	"+n),!0}return!1},Zi=function(t,e){const i=[];let n=t;for(;;){n=n.parent(),i.length=0,n.getDescendants(i),n.clear();for(const o of e)s(this,Z).delete(o),s(this,Wt).delete(o);if(e.delete(n)||(s(this,Z).add(n),n.parent()!==null&&!d(this,B,_s).call(this,n.parent().getObject())))break}},mi=function(t){this.debugOutput("spread"),s(this,Wt).add(t);for(const e of d(this,B,Qi).call(this,t.getObject())){const i=s(this,Ve)[e.index()];!s(this,Wt).has(i)&&!s(this,Z).has(i)&&(i.clear(),t.add(i),s(this,Z).add(i))}},Xi=function(t){this.debugOutput("srs");const e=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let i=0;s(this,Wt).clear(),s(this,Z).clear();for(const o of t)s(this,Z).add(o);const n=this.pro;for(;t.size&&s(this,Z).size;){if((this.targetDeg??1)<=n.satisfiedConstraintRate())return this.debugOutput("stop: current degree is above the target"),!0;if(this.iterLimit&&this.iterLimit<i++)return this.debugOutput("stop: number of iterations has reached the limit"),!1;if(e<Date.now())return this.debugOutput("stop: time limit has been reached"),!1;const o=s(this,Z).values().next().value;s(this,Z).delete(o),d(this,B,_s).call(this,o.getObject())?t.delete(o)||(o.parent()!==null&&d(this,B,_s).call(this,o.parent().getObject())?d(this,B,Zi).call(this,o,t):d(this,B,mi).call(this,o)):d(this,B,mi).call(this,o)}return!1};let Jn=(Ai=class{constructor(r){f(this,qt,[]);f(this,Yt);f(this,ns);l(this,Yt,null),l(this,ns,r)}add(r){l(r,Yt,this),s(this,qt).push(r)}clear(){for(const r of s(this,qt))l(r,Yt,null);s(this,qt).length=0}getDescendants(r){r.push(this);for(const t of s(this,qt))t.getDescendants(r)}getObject(){return s(this,ns)}parent(){return s(this,Yt)}},qt=new WeakMap,Yt=new WeakMap,ns=new WeakMap,Ai);const X=class X extends W{constructor(t,e=null){super(t);f(this,v);f(this,k);f(this,Jt,new S);f(this,Rt,[]);f(this,C,0);f(this,Kt,0);f(this,Qt,0);f(this,ke,!1);f(this,rs,0);f(this,ft);f(this,os);f(this,Zt);f(this,as,!1);l(this,k,[...this.pro.variables()]),l(this,ft,new Array(this.pro.variableSize())),d(this,v,tn).call(this),l(this,Zt,new Array(this.pro.constraintSize()));const i=[];for(const n of this.pro.constraints())n.size()===1&&i.push(n);l(this,os,[...i]),e&&l(this,C,e)}name(){return"Forward Checking for Fuzzy CSPs"}setUsingMinimumRemainingValuesHeuristics(t){l(this,ke,t)}setIncrementStepOfWorstSatisfactionDegree(t){l(this,rs,t)}setIntensivePruning(t){l(this,as,t)}setTargetRate(t=null){if(this.targetDeg=t,this.targetDeg===null)l(this,C,0);else{let e=Number.MIN_VALUE;for(l(this,C,this.targetDeg-e);s(this,C)>=this.targetDeg;)e*=10,l(this,C,this.targetDeg-e)}}exec(){l(this,Qt,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),l(this,Kt,0);for(const e of s(this,k))e.solverObject=new ge(e.domain().size());if(this.pro.clearAllVariables(),!d(this,v,pi).call(this))return!1;let t=!1;for(;;){if(d(this,v,wi).call(this,0)===X.TERMINATE){if(this.iterLimit&&this.iterLimit<H(this,Kt)._++){this.debugOutput("stop: number of iterations has reached the limit");break}if(s(this,Qt)<Date.now()){this.debugOutput("stop: time limit has been reached");break}}if(s(this,Jt).isEmpty())break;if(this.debugOutput(`	found a solution: ${s(this,C)}`),this.foundSolution(s(this,Jt),s(this,C))){t=!0;break}if(this.targetDeg===null)t=!0,l(this,C,s(this,C)+s(this,rs));else if(this.targetDeg<=s(this,C)){this.debugOutput("stop: current degree is above the target"),t=!0;break}for(const i of s(this,k))i.solverObject.revealAll()}s(this,Jt).apply();for(const e of s(this,k))e.solverObject=null;return t}};k=new WeakMap,Jt=new WeakMap,Rt=new WeakMap,C=new WeakMap,Kt=new WeakMap,Qt=new WeakMap,ke=new WeakMap,rs=new WeakMap,ft=new WeakMap,os=new WeakMap,Zt=new WeakMap,as=new WeakMap,v=new WeakSet,tn=function(){l(this,Rt,[]);for(let t=0;t<s(this,k).length;++t){s(this,Rt).push(new Array(s(this,k).length));for(let e=0;e<s(this,k).length;++e)e<t&&(s(this,Rt)[t][e]=this.pro.constraintsBetween(s(this,k)[e],s(this,k)[t]))}},Us=function(t,e){return t<e?s(this,Rt)[e][t]:s(this,Rt)[t][e]},pi=function(){for(const t of s(this,os)){const e=t.at(0),i=e.value(),n=e.domain(),o=e.solverObject;for(let a=0,h=n.size();a<h;++a)e.assign(n.at(a)),t.satisfactionDegree()<=s(this,C)&&o.hide(a,-1);if(e.assign(i),o.isEmpty())return!1}return!0},en=function(t,e,i){const n=e.domain(),o=e.solverObject;for(let a=0,h=n.size();a<h;++a)o.isValueHidden(a)||(e.assign(n.at(a)),i.satisfactionDegree()<=s(this,C)&&o.hide(a,t));return e.clear(),!o.isEmpty()},sn=function(t,e,i){const n=e.domain(),o=e.solverObject;let a=null;for(const u of i)if(u.isEmpty()&&u!==e){a=u;break}const h=a.domain(),c=a.solverObject;t:for(let u=0,g=n.size();u<g;++u)if(!o.isValueHidden(u)){e.assign(n.at(u));for(let p=0,w=h.size();p<w;++p){if(c.isValueHidden(p))continue;if(a.assign(h.at(p)),i.satisfactionDegree()>s(this,C))continue t}o.hide(u,t)}return a.clear(),e.clear(),!o.isEmpty()},nn=function(t,e,i){const n=e.domain(),o=e.solverObject;let a=null,h=null;for(const w of i)if(w.isEmpty()&&w!==e)if(a===null)a=w;else{h=w;break}const c=a.domain(),u=h.domain(),g=a.solverObject,p=h.solverObject;t:for(let w=0,x=n.size();w<x;++w)if(!o.isValueHidden(w)){e.assign(n.at(w));for(let J=0,Ft=c.size();J<Ft;++J)if(!g.isValueHidden(J)){a.assign(c.at(J));for(let mt=0,rr=u.size();mt<rr;++mt){if(p.isValueHidden(mt))continue;if(h.assign(u.at(mt)),i.satisfactionDegree()>s(this,C))continue t}}o.hide(w,t)}return h.clear(),a.clear(),e.clear(),!o.isEmpty()},rn=function(t,e,i,n){const o=e.domain(),a=e.solverObject,h=new Array(n-1);let c=0;for(const g of i)g.isEmpty()&&g!==e&&(h[c++]=g);const u=new Array(h.length);t:for(let g=0,p=o.size();g<p;++g)if(!a.isValueHidden(g)){e.assign(o.at(g)),u.fill(0);e:for(;;){let w=!1;for(let x=0;x<h.length;++x){const J=h[x].domain();if(h[x].solverObject.isValueHidden(u[x])){w=!0;break}h[x].assign(J.at(u[x]))}if(!w&&i.satisfactionDegree()>s(this,C))continue t;for(let x=0;x<h.length&&(u[x]+=1,!(u[x]<h[x].domain().size()));++x)if(u[x]=0,x===h.length-1)break e}a.hide(g,t)}for(const g of h)g.clear();return e.clear(),!a.isEmpty()},on=function(t,e){for(const i of s(this,k)){if(!i.isEmpty())continue;const n=d(this,v,Us).call(this,e,i.index());for(const o of n){const a=o.emptyVariableSize();if(a===1){if(!d(this,v,en).call(this,t,i,o))return!1}else if(s(this,as)){if(a===2){if(!d(this,v,sn).call(this,t,i,o))return!1}else if(a===3){if(!d(this,v,nn).call(this,t,i,o))return!1}else if(a>3&&!d(this,v,rn).call(this,t,i,o,a))return!1}}}return!0},an=function(t){s(this,Zt).fill(!1);for(let e=0;e<s(this,k).length;++e){const i=s(this,k)[e];if(i===t||i.isEmpty())continue;const n=d(this,v,Us).call(this,t.index(),e);for(const o of n){if(s(this,Zt)[o.index()])continue;const a=o.satisfactionDegree();if(a!==D.UNDEFINED&&a<=s(this,C))return!1;s(this,Zt)[o.index()]=!0}}return!0},hn=function(){for(let t=0;t<s(this,ft).length;++t){const e=s(this,ft)[t].index();for(let i=t+1;i<s(this,ft).length;++i){const n=s(this,ft)[i],o=d(this,v,Us).call(this,e,n.index());for(const a of o){const h=n.value(),c=n.domain(),u=n.solverObject;for(let g=0,p=c.size();g<p;++g)u.isValueHidden(g)||(n.assign(c.at(g)),a.satisfactionDegree()<=s(this,C)&&u.hide(g,t));n.assign(h)}}}},bi=function(){let t=0,e=Number.MAX_VALUE;for(let i=0;i<s(this,k).length;++i){const n=s(this,k)[i];if(!n.isEmpty())continue;const a=n.domain().size()-n.solverObject.hiddenSize();a<e&&(e=a,t=i)}return t},wi=function(t){let e=X.CONTINUE;const i=s(this,ke)?d(this,v,bi).call(this):t,n=s(this,k)[i],o=n.domain(),a=n.solverObject;s(this,ft)[t]=n;for(let h=0,c=o.size();h<c;++h){if(a.isValueHidden(h))continue;if(this.iterLimit&&this.iterLimit<H(this,Kt)._++||s(this,Qt)<Date.now()){e=X.TERMINATE;break}n.assign(o.at(h));for(const g of s(this,k))g.solverObject.reveal(t);if(!d(this,v,an).call(this,n)||!d(this,v,on).call(this,t,i))continue;const u=t+1;if(e=u===s(this,k).length-1?d(this,v,cn).call(this,u):d(this,v,wi).call(this,u),e===X.TERMINATE)break}if(e===X.CONTINUE)for(const h of s(this,k))h.solverObject.reveal(t);return n.clear(),e},cn=function(t){let e=X.CONTINUE;const i=s(this,k)[s(this,ke)?d(this,v,bi).call(this):t],n=i.domain(),o=i.solverObject;s(this,ft)[t]=i;for(let a=0,h=n.size();a<h;++a){if(o.isValueHidden(a))continue;if(this.iterLimit&&this.iterLimit<H(this,Kt)._++||s(this,Qt)<Date.now()){e=X.TERMINATE;break}i.assign(n.at(a));const c=this.pro.worstSatisfactionDegree();if(c>s(this,C)){if(l(this,C,c),s(this,Jt).setProblem(this.pro),e=X.TERMINATE,this.targetDeg!==null&&this.targetDeg<=s(this,C))break;d(this,v,pi).call(this),d(this,v,hn).call(this)}}return i.clear(),e},O(X,"CONTINUE",0),O(X,"TERMINATE",1);let qs=X;const tt=class tt extends W{constructor(t,e=null){super(t);f(this,F);f(this,A);f(this,Xt,new S);f(this,It,[]);f(this,j,0);f(this,te,0);f(this,ee,0);f(this,Ce,!1);f(this,se,0);l(this,A,[...this.pro.variables()]),d(this,F,un).call(this),l(this,j,Math.max(0,t.worstSatisfactionDegree())),e&&l(this,j,e)}name(){return"Forward Checking for Fuzzy CSPs of Binary Constraints"}setUsingMinimumRemainingValuesHeuristics(t){l(this,Ce,t)}setIncrementStepOfWorstSatisfactionDegree(t){l(this,se,t)}setTargetRate(t=null){if(this.targetDeg=t,this.targetDeg===null)l(this,j,0);else{let e=Number.MIN_VALUE;for(l(this,j,this.targetDeg-e);s(this,j)>=this.targetDeg;)e*=10,l(this,j,this.targetDeg-e)}}exec(){l(this,ee,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),l(this,te,0);for(const i of s(this,A))i.solverObject=new ge(i.domain().size());this.pro.clearAllVariables();const t=new S;let e=!1;for(;;){if(d(this,F,vi).call(this,0)===tt.TERMINATE){if(this.iterLimit&&this.iterLimit<H(this,te)._++){this.debugOutput("stop: number of iterations has reached the limit");break}if(s(this,ee)<Date.now()){this.debugOutput("stop: time limit has been reached");break}}if(s(this,Xt).isEmpty())break;if(t.setAssignmentList(s(this,Xt)),s(this,Xt).clear(),this.debugOutput(`	found a solution: ${s(this,j)}`),this.foundSolution(t,s(this,j))){e=!0;break}if(this.targetDeg===null){if(e=!0,s(this,j)+s(this,se)>1)break;l(this,j,s(this,j)+(s(this,j)+s(this,se)>1?0:s(this,se)))}else if(this.targetDeg<=s(this,j)){this.debugOutput("stop: current degree is above the target"),e=!0;break}for(const n of s(this,A))n.solverObject.revealAll()}t.apply();for(const i of s(this,A))i.solverObject=null;return e}};A=new WeakMap,Xt=new WeakMap,It=new WeakMap,j=new WeakMap,te=new WeakMap,ee=new WeakMap,Ce=new WeakMap,se=new WeakMap,F=new WeakSet,un=function(){l(this,It,[]);for(let t=0;t<s(this,A).length;++t){s(this,It).push(new Array(s(this,A).length));for(let e=0;e<s(this,A).length;++e)e<t&&(s(this,It)[t][e]=this.pro.constraintsBetween(s(this,A)[e],s(this,A)[t]))}},fn=function(t,e){return t<e?s(this,It)[e][t]:s(this,It)[t][e]},ln=function(t,e,i){const n=e.domain(),o=e.solverObject;for(let a=0,h=n.size();a<h;++a)o.isValueHidden(a)||(e.assign(n.at(a)),i.satisfactionDegree()<=s(this,j)&&o.hide(a,t));return e.clear(),!o.isEmpty()},dn=function(t,e){for(const i of s(this,A)){if(!i.isEmpty())continue;const n=d(this,F,fn).call(this,e,i.index());for(const o of n)if(o.size()===2&&!d(this,F,ln).call(this,t,i,o))return!1}return!0},Di=function(){let t=0,e=Number.MAX_VALUE;for(let i=0;i<s(this,A).length;++i){const n=s(this,A)[i];if(!n.isEmpty())continue;const a=n.domain().size()-n.solverObject.hiddenSize();a<e&&(e=a,t=i)}return t},vi=function(t){let e=tt.CONTINUE;const i=s(this,Ce)?d(this,F,Di).call(this):t,n=s(this,A)[i],o=n.domain(),a=n.solverObject;for(let h=0,c=o.size();h<c;++h){if(a.isValueHidden(h))continue;if(this.iterLimit&&this.iterLimit<H(this,te)._++||s(this,ee)<Date.now()){e=tt.TERMINATE;break}n.assign(o.at(h));for(const g of s(this,A))g.solverObject.reveal(t);if(!d(this,F,dn).call(this,t,i))continue;const u=t+1;if(e=u===s(this,A).length-1?d(this,F,gn).call(this,u):d(this,F,vi).call(this,u),e===tt.TERMINATE)break}if(e===tt.CONTINUE)for(const h of s(this,A))h.solverObject.reveal(t);return n.clear(),e},gn=function(t){let e=tt.CONTINUE;const i=s(this,A)[s(this,Ce)?d(this,F,Di).call(this):t],n=i.domain(),o=i.solverObject;for(let a=0,h=n.size();a<h;++a){if(o.isValueHidden(a))continue;if(this.iterLimit&&this.iterLimit<H(this,te)._++||s(this,ee)<Date.now()){e=tt.TERMINATE;break}i.assign(n.at(a));const c=this.pro.worstSatisfactionDegree();if(c>s(this,j)&&(l(this,j,c),s(this,Xt).setProblem(this.pro),e=tt.TERMINATE,this.targetDeg!==null&&this.targetDeg<=s(this,j)))break}return i.clear(),e},O(tt,"CONTINUE",0),O(tt,"TERMINATE",1);let Ys=tt;const Le=class Le extends W{constructor(t){super(t);f(this,L);f(this,ne,0);f(this,re,0);f(this,hs,0);f(this,cs,0);f(this,lt,0);d(this,L,pn).call(this)}name(){return"Flexible Local Changes"}exec(){l(this,cs,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),l(this,hs,0),l(this,lt,-1);const t=this.pro.worstSatisfactionDegree();this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const e=new Set,i=new Set,n=new Set;for(const w of this.pro.variables())(w.isEmpty()?n:i).add(w);const o=new Set,a=d(this,L,Dn).call(this,i,o);let h,c=null;n.size===0?(h=a,c=S.fromVariables(i)):h=s(this,re);const u=d(this,L,Ei).call(this,i,o).union(n),g=i.difference(u);let p=d(this,L,$s).call(this,e,g,u,s(this,ne),s(this,ne),h);return p<h&&c!==null&&c.apply(),p=this.pro.worstSatisfactionDegree(),p>t&&p>0&&(s(this,lt)!==0||this.targetDeg===null)}};ie=new WeakSet,yi=function(t,e){const i=new Set(t);return i.add(e),i},mn=function(t,e){const i=new Set(t);return i.delete(e),i},ne=new WeakMap,re=new WeakMap,hs=new WeakMap,cs=new WeakMap,lt=new WeakMap,L=new WeakSet,Ei=function(t,e){const i=new Map;for(const a of e)if(a.isDefined())for(const h of a)i.has(h)?i.set(h,(i.get(h)??0)+1):i.set(h,1);const n=[...t];n.sort((a,h)=>{let c=0,u=0;return i.has(a)&&(c=i.get(a)??0),i.has(h)&&(u=i.get(h)??0),c<u?1:c>u?-1:0});const o=new Set;for(const a of n){let h=!1;for(const c of e)if(c.isDefined()){h=!0;break}if(!h)break;a.clear(),o.add(a)}return o},pn=function(){let t=1,e=0;for(const i of this.pro.variables())for(const n of i){const o=n.lowestConsistencyDegree(),a=n.highestConsistencyDegree();o<t&&(t=o),a>e&&(e=a)}l(this,re,t),l(this,ne,e)},bn=function(t,e,i,n,o,a,h){var p;const c=d(this,L,Ei).call(this,e,a),u=d(p=Le,ie,yi).call(p,t,i),g=e.difference(c);return d(this,L,$s).call(this,u,g,c,n,Math.min(o,n),h)},wn=function(t,e,i,n,o,a){let h=s(this,re);if(i.domain().size()===0)return h;let c=S.fromVariables(e),u=i.domain().at(0);const g=S.fromVariables(e);for(let p=0;p<i.domain().size()&&h<o;++p){const w=i.domain().at(p);i.assign(w);const x=Math.min(n,d(this,L,vn).call(this,t,i,h,a));if(x>Math.max(h,a)){const J=new Set,Ft=Math.min(Math.min(x,o),d(this,L,yn).call(this,t,e,i,x,o,J));if(Ft>h&&(h=Ft,u=w,c=S.fromVariables(e)),J.size){const mt=d(this,L,bn).call(this,t,e,i,x,o,J,Math.max(a,h));if(s(this,lt)!==-1)return h;mt>h&&(h=mt,u=w,c=S.fromVariables(e)),g.apply()}}}return c.apply(),i.assign(u),h},$s=function(t,e,i,n,o,a){var u,g;if(this.debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${i.size}`),this.targetDeg!==null&&this.targetDeg<=this.pro.worstSatisfactionDegree())return this.debugOutput("stop: current degree is above the target"),l(this,lt,1),o;if(this.iterLimit&&this.iterLimit<H(this,hs)._++)return this.debugOutput("stop: number of iterations has reached the limit"),l(this,lt,0),o;if(s(this,cs)<Date.now())return this.debugOutput("stop: time limit has been reached"),l(this,lt,0),o;if(i.size===0)return o;const h=i.values().next().value,c=d(this,L,wn).call(this,t,e,h,n,o,a);return s(this,lt)!==-1?o:c<a?s(this,re):(e=d(u=Le,ie,yi).call(u,e,h),i=d(g=Le,ie,mn).call(g,i,h),d(this,L,$s).call(this,t,e,i,n,c,a))},Dn=function(t,e){const i=new Set;for(const o of t)for(const a of o)i.add(a);let n=1;for(const o of i){const a=o.satisfactionDegree();a!==D.UNDEFINED&&a<n&&(n=a)}for(const o of this.pro.constraints())o.lowestConsistencyDegree()<s(this,ne)&&e.add(o);return n},vn=function(t,e,i,n){let o=1;const a=new Set;for(const h of t){const c=this.pro.constraintsBetween(h,e);for(const u of c)a.add(u)}for(const h of a){const c=h.satisfactionDegree();if(c!==D.UNDEFINED&&(c<o&&(o=c),o<=i||o<=n))return o}return o},yn=function(t,e,i,n,o,a){let h=1;const c=new Set;for(const u of t){const g=this.pro.constraintsBetween(u,i);for(const p of g)c.add(p)}for(const u of e){const g=this.pro.constraintsBetween(u,i);for(const p of g)c.add(p)}for(const u of c){const g=u.satisfactionDegree();g!==D.UNDEFINED&&g<h&&(h=g)}for(const u of c){const g=u.satisfactionDegree();g!==D.UNDEFINED&&(g<n||g<o)&&a.add(u)}return h},f(Le,ie);let Js=Le;const Ls=class Ls extends W{constructor(t){super(t);f(this,M);f(this,oe,0);f(this,ae,0);f(this,us,0);f(this,fs,0);f(this,dt,0);d(this,M,zn).call(this)}name(){return"Flexible Local Changes Ex"}exec(){l(this,fs,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),l(this,us,0),l(this,dt,-1);const t=this.pro.worstSatisfactionDegree();this.pro.emptyVariableSize()===0&&this.pro.clearAllVariables();const e=new Set,i=new Set,n=new Set;for(const w of this.pro.variables())(w.isEmpty()?n:i).add(w);const o=new Set,a=d(this,M,On).call(this,i,o);let h,c=null;n.size===0?(h=a,c=S.fromVariables(i)):h=s(this,ae);const u=d(this,M,zi).call(this,i,o).union(n),g=i.difference(u);let p=d(this,M,xi).call(this,e,g,u,s(this,oe),s(this,oe),h);return p<h&&c!==null&&c.apply(),p=this.pro.worstSatisfactionDegree(),p>t&&p>0&&(s(this,dt)!==0||this.targetDeg===null)}};Cs=new WeakSet,En=function(t,e){const i=new Set(t);return i.add(e),i},oe=new WeakMap,ae=new WeakMap,us=new WeakMap,fs=new WeakMap,dt=new WeakMap,M=new WeakSet,zi=function(t,e){const i=new Map;for(const a of e)if(a.isDefined())for(const h of a)i.has(h)?i.set(h,(i.get(h)??0)+1):i.set(h,1);const n=[...t];n.sort((a,h)=>{let c=0,u=0;return i.has(a)&&(c=i.get(a)??0),i.has(h)&&(u=i.get(h)??0),c<u?1:c>u?-1:0});const o=new Set;for(const a of n){let h=!1;for(const c of e)if(c.isDefined()){h=!0;break}if(!h)break;a.clear(),o.add(a)}return o},zn=function(){let t=1,e=0;for(const i of this.pro.variables())for(const n of i){const o=n.lowestConsistencyDegree(),a=n.highestConsistencyDegree();o<t&&(t=o),a>e&&(e=a)}l(this,ae,t),l(this,oe,e)},xn=function(t,e,i,n,o,a,h){var p;const c=d(this,M,zi).call(this,e,a),u=d(p=Ls,Cs,En).call(p,t,i),g=e.difference(c);return d(this,M,xi).call(this,u,g,c,n,Math.min(o,n),h)},Sn=function(t,e,i,n,o,a){let h=s(this,ae);if(i.domain().size()===0)return h;let c=S.fromVariables(e),u=i.domain().at(0);const g=S.fromVariables(e);for(let p=0;p<i.domain().size()&&h<o;++p){const w=i.domain().at(p);i.assign(w);const x=Math.min(n,d(this,M,Nn).call(this,t,i,h,a));if(x>Math.max(h,a)){const J=new Set,Ft=Math.min(Math.min(x,o),d(this,M,Vn).call(this,t,e,i,x,o,J));if(Ft>h&&(h=Ft,u=w,c=S.fromVariables(e)),J.size){const mt=d(this,M,xn).call(this,t,e,i,x,o,J,Math.max(a,h));if(s(this,dt)!==-1)return h;mt>h&&(h=mt,u=w,c=S.fromVariables(e)),g.apply()}}}return c.apply(),i.assign(u),h},xi=function(t,e,i,n,o,a){for(e=new Set(e),i=new Set(i);;){if(this.debugOutput(`X1 ${t.size}, X2' ${e.size}, X3' ${i.size}`),this.targetDeg!==null&&this.targetDeg<=this.pro.worstSatisfactionDegree())return this.debugOutput("stop: current degree is above the target"),l(this,dt,1),o;if(this.iterLimit&&this.iterLimit<H(this,us)._++)return this.debugOutput("stop: number of iterations has reached the limit"),l(this,dt,0),o;if(s(this,fs)<Date.now())return this.debugOutput("stop: time limit has been reached"),l(this,dt,0),o;if(i.size===0)return o;const h=i.values().next().value,c=d(this,M,Sn).call(this,t,e,h,n,o,a);if(s(this,dt)!==-1)return o;if(c<a)return s(this,ae);e.add(h),i.delete(h),o=c}},On=function(t,e){const i=new Set;for(const o of t)for(const a of o)i.add(a);let n=1;for(const o of i){const a=o.satisfactionDegree();a!==D.UNDEFINED&&a<n&&(n=a)}for(const o of this.pro.constraints())o.lowestConsistencyDegree()<s(this,oe)&&e.add(o);return n},Nn=function(t,e,i,n){let o=1;const a=new Set;for(const h of t){const c=this.pro.constraintsBetween(h,e);for(const u of c)a.add(u)}for(const h of a){const c=h.satisfactionDegree();if(c!==D.UNDEFINED&&(c<o&&(o=c),o<=i||o<=n))return o}return o},Vn=function(t,e,i,n,o,a){let h=1;const c=new Set;for(const u of t){const g=this.pro.constraintsBetween(u,i);for(const p of g)c.add(p)}for(const u of e){const g=this.pro.constraintsBetween(u,i);for(const p of g)c.add(p)}for(const u of c){const g=u.satisfactionDegree();g!==D.UNDEFINED&&g<h&&(h=g)}for(const u of c){const g=u.satisfactionDegree();g!==D.UNDEFINED&&(g<n||g<o)&&a.add(u)}return h},f(Ls,Cs);let Ks=Ls;class Kn extends W{constructor(t){super(t);f(this,Me);f(this,ls,!0);f(this,Tt);f(this,Ae,0);l(this,Tt,new Array(this.pro.constraintSize())),s(this,Tt).fill(1)}name(){return"Fuzzy Breakout"}setRandomness(t){l(this,ls,t)}exec(){const t=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let e=0;for(const a of this.pro.variables())a.isEmpty()&&a.assign(a.domain().at(0));const i=this.pro.worstSatisfactionDegree(),n=new S,o=new S;for(;;){const[a,h]=this.pro.constraintsWithWorstSatisfactionDegree();if(this.debugOutput(`worst satisfaction degree: ${h}`),this.iterLimit&&this.iterLimit<e++){this.debugOutput("stop: number of iterations has reached the limit");break}if(t<Date.now()){this.debugOutput("stop: time limit has been reached");break}if(s(this,Ae)<h&&(o.setProblem(this.pro),l(this,Ae,h),this.foundSolution(o,s(this,Ae))))return!0;if(this.targetDeg&&this.targetDeg<=h)return this.debugOutput("stop: current degree is above the target"),!0;if(d(this,Me,kn).call(this,d(this,Me,Cn).call(this,a),n),0<n.size()){const c=s(this,ls)?n.random():n.at(0);c.apply(),n.clear(),this.debugOutput("	"+c)}else{for(const c of a)s(this,Tt)[c.index()]+=1;this.debugOutput("breakout")}}return this.targetDeg===null&&i<this.pro.worstSatisfactionDegree()}}ls=new WeakMap,Tt=new WeakMap,Ae=new WeakMap,Me=new WeakSet,kn=function(t,e){let i=0;for(const n of t){const o=n.value();let a=0;for(const h of n)a+=(1-h.satisfactionDegree())*s(this,Tt)[h.index()];t:for(const h of n.domain()){if(o===h)continue;n.assign(h);let c=a;for(const u of n)if(c-=(1-u.satisfactionDegree())*s(this,Tt)[u.index()],c<i)continue t;c>i?(i=c,e.clear(),e.addVariable(n,h)):i!==0&&e.addVariable(n,h)}n.assign(o)}},Cn=function(t){const e=new Set;for(const i of t)for(const n of i)e.add(n);return Array.from(e)};const ri=class ri extends W{constructor(t,e=1){super(t);f(this,Re);f(this,ot,[]);f(this,ds,[]);f(this,gs);l(this,gs,e)}static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}name(){return"Fuzzy GENET"}exec(){if(!d(this,Re,Ln).call(this,s(this,gs)))throw new Error;const t=this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit;let e=0;const i=new S,n=[];for(let h=0;h<s(this,ot).length;++h)n.push(h);let o=this.pro.worstSatisfactionDegree(),a=!1;for(;;){if(this.iterLimit&&this.iterLimit<e++){this.debugOutput("stop: number of iterations has reached the limit");break}if(t<Date.now()){this.debugOutput("stop: time limit has been reached");break}let h=!1;for(const c of d(this,Re,An).call(this,n))s(this,ot)[c].setActivityMaximumInput()&&(h=!0);if(h){for(const u of s(this,ot))u.applyToVariable();const c=this.pro.worstSatisfactionDegree();if(o<c){if(o=c,this.debugOutput(`worst satisfaction degree: ${c}`),i.setProblem(this.pro),this.foundSolution(i,c)){a=!0;break}if(this.targetDeg===null)a=!0;else if(this.targetDeg<=o){this.debugOutput("stop: current degree is above the target"),a=!0;break}}}else{for(const c of s(this,ds))c.refreshWeight();continue}}return i.apply(),a}};ot=new WeakMap,ds=new WeakMap,gs=new WeakMap,Re=new WeakSet,Ln=function(t){this.debugOutput("network creation start");const e=[];for(const i of this.pro.variables()){if(i.domain().size()===0)return!1;s(this,ot).push(new Zs(i))}for(const i of this.pro.constraints())if(i.size()===1){const n=i.at(0),o=s(this,ot)[n.index()];for(let a=0;a<o.size();++a){const h=n.value();n.assign(o.get(a)._value),i.satisfactionDegree()<=t&&e.push(new Vi(i,o.get(a))),n.assign(h)}}else{const n=i.at(0),o=i.at(1),a=s(this,ot)[n.index()],h=s(this,ot)[o.index()];for(let c=0;c<a.size();++c){const u=n.value();n.assign(a.get(c)._value);for(let g=0;g<h.size();++g){const p=o.value();o.assign(h.get(g)._value),i.satisfactionDegree()<=t&&e.push(new Vi(i,a.get(c),h.get(g))),o.assign(p)}n.assign(u)}}for(const i of s(this,ot))for(const n of i._neurons)n.lockConnections();return l(this,ds,e),this.debugOutput("network creation complete"),!0},An=function(t){for(let e=t.length;e>1;--e){const i=ri.nextInt(e),n=t[e-1];t[e-1]=t[i],t[i]=n}return t};let Qs=ri;const As=class As{constructor(r){f(this,ps);f(this,ms);f(this,Ie,0);f(this,yt,[]);O(this,"_neurons",[]);l(this,ms,r);for(const t of r.domain())this._neurons.push(new Qn(t));d(this,ps,Si).call(this,As.nextInt(this._neurons.length))}static nextInt(r){return Math.floor(Math.random()*Math.floor(r))}applyToVariable(){s(this,ms).assign(this._neurons[s(this,Ie)]._value)}get(r){return this._neurons[r]}neurons(){return this._neurons}setActivityMaximumInput(){s(this,yt).length=0;let r=Number.NEGATIVE_INFINITY,t=!1;for(let e=0;e<this._neurons.length;++e){const i=this._neurons[e].getInput();r<=i&&(r<i&&(r=i,s(this,yt).length=0,t=!1),s(this,yt).push(e),s(this,Ie)===e&&(t=!0))}return t||s(this,yt).length===0?!1:(d(this,ps,Si).call(this,s(this,yt)[As.nextInt(s(this,yt).length)]),!0)}size(){return this._neurons.length}};ms=new WeakMap,Ie=new WeakMap,yt=new WeakMap,ps=new WeakSet,Si=function(r){for(const t of this._neurons)t._isActive=!1;this._neurons[r]._isActive=!0,l(this,Ie,r)};let Zs=As;class Vi{constructor(r,t,e=null){f(this,he);f(this,gt);f(this,at);O(this,"_weight");this._weight=r.satisfactionDegree()-1,l(this,he,r),l(this,gt,t),s(this,gt).addConnection(this),l(this,at,e),s(this,at)!==null&&s(this,at).addConnection(this)}getNeuron(r){return r===s(this,gt)?s(this,at):r===s(this,at)?s(this,gt):null}refreshWeight(){!s(this,gt)._isActive||s(this,at)!==null&&!s(this,at)._isActive||(s(this,he).size()===1?this._weight+=s(this,he).fuzzyRelation().satisfactionDegree(s(this,gt)._value)-1:this._weight+=s(this,he).fuzzyRelation().satisfactionDegree(s(this,gt)._value,s(this,at)._value)-1)}}he=new WeakMap,gt=new WeakMap,at=new WeakMap;class Qn{constructor(r){f(this,Te,[]);f(this,bs,[]);O(this,"_value");O(this,"_isActive",!1);this._value=r}addConnection(r){s(this,Te).push(r)}lockConnections(){l(this,bs,[...s(this,Te)]),l(this,Te,null)}getInput(){let r=0;for(const t of s(this,bs)){const e=t.getNeuron(this);r+=t._weight*(e===null||e._isActive?1:0)}return r}}Te=new WeakMap,bs=new WeakMap;const Ms=class Ms extends W{constructor(t){super(t);f(this,Y);f(this,ce,new Set);f(this,et,new Set);f(this,je,[]);f(this,ue,[]);f(this,Et,new Set);f(this,ws,0);f(this,Ds,0);f(this,vs,!0);for(const e of this.pro.constraints())s(this,je).push(new Zn(e)),s(this,ue).push(null)}name(){return"SRS 3"}exec(){if(l(this,Ds,this.timeLimit===null?Number.MAX_VALUE:Date.now()+this.timeLimit),l(this,ws,0),this.targetDeg&&this.targetDeg<=this.pro.worstSatisfactionDegree())return!0;const t=new S;let e=!1;for(;!(!d(this,Y,Tn).call(this)||s(this,Et).size);){const n=this.pro.worstSatisfactionDegree();if(n!==-1){if(this.debugOutput(`	found a solution: ${n}	${this.targetDeg}`),t.setProblem(this.pro),this.foundSolution(t,n)){e=!0;break}if(this.targetDeg===null)e=!0;else if(this.targetDeg<=n){this.debugOutput("stop: current degree is above the target"),e=!0;break}}}return e}setRandomness(t){l(this,vs,t)}};ce=new WeakMap,et=new WeakMap,je=new WeakMap,ue=new WeakMap,Et=new WeakMap,ws=new WeakMap,Ds=new WeakMap,vs=new WeakMap,Y=new WeakSet,Mn=function(t){const e=t.index();return s(this,ue)[e]===null&&(s(this,ue)[e]=t.neighbors()),s(this,ue)[e]},Hs=function(t){this.debugOutput("repair");const e=new S,i=t.satisfactionDegree(),n=this.pro.worstSatisfactionDegree();let o=t.satisfactionDegree();for(const a of t){const h=a.value();t:for(const c of a.domain()){if(h===c)continue;a.assign(c);const u=t.satisfactionDegree();if(!(i>u||o-u>Ms.REPAIR_THRESHOLD)){for(const g of a){if(g===t)continue;const p=g.satisfactionDegree();if(p!==D.UNDEFINED&&p<n)continue t}u>o&&(o=u,e.clear()),e.addVariable(a,c)}}a.assign(h)}if(e.size()>0){const a=s(this,vs)?e.random():e.at(0);return a.apply(),this.debugOutput("	"+a),!0}return!1},Rn=function(t){this.debugOutput("shrink");let e=!1;for(;;){if(t=t.parent(),s(this,Et).delete(t)){e=!0;break}if(!d(this,Y,Hs).call(this,t.parent().getObject()))break}const i=[];t.getDescendants(i);for(const n of i)n.clear(),s(this,et).delete(n),s(this,ce).delete(n);e||s(this,et).add(t)},In=function(t){this.debugOutput("spread"),s(this,ce).add(t);for(const e of d(this,Y,Mn).call(this,t.getObject())){const i=s(this,je)[e.index()];!s(this,ce).has(i)&&!s(this,et).has(i)&&(t.add(i),s(this,et).add(i))}},Tn=function(){this.debugOutput("srs");const[t]=this.pro.constraintsWithWorstSatisfactionDegree();for(const e of t){const i=s(this,je)[e.index()];i.setParent(null),s(this,Et).add(i)}s(this,ce).clear(),s(this,et).clear();for(const e of s(this,Et))s(this,et).add(e);for(;s(this,Et).size&&s(this,et).size;){if(this.iterLimit&&this.iterLimit<H(this,ws)._++)return this.debugOutput("stop: number of iterations has reached the limit"),!1;if(s(this,Ds)<Date.now())return this.debugOutput("stop: time limit has been reached"),!1;const e=s(this,et).values().next().value;if(s(this,et).delete(e),d(this,Y,Hs).call(this,e.getObject())){if(s(this,Et).delete(e))continue;if(d(this,Y,Hs).call(this,e.parent().getObject())){d(this,Y,Rn).call(this,e);continue}}d(this,Y,In).call(this,e)}return!0},O(Ms,"REPAIR_THRESHOLD",0);let Os=Ms;class Zn{constructor(r){f(this,fe,[]);f(this,jt);f(this,ys);l(this,jt,null),l(this,ys,r)}add(r){l(r,jt,this),s(this,fe).push(r)}clear(){for(const r of s(this,fe))l(r,jt,null);s(this,fe).length=0}getDescendants(r){r.push(this);for(const t of s(this,fe))t.getDescendants(r)}getObject(){return s(this,ys)}parent(){return s(this,jt)}setParent(r){l(this,jt,r)}}fe=new WeakMap,jt=new WeakMap,ys=new WeakMap;class Xn{static apply(r,t){console.log("start post-stabilization");let e,i=0;do{console.log("post-stabilization: count "+i++),e=!1;let n=r.worstSatisfactionDegree();const o=r.variables();for(let a=0;a<o.length;++a){const h=o[a],c=h.value(),u=t.at(a);c!==u.value()&&(u.apply(),r.worstSatisfactionDegree()>=n?e=!0:h.assign(c))}}while(e);return console.log("finish post-stabilization"),!0}}class tr extends Os{constructor(r){super(r)}name(){return"SRS 3 + PF"}exec(){let r=0,t=0;this.debug&&(r=this.pro.worstSatisfactionDegree(),t=this.pro.emptyVariableSize());const e=new S;e.setProblem(this.pro);const i=super.exec();return i&&Xn.apply(this.pro,e),this.debugOutput(`result: ${i?"success":"failure"}`),this.debugOutput(`satisfaction degree: ${r} -> ${this.pro.worstSatisfactionDegree()}`),this.debugOutput(`unassigned size: ${t} -> ${this.pro.emptyVariableSize()}`),i}}class Fe{static crispSolverNames(){return["Forward Checking","Max Forward Checking","Local Changes","Local Changes Ex","Breakout","GENET","Crisp SRS 3"]}static fuzzySolverNames(){return["Fuzzy Forward Checking","Fuzzy Forward Checking Bc","Flexible Local Changes","Flexible Local Changes Ex","Fuzzy Breakout","Fuzzy GENET","SRS 3","SRS 3 PF"]}static async createSolver(r,t){const e=await Fe.createCrispSolver(r,t);if(e)return e;const i=await Fe.createFuzzySolver(r,t);return i||null}static async createCrispSolver(r,t){switch(r.replaceAll(" ","")){case"ForwardChecking":case"forward-checking":return new Pn(t);case"MaxForwardChecking":case"max-forward-checking":return new Bn(t);case"LocalChanges":case"local-changes":return new Bs(t);case"LocalChangesEx":case"local-changes-ex":return new Ws(t);case"Breakout":case"breakout":return new Wn(t);case"GENET":case"genet":return new Gs(t);case"CrispSRS3":case"crisp-srs3":return new Yn(t)}return null}static async createFuzzySolver(r,t){switch(r.replaceAll(" ","")){case"FuzzyForwardChecking":case"fuzzy-forward-checking":return new qs(t);case"FuzzyForwardCheckingBc":case"fuzzy-forward-checking-bc":return new Ys(t);case"FlexibleLocalChanges":case"flexible-local-changes":return new Js(t);case"FlexibleLocalChangesEx":case"flexible-local-changes-ex":return new Ks(t);case"FuzzyBreakout":case"fuzzy-breakout":return new Kn(t);case"FuzzyGENET":case"fuzzy-genet":return new Qs(t);case"SRS3":case"srs3":return new Os(t);case"SRS3PF":case"SRS3_PF":case"srs3-pf":return new tr(t)}return null}}const zs=class zs{static random(r,t){var i,n;const e=d(i=zs,Es,Oi).call(i,r);return e/(e+d(n=zs,Es,Oi).call(n,t))}};Es=new WeakSet,Oi=function(r){let t,e,i,n,o;if(r>1){t=Math.sqrt(2*r-1);do do{do{do e=Math.random(),i=2*Math.random()-1;while(e*e+i*i>=1||e===0);i=i/e,e=t*i+r-1}while(e<=0);n=(r-1)*Math.log(e/(r-1))-t*i}while(n<=-50);while((1+i*i)*Math.exp(n)<=Math.random())}else{t=Math.E/(r+Math.E);do Math.random()<t?(e=0,i=1,o=Math.random(),o>0&&(e=Math.exp(Math.log(o)/r),i=Math.exp(-e))):(o=Math.random(),e=1,i=0,o>0&&(e=1-Math.log(o),i=Math.exp((r-1)*Math.log(e))));while(Math.random()>=i)}return e},f(zs,Es);let Xs=zs;class er{constructor(){O(this,"_debug",!0);f(this,Rs,r=>console.log(r))}setDebugMode(r){this._debug=r}setDebugOutput(r){this._debugOutput=r}_debugOutput(r){this._debug&&s(this,Rs).call(this,r)}}Rs=new WeakMap;const Ts=class Ts extends er{constructor(t,e,i,n=null){super();f(this,Is);f(this,st);f(this,le);f(this,zt);f(this,ht);l(this,st,t),l(this,le,e),l(this,zt,i),l(this,ht,n??t)}static nextInt(t){return Math.floor(Math.random()*Math.floor(t))}getVariableCount(){return s(this,st)}setVariableCount(t){l(this,st,t)}getDensity(){return s(this,le)}setDensity(t){l(this,le,t)}getAverageTightness(){return s(this,zt)}setAverageTightness(t){l(this,zt,t)}getDomainSize(){return s(this,ht)}setDomainSize(t){l(this,ht,t)}isFuzzy(){return!0}createProblem(t){const e=s(this,le)*((s(this,st)*s(this,st)-s(this,st))/2)|0,i=[];for(let n=0;n<s(this,st);++n)i.push(t.createVariable({domain:t.createDomain({min:0,max:s(this,ht)-1}),value:0,name:""}));for(;t.constraintSize()<e;){const n=Ts.nextInt(s(this,st)),o=Ts.nextInt(s(this,st));n!==o&&t.constraintsBetween(i[n],i[o]).length===0&&t.createConstraint({relation:new sr(d(this,Is,jn).call(this)),variables:[i[n],i[o]]})}return t}};st=new WeakMap,le=new WeakMap,zt=new WeakMap,ht=new WeakMap,Is=new WeakSet,jn=function(){const t=[];for(let e=0;e<s(this,ht);++e)t.push(new Array(s(this,ht)));for(let e=0;e<s(this,ht);++e)for(let i=0;i<s(this,ht);++i){const n=s(this,zt)===0?Number.MAX_VALUE:(1-s(this,zt))/s(this,zt);t[e][i]=Xs.random(1,n)}return t};let ti=Ts;class sr{constructor(r){f(this,xs);l(this,xs,r)}satisfactionDegree(r,t){return s(this,xs)[r][t]}}xs=new WeakMap,onmessage=async y=>{const{task:r,args:t}=y.data;switch(r){case"create":ir(...t);break;case"solve":nr(...t);break}};let ei=null,si=null;function ir(y,r,t){ei=new ti(y,r,t),ei.setDebugOutput(ki),si=ei.createProblem(new Hn)}async function nr(y,r){const t=Date.now(),e=Fe.fuzzySolverNames()[y],i=await Fe.createSolver(e,si);i.setTargetRate(r),i.setDebugOutput(ki);const n=i.solve(),o=Date.now()-t,a=si.worstSatisfactionDegree();postMessage({result:n,time:o,deg:a,solver:i.name()})}function ki(y){postMessage({log:y})}})();
