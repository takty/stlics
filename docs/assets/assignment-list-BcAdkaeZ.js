var G=Object.defineProperty;var C=i=>{throw TypeError(i)};var U=(i,t,e)=>t in i?G(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var $=(i,t,e)=>U(i,typeof t!="symbol"?t+"":t,e),F=(i,t,e)=>t.has(i)||C("Cannot "+e);var s=(i,t,e)=>(F(i,t,"read from private field"),e?e.call(i):t.get(i)),n=(i,t,e)=>t.has(i)?C("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(i):t.set(i,e),r=(i,t,e,u)=>(F(i,t,"write to private field"),u?u.call(i,e):t.set(i,e),e);var O=(i,t,e,u)=>({set _(f){r(i,t,f,e)},get _(){return s(i,t,u)}});var E,w;class j{constructor(){n(this,E,-1);n(this,w,"");$(this,"userObject",null)}setIndex(t){r(this,E,t)}setName(t){r(this,w,t)}index(){return s(this,E)}name(){return s(this,w)}}E=new WeakMap,w=new WeakMap;var p,x,b,y,o;const g=class g extends j{constructor(e,u){super();n(this,x);n(this,b);n(this,y,s(g,p));n(this,o,[]);r(this,x,e),r(this,b,u)}toString(){const e=this.name(),u=e?`(${e})`:"",f=this.isEmpty()?"<empty>":""+this.value();return`x${this.index()}${u} = ${f}`}size(){return s(this,o).length}at(e){return s(this,o).at(e)}has(e){return s(this,o).includes(e)}indexOf(e){return s(this,o).indexOf(e)}neighbors(){const e=[];for(const u of s(this,o))for(const f of u)f!==this&&e.push(f);return e}[Symbol.iterator](){return s(this,o)[Symbol.iterator]()}owner(){return s(this,x)}connect(e){if(s(this,o).includes(e))throw new RangeError;s(this,o).push(e)}disconnect(e){if(!s(this,o).includes(e))throw new RangeError;r(this,o,s(this,o).filter(u=>u!==e))}domain(e){if(e===void 0)return s(this,b);r(this,b,e),this.clear()}assign(e){r(this,y,e)}clear(){this.assign(s(g,p))}value(){return s(this,y)}isEmpty(){return this.value()===s(g,p)}};p=new WeakMap,x=new WeakMap,b=new WeakMap,y=new WeakMap,o=new WeakMap,n(g,p,Number.MIN_VALUE);let R=g;var d,D,L,M,v,l,S,N,A,T,I;class k{constructor(){n(this,d,!0);n(this,D,t=>console.log(t));n(this,L,()=>!1);n(this,M,Number.MAX_SAFE_INTEGER);n(this,v,null);n(this,l,.8);n(this,S,null);n(this,N,0);n(this,A,0);n(this,T,-1);n(this,I,0)}initialize(){r(this,N,s(this,v)===null?Number.MAX_VALUE:Date.now()+s(this,v)),r(this,A,0)}check(t=null){if(t!==null&&s(this,l)!==null&&s(this,l)<=t)return this.outputDebugString("Stop: Current evaluation value is above the target"),!0;if(s(this,M)<O(this,A)._++)return this.outputDebugString("Stop: Number of iterations has reached the limit"),!1;if(s(this,N)<Date.now())return this.outputDebugString("Stop: Time limit has been reached"),!1;if(t!==null&&s(this,S)!==null)if(t!==-1&&s(this,T)===t){if(s(this,S)<O(this,I)._++)return this.outputDebugString("Stop: Evaluation value has not changed for a certain number of times"),!1}else r(this,T,t),r(this,I,0);return null}solutionFound(t,e){return s(this,L).call(this,t,e)}outputDebugString(t){s(this,d)&&s(this,D).call(this,t)}isDebugMode(){return s(this,d)}isTargetAssigned(){return s(this,l)!==null}getTarget(){return s(this,l)}setIterationLimit(t=null){r(this,M,t===null?Number.MAX_SAFE_INTEGER:t)}setTimeLimit(t=null){r(this,v,t)}setTarget(t=null){r(this,l,t)}setSameEvaluationLimit(t=null){r(this,S,t)}setListener(t){r(this,L,t)}setDebugMode(t){r(this,d,t)}setDebugOutput(t){r(this,D,t)}}d=new WeakMap,D=new WeakMap,L=new WeakMap,M=new WeakMap,v=new WeakMap,l=new WeakMap,S=new WeakMap,N=new WeakMap,A=new WeakMap,T=new WeakMap,I=new WeakMap;class q{constructor(){$(this,"pro");$(this,"monitor")}name(){return""}solve(t,e=new k){this.pro=t,this.monitor=e,this.preprocess();const u=this.exec();return this.postprocess(),u}preprocess(){}exec(){return!1}postprocess(){}}var a,c;const V=class V{constructor(t,e=null){n(this,a);n(this,c);if(t instanceof V)r(this,a,t.variable()),r(this,c,t.value());else if(t instanceof R)r(this,a,t),r(this,c,e??t.value());else throw new RangeError}apply(){s(this,a).assign(s(this,c))}toString(){return`v${s(this,a).index()} <- ${s(this,c)}`}value(){return s(this,c)}variable(){return s(this,a)}};a=new WeakMap,c=new WeakMap;let m=V;var h;const z=class z{constructor(){n(this,h,[])}static fromVariables(t){const e=new z;return e.setVariables(t),e}setProblem(t){s(this,h).length=0;for(const e of t.variables())s(this,h).push(new m(e))}setAssignmentList(t){s(this,h).length=0;for(const e of t)s(this,h).push(new m(e))}setVariables(t){s(this,h).length=0;for(const e of t)s(this,h).push(new m(e))}addVariable(t,e=null){s(this,h).push(new m(t,e))}apply(){for(const t of s(this,h))t.apply()}clear(){s(this,h).length=0}isEmpty(){return s(this,h).length===0}size(){return s(this,h).length}differenceSize(){let t=0;for(const e of s(this,h))e.variable().value()!==e.value()&&++t;return t}at(t){return s(this,h)[t]}[Symbol.iterator](){return s(this,h)[Symbol.iterator]()}random(){return s(this,h)[Math.floor(Math.random()*s(this,h).length)]}};h=new WeakMap;let X=z;export{X as A,q as S};
