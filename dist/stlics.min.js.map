{
  "version": 3,
  "sources": ["../src/problem/element.ts", "../src/problem/variable.ts", "../src/problem/domain.ts", "../src/problem/domain-ranged.ts", "../src/problem/domain-arbitrary.ts", "../src/problem/relation.ts", "../src/problem/constraint.ts", "../src/problem/constraint-1.ts", "../src/problem/constraint-2.ts", "../src/problem/constraint-3.ts", "../src/problem/constraint-n.ts", "../src/problem/problem.ts", "../src/problem/variables.ts", "../src/solver/monitor.ts", "../src/solver/solver.ts", "../src/util/domain-pruner.ts", "../src/util/assignment.ts", "../src/util/assignment-list.ts", "../src/problem/relations.ts", "../src/util/problems.ts", "../src/solver/crisp/forward-checking.ts", "../src/solver/crisp/max-forward-checking.ts", "../src/solver/crisp/local-changes.ts", "../src/solver/crisp/local-changes-ex.ts", "../src/solver/crisp/breakout.ts", "../src/solver/crisp/genet.ts", "../src/solver/crisp/crisp-srs3.ts", "../src/solver/fuzzy/full-checking.ts", "../src/solver/fuzzy/fuzzy-forward-checking.ts", "../src/solver/fuzzy/flexible-local-changes.ts", "../src/solver/fuzzy/flexible-local-changes-ex.ts", "../src/solver/fuzzy/fuzzy-breakout.ts", "../src/solver/fuzzy/fuzzy-genet.ts", "../src/solver/fuzzy/srs3.ts", "../src/solver/filter/post-stabilizer.ts", "../src/solver/solver-factory-static.ts", "../src/solver/filter/ac3.ts", "../src/solver/filter/node-consistency.ts", "../src/util/loop-detector.ts"],
  "sourcesContent": ["/**\r\n * The common class of variables and constraints.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-10-21\r\n */\r\n\r\nexport class Element {\r\n\r\n\t#index: number = -1;\r\n\t#name: string = '';\r\n\r\n\t/**\r\n\t * It is used when the user wishes to associate an arbitrary object with each element.\r\n\t */\r\n\tuserObject: any = null;\r\n\r\n\t/**\r\n\t * Used when the solver wants to associate an arbitrary object with each element.\r\n\t */\r\n\tsolverObject: any = null;\r\n\r\n\t// Called only from Problem.\r\n\tsetIndex(index: number): void {\r\n\t\tthis.#index = index;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the name.\r\n\t *\r\n\t * @param name string representing the name.\r\n\t */\r\n\tsetName(name: string): void {\r\n\t\tthis.#name = name;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the index on the owned problem.\r\n\t * Each variable and constraint is assigned a serial number as an index, which is used to access it through the problem.\r\n\t *\r\n\t * @return Integer value representing the index.\r\n\t */\r\n\tindex(): number {\r\n\t\treturn this.#index;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the name.\r\n\t *\r\n\t * @return String representing the name.\r\n\t */\r\n\tname(): string {\r\n\t\treturn this.#name;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Class that represents a variable.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-10-21\r\n */\r\n\r\nimport { Problem } from './problem';\r\nimport { Element } from './element';\r\nimport { Constraint } from './constraint';\r\nimport { Domain } from './domain';\r\n\r\nexport class Variable extends Element {\r\n\r\n\tstatic readonly #INVALID: number = Number.MIN_VALUE;\r\n\r\n\t#owner: Problem;\r\n\r\n\t#d: Domain;\r\n\t#v: number = Variable.#INVALID;\r\n\t#cs: Constraint[] = [];\r\n\r\n\t// Called only from Problem.\r\n\tconstructor(owner: Problem, d: Domain) {\r\n\t\tsuper();\r\n\t\tthis.#owner = owner;\r\n\t\tthis.#d = d;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets a string representation.\r\n\t * @return A string representation.\r\n\t */\r\n\ttoString(): string {\r\n\t\tconst n = this.name();\r\n\t\tconst np = n ? `(${n})` : '';\r\n\t\tconst v = this.isEmpty() ? '<empty>' : ('' + this.value());\r\n\r\n\t\treturn `x${this.index()}${np} = ${v}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the number of associated constraints.\r\n\t * @return Number of constraints.\r\n\t */\r\n\tsize(): number {\r\n\t\treturn this.#cs.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the associated constraints by specifying their indices.\r\n\t * @param index Index.\r\n\t * @return A constraint.\r\n\t */\r\n\tat(index: number): Constraint | undefined {\r\n\t\treturn this.#cs.at(index);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether or not the variable is associated with the specified constraint.\r\n\t * @param c A constraint.\r\n\t * @return True if associated.\r\n\t */\r\n\thas(c: Constraint): boolean {\r\n\t\treturn this.#cs.includes(c);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the index of a specified constraint.\r\n\t * If not found, returns -1.\r\n\t * @param c A constraint.\r\n\t * @return Index.\r\n\t */\r\n\tindexOf(c: Constraint): number {\r\n\t\treturn this.#cs.indexOf(c);\r\n\t}\r\n\r\n\t/**\r\n\t * Collects the variables connected via the associated constraints.\r\n\t * @return An array of variables\r\n\t */\r\n\tneighbors(): Variable[] {\r\n\t\tconst xs: Variable[] = [];\r\n\r\n\t\tfor (const c of this.#cs) {\r\n\t\t\tfor (const x of c) {\r\n\t\t\t\tif (x !== this) {\r\n\t\t\t\t\txs.push(x);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn xs;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the iterator of the associated constraints.\r\n\t */\r\n\t[Symbol.iterator](): Iterator<Constraint> {\r\n\t\treturn this.#cs[Symbol.iterator]();\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * Gets the problem that owns this variable.\r\n\t * @return Owner.\r\n\t */\r\n\towner(): Problem {\r\n\t\treturn this.#owner;\r\n\t}\r\n\r\n\t// Called only from Problem.\r\n\tconnect(c: Constraint): void {\r\n\t\tif (this.#cs.includes(c)) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\t\tthis.#cs.push(c);\r\n\t}\r\n\r\n\t// Called only from Problem.\r\n\tdisconnect(c: Constraint): void {\r\n\t\tif (!this.#cs.includes(c)) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\t\tthis.#cs = this.#cs.filter(\r\n\t\t\t(i: Constraint): boolean => i !== c\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the domain of the variable.\r\n\t * @return The domain.\r\n\t */\r\n\tdomain(): Domain;\r\n\r\n\t/**\r\n\t * Sets a new domain to the variable.\r\n\t * The variable will be in unassigned state.\r\n\t * @param d Domain to be assigned.\r\n\t */\r\n\tdomain(d: Domain): void;\r\n\r\n\tdomain(d?: Domain): Domain | void {\r\n\t\tif (d === undefined) {\r\n\t\t\treturn this.#d;\r\n\t\t} else {\r\n\t\t\tthis.#d = d;\r\n\t\t\tthis.clear();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Assign a value.\r\n\t * @param value Value.\r\n\t */\r\n\tassign(value: number): void {\r\n\t\tthis.#v = value;  // Do not change #val except here.\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the state of the variable to unassigned.\r\n\t */\r\n\tclear(): void {\r\n\t\t// Do not use the invalid value except here and below (isEmpty).\r\n\t\tthis.assign(Variable.#INVALID);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the value of the variable.\r\n\t * @returnThe value of the variable.\r\n\t */\r\n\tvalue(): number {\r\n\t\treturn this.#v;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether the value is unassigned or not.\r\n\t * @return True if unassigned.\r\n\t */\r\n\tisEmpty(): boolean {\r\n\t\treturn this.value() === Variable.#INVALID;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * An abstract class that represents a variable domain.\r\n * The domain is immutable.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-10-21\r\n */\r\n\r\nexport abstract class Domain {\r\n\r\n\t/**\r\n\t * Checks whether the specified value is included as an element of the domain.\r\n\t *\r\n\t * @param v A value.\r\n\t * @return True if the value is included.\r\n\t */\r\n\tabstract contains(v: number): boolean;\r\n\r\n\t/**\r\n\t * Gets the index of the specified value. If it does not exist, -1 is returned.\r\n\t *\r\n\t * @param v A value.\r\n\t * @return The index.\r\n\t */\r\n\tabstract indexOf(v: number): number;\r\n\r\n\t/**\r\n\t * Gets the size of the domain, including the pruned elements.\r\n\t *\r\n\t * @return The size.\r\n\t */\r\n\tabstract size(): number;\r\n\r\n\t/**\r\n\t * Gets the value at the specified index. The retrieved value may have been pruned.\r\n\t *\r\n\t * @param index An index.\r\n\t * @return The value.\r\n\t */\r\n\tabstract at(index: number): number;\r\n\r\n\t/**\r\n\t * Gets the iterator of the values of the domain.\r\n\t */\r\n\tabstract [Symbol.iterator](): Iterator<number>;\r\n\r\n\t/**\r\n\t * Gets an arbitrary value, regardless of whether it has been pruned or not.\r\n\t *\r\n\t * @return A value.\r\n\t */\r\n\trandom(): number {\r\n\t\treturn this.at(Math.floor(Math.random() * this.size()));\r\n\t}\r\n\r\n}\r\n", "/**\r\n * A variable domain with contiguous integer elements.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { Domain } from './domain';\r\n\r\nexport class DomainRanged extends Domain {\r\n\r\n\t#min: number;\r\n\t#max: number;\r\n\r\n\tconstructor(min: number, max: number) {\r\n\t\tsuper();\r\n\t\tthis.#min = min | 0;\r\n\t\tthis.#max = max | 0;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tcontains(v: number): boolean {\r\n\t\treturn this.#min <= v && v <= this.#max;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tindexOf(v: number): number {\r\n\t\treturn (this.#min <= v && v <= this.#max) ? (v - this.#min) : -1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tsize(): number {\r\n\t\treturn this.#max - this.#min + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tat(index: number): number {\r\n\t\treturn this.#min + index;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\t[Symbol.iterator](): Iterator<number> {\r\n\t\tlet v: number = this.#min;\r\n\t\tconst max: number = this.#max;\r\n\t\treturn {\r\n\t\t\tnext(): IteratorResult<number> {\r\n\t\t\t\tif (v <= max) {\r\n\t\t\t\t\treturn { value: v++, done: false };\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn { value: null, done: true };\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t};\r\n\t}\r\n\r\n}\r\n", "/**\r\n * A variable domain with arbitrary elements.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { Domain } from './domain';\r\n\r\nexport class DomainArbitrary extends Domain {\r\n\r\n\t#vs: number[];\r\n\r\n\tconstructor(vs: number[]) {\r\n\t\tsuper();\r\n\t\tthis.#vs = [...vs];\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tcontains(v: number): boolean {\r\n\t\treturn this.#vs.includes(v);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tindexOf(v: number): number {\r\n\t\treturn this.#vs.indexOf(v);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tsize(): number {\r\n\t\treturn this.#vs.length;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tat(index: number): number {\r\n\t\treturn this.#vs[index];\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\t[Symbol.iterator](): Iterator<number> {\r\n\t\treturn this.#vs[Symbol.iterator]();\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Interfaces that represents the relationship between variables.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\n/**\r\n * An interface that represents the relationship between variables.\r\n */\r\nexport abstract class Relation {\r\n\r\n\t/**\r\n\t * Gets whether or not the relation is satisfied in this crisp relation.\r\n\t * @param vs Values of each variable\r\n\t * @return Whether or not it is satisfied.\r\n\t */\r\n\tabstract isSatisfied(...vs: number[]): -1 | 0 | 1;\r\n\r\n\t/**\r\n\t * Gets the satisfaction degree in this fuzzy relation.\r\n\t * @param vs Values of each variable\r\n\t * @return A satisfaction degree d (0 <= d <= 1).\r\n\t */\r\n\tabstract degree(...vs: number[]): number;\r\n\r\n}\r\n\r\n/**\r\n * The class represents crisp relationships between variables.\r\n */\r\nexport abstract class CrispRelation extends Relation {\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tdegree(...vs: number[]): number {\r\n\t\treturn this.isSatisfied(...vs);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * The class represents fuzzy relationships between variables.\r\n */\r\nexport abstract class FuzzyRelation extends Relation {\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tisSatisfied(...vs: number[]): -1 | 0 | 1 {\r\n\t\tconst d: number = this.degree(...vs);\r\n\t\treturn (0 < d && d < 1) ? 0 : d as -1 | 0 | 1;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * The class represents a constraint.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { Element } from './element';\r\nimport { Variable } from './variable';\r\nimport { Relation } from './relation';\r\nimport { FuzzyRelation } from './relation';\r\n\r\nexport abstract class Constraint extends Element {\r\n\r\n\t/**\r\n\t * The constant indicating that the satisfaction degree is not defined.\r\n\t */\r\n\tstatic UNDEFINED: -1 = -1;\r\n\r\n\trel: Relation;\r\n\r\n\t// Called only from Problem.\r\n\tconstructor(r: Relation) {\r\n\t\tsuper();\r\n\t\tthis.rel = r;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the relation between variables.\r\n\t * @return Relation.\r\n\t */\r\n\trelation(): Relation {\r\n\t\treturn this.rel;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether this is a fuzzy constraint.\r\n\t * @return True if it is fuzzy constraint.\r\n\t */\r\n\tisFuzzy(): boolean {\r\n\t\treturn this.rel instanceof FuzzyRelation;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a string representation.\r\n\t * @return A string representation.\r\n\t */\r\n\ttoString(): string {\r\n\t\tconst n = this.name();\r\n\t\tconst np = n ? `(${n})` : '';\r\n\t\tconst s = this.degree();\r\n\t\tconst sn = s === Constraint.UNDEFINED ? 'UNDEFINED' : ('' + s);\r\n\r\n\t\treturn `c${this.index()}${np} = ${sn}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the order of the constraint, i.e., the number of (associated) variables in the scope.\r\n\t * @return Order.\r\n\t */\r\n\tabstract size(): number;\r\n\r\n\t/**\r\n\t * Gets the associated variable by specifying its index.\r\n\t * @param index Index.\r\n\t * @return A variable.\r\n\t */\r\n\tabstract at(index: number): Variable | undefined;\r\n\r\n\t/**\r\n\t * Returns whether the specified variable is associated or not.\r\n\t * @param x A variable.\r\n\t * @return True if it is associated.\r\n\t */\r\n\tabstract has(x: Variable): boolean;\r\n\r\n\t/**\r\n\t * Gets the index of a specified variable.\r\n\t * If not found, returns -1.\r\n\t * @param x A variable.\r\n\t * @return Index.\r\n\t */\r\n\tabstract indexOf(x: Variable): number;\r\n\r\n\t/**\r\n\t * Returns the set of constraints connected via the associated variables.\r\n\t * @return A set of constraints.\r\n\t */\r\n\tabstract neighbors(): Constraint[];\r\n\r\n\t/**\r\n\t * Gets the iterator of the associated variables.\r\n\t */\r\n\tabstract [Symbol.iterator](): Iterator<Variable>;\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * Returns the number of scope variables that have not been assigned a value.\r\n\t * @return Number of variables\r\n\t */\r\n\tabstract emptyVariableSize(): number;\r\n\r\n\t/**\r\n\t * Returns whether or not the satisfaction (degree) is defined.\r\n\t * Satisfaction (degree) is defined when all associated variables have values assigned to them.\r\n\t * @return True if it is defined.\r\n\t */\r\n\tabstract isDefined(): boolean;\r\n\r\n\t/**\r\n\t * Returns whether or not this constraint is satisfied.\r\n\t * @return 1 if satisfied, 0 if not, UNDEFINED if undefined\r\n\t */\r\n\tabstract isSatisfied(): -1 | 0 | 1;\r\n\r\n\t/**\r\n\t * Gets the current satisfaction degree.\r\n\t * @return Degree 0 - 1, UNDEFINED if undefined.\r\n\t */\r\n\tabstract degree(): number;\r\n\r\n\t/**\r\n\t * Calculates the highest consistency degree.\r\n\t * That is, it seeks the highest satisfaction degree of the possible combinations of variable assignments for a given constraint.\r\n\t * When all associated variables have been assigned values, it returns the same value as degree().\r\n\t * @return The highest consistency degree.\r\n\t */\r\n\tabstract highestConsistencyDegree(): number;\r\n\r\n\t/**\r\n\t * Calculates the lowest consistency degree.\r\n\t * That is, it seeks the lowest satisfaction degree of the possible combinations of variable assignments for a given constraint.\r\n\t * When all associated variables have been assigned values, it returns the same value as degree().\r\n\t * @return The lowest consistency degree.\r\n\t */\r\n\tabstract lowestConsistencyDegree(): number;\r\n\r\n}\r\n", "/**\r\n * The class represents an unary constraint.\r\n * The constructor is not called directly, since it is created by the Problem.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { Constraint } from './constraint';\r\nimport { Relation } from './relation';\r\nimport { Variable } from './variable';\r\n\r\nexport class Constraint1 extends Constraint {\r\n\r\n\t#xs: [Variable] = [] as unknown as [Variable];\r\n\r\n\t// Called only from Problem.\r\n\tconstructor(r: Relation, x: Variable) {\r\n\t\tsuper(r);\r\n\t\tthis.#xs = [x];\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tsize(): number {\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tat(index: number): Variable | undefined {\r\n\t\treturn this.#xs.at(index);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\thas(x: Variable) {\r\n\t\treturn x === this.#xs[0];\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tindexOf(x: Variable): number {\r\n\t\treturn (x === this.#xs[0]) ? 0 : -1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tneighbors(): Constraint[] {\r\n\t\tconst cs: Constraint[] = [];\r\n\r\n\t\tfor (const c of this.#xs[0]) {\r\n\t\t\tif (c !== this) {\r\n\t\t\t\tcs.push(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cs;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\t[Symbol.iterator](): Iterator<Variable> {\r\n\t\treturn this.#xs[Symbol.iterator]();\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\temptyVariableSize(): number {\r\n\t\treturn this.#xs[0].isEmpty() ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tisDefined(): boolean {\r\n\t\treturn !this.#xs[0].isEmpty();\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tisSatisfied(): -1 | 0 | 1 {\r\n\t\tif (this.#xs[0].isEmpty()) {\r\n\t\t\treturn Constraint.UNDEFINED;\r\n\t\t}\r\n\t\treturn this.rel.isSatisfied(this.#xs[0].value()) ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tdegree(): number {\r\n\t\tif (this.#xs[0].isEmpty()) {\r\n\t\t\treturn Constraint.UNDEFINED;\r\n\t\t}\r\n\t\treturn this.rel.degree(this.#xs[0].value());\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\thighestConsistencyDegree(): number {\r\n\t\tconst d: number = this.degree();\r\n\t\tif (d !== Constraint.UNDEFINED) {\r\n\t\t\treturn d;\r\n\t\t}\r\n\t\tlet cd: number = 0;\r\n\t\tconst fn = (v: number): boolean => {\r\n\t\t\tconst d: number = this.rel.degree(v);\r\n\t\t\tif (d > cd) {\r\n\t\t\t\tcd = d;\r\n\t\t\t}\r\n\t\t\treturn (cd === 1);\r\n\t\t}\r\n\t\tfor (const v of this.#xs[0].domain()) {\r\n\t\t\tif (fn(v)) break;\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tlowestConsistencyDegree(): number {\r\n\t\tconst d: number = this.degree();\r\n\t\tif (d !== Constraint.UNDEFINED) {\r\n\t\t\treturn d;\r\n\t\t}\r\n\t\tlet cd: number = 1;\r\n\t\tconst fn = (v: number): boolean => {\r\n\t\t\tconst d: number = this.rel.degree(v);\r\n\t\t\tif (d < cd) {\r\n\t\t\t\tcd = d;\r\n\t\t\t}\r\n\t\t\treturn (cd === 0);\r\n\t\t}\r\n\t\tfor (const v of this.#xs[0].domain()) {\r\n\t\t\tif (fn(v)) break;\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * The class represents an binary constraint.\r\n * The constructor is not called directly, since it is created by the Problem.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { Constraint } from './constraint';\r\nimport { Relation } from './relation';\r\nimport { Variable } from './variable';\r\nimport { Domain } from './domain';\r\n\r\nexport class Constraint2 extends Constraint {\r\n\r\n\t#xs: [Variable, Variable] = [] as unknown as [Variable, Variable];\r\n\r\n\t// Called only from Problem.\r\n\tconstructor(r: Relation, x1: Variable, x2: Variable) {\r\n\t\tsuper(r);\r\n\t\tthis.#xs = [x1, x2];\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tsize(): number {\r\n\t\treturn 2;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tat(index: number): Variable | undefined {\r\n\t\treturn this.#xs.at(index);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\thas(x: Variable): boolean {\r\n\t\treturn this.#xs[0] === x || this.#xs[1] === x;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tindexOf(x: Variable): number {\r\n\t\tif (x === this.#xs[0]) return 0;\r\n\t\tif (x === this.#xs[1]) return 1;\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tneighbors(): Constraint[] {\r\n\t\tconst cs: Constraint[] = [];\r\n\r\n\t\tfor (const x of this.#xs) {\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tif (c !== this) {\r\n\t\t\t\t\tcs.push(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cs;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\t[Symbol.iterator](): Iterator<Variable> {\r\n\t\treturn this.#xs[Symbol.iterator]();\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\temptyVariableSize(): number {\r\n\t\tlet n: number = 0;\r\n\r\n\t\tif (this.#xs[0].isEmpty()) ++n;\r\n\t\tif (this.#xs[1].isEmpty()) ++n;\r\n\t\treturn n;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tisDefined(): boolean {\r\n\t\treturn !this.#xs[0].isEmpty() && !this.#xs[1].isEmpty();\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tisSatisfied(): -1 | 0 | 1 {\r\n\t\tif (this.#xs[0].isEmpty() || this.#xs[1].isEmpty()) {\r\n\t\t\treturn Constraint.UNDEFINED;\r\n\t\t}\r\n\t\treturn this.rel.isSatisfied(this.#xs[0].value(), this.#xs[1].value()) ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tdegree(): number {\r\n\t\tif (this.#xs[0].isEmpty() || this.#xs[1].isEmpty()) {\r\n\t\t\treturn Constraint.UNDEFINED;\r\n\t\t}\r\n\t\treturn this.rel.degree(this.#xs[0].value(), this.#xs[1].value());\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\thighestConsistencyDegree(): number {\r\n\t\tconst d: number = this.degree();\r\n\t\tif (d !== Constraint.UNDEFINED) {\r\n\t\t\treturn d;\r\n\t\t}\r\n\t\tlet cd: number = 0;\r\n\t\tconst fn = (v1: number, v2: number): boolean => {\r\n\t\t\tconst d: number = this.rel.degree(v1, v2);\r\n\t\t\tif (d > cd) {\r\n\t\t\t\tcd = d;\r\n\t\t\t}\r\n\t\t\treturn (cd === 1);\r\n\t\t}\r\n\t\tconst v1: number = this.#xs[0].value();\r\n\t\tconst v2: number = this.#xs[1].value();\r\n\t\tconst d1: Domain = this.#xs[0].domain();\r\n\t\tconst d2: Domain = this.#xs[1].domain();\r\n\r\n\t\tif (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty()) {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tif (fn(v1, v2)) break;\r\n\t\t\t}\r\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty()) {\r\n\t\t\tfor (const v2 of d2) {\r\n\t\t\t\tif (fn(v1, v2)) break;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tfor (const v2 of d2) {\r\n\t\t\t\t\tif (fn(v1, v2)) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tlowestConsistencyDegree(): number {\r\n\t\tconst d: number = this.degree();\r\n\t\tif (d !== Constraint.UNDEFINED) {\r\n\t\t\treturn d;\r\n\t\t}\r\n\t\tlet cd: number = 1;\r\n\t\tconst fn = (v1: number, v2: number): boolean => {\r\n\t\t\tconst d: number = this.rel.degree(v1, v2);\r\n\t\t\tif (d < cd) {\r\n\t\t\t\tcd = d;\r\n\t\t\t}\r\n\t\t\treturn (cd === 0);\r\n\t\t}\r\n\t\tconst v1: number = this.#xs[0].value();\r\n\t\tconst v2: number = this.#xs[1].value();\r\n\t\tconst d1: Domain = this.#xs[0].domain();\r\n\t\tconst d2: Domain = this.#xs[1].domain();\r\n\r\n\t\tif (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty()) {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tif (fn(v1, v2)) break;\r\n\t\t\t}\r\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty()) {\r\n\t\t\tfor (const v2 of d2) {\r\n\t\t\t\tif (fn(v1, v2)) break;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tfor (const v2 of d2) {\r\n\t\t\t\t\tif (fn(v1, v2)) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * The class represents an 3-ary constraint.\r\n * The constructor is not called directly, since it is created by the Problem.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { Constraint } from './constraint';\r\nimport { Relation } from './relation';\r\nimport { Variable } from './variable';\r\nimport { Domain } from './domain';\r\n\r\nexport class Constraint3 extends Constraint {\r\n\r\n\t#xs: [Variable, Variable, Variable] = [] as unknown as [Variable, Variable, Variable];\r\n\r\n\t// Called only from Problem.\r\n\tconstructor(r: Relation, x1: Variable, x2: Variable, x3: Variable) {\r\n\t\tsuper(r);\r\n\t\tthis.#xs = [x1, x2, x3];\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tsize(): number {\r\n\t\treturn 3;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tat(index: number): Variable | undefined {\r\n\t\treturn this.#xs.at(index);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\thas(x: Variable): boolean {\r\n\t\treturn this.#xs[0] === x || this.#xs[1] === x || this.#xs[2] === x;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tindexOf(x: Variable): number {\r\n\t\tif (x === this.#xs[0]) return 0;\r\n\t\tif (x === this.#xs[1]) return 1;\r\n\t\tif (x === this.#xs[2]) return 2;\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tneighbors(): Constraint[] {\r\n\t\tconst cs: Constraint[] = [];\r\n\r\n\t\tfor (const x of this.#xs) {\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tif (c !== this) {\r\n\t\t\t\t\tcs.push(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cs;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\t[Symbol.iterator](): Iterator<Variable> {\r\n\t\treturn this.#xs[Symbol.iterator]();\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\temptyVariableSize(): number {\r\n\t\tlet n: number = 0;\r\n\r\n\t\tif (this.#xs[0].isEmpty()) ++n;\r\n\t\tif (this.#xs[1].isEmpty()) ++n;\r\n\t\tif (this.#xs[2].isEmpty()) ++n;\r\n\t\treturn n;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tisDefined(): boolean {\r\n\t\treturn !this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && !this.#xs[2].isEmpty();\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tisSatisfied(): -1 | 0 | 1 {\r\n\t\tif (this.#xs[0].isEmpty() || this.#xs[1].isEmpty() || this.#xs[2].isEmpty()) {\r\n\t\t\treturn Constraint.UNDEFINED;\r\n\t\t}\r\n\t\treturn this.rel.isSatisfied(this.#xs[0].value(), this.#xs[1].value(), this.#xs[2].value()) ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tdegree(): number {\r\n\t\tif (this.#xs[0].isEmpty() || this.#xs[1].isEmpty() || this.#xs[2].isEmpty()) {\r\n\t\t\treturn Constraint.UNDEFINED;\r\n\t\t}\r\n\t\treturn this.rel.degree(this.#xs[0].value(), this.#xs[1].value(), this.#xs[2].value());\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\thighestConsistencyDegree(): number {\r\n\t\tconst d: number = this.degree();\r\n\t\tif (d !== Constraint.UNDEFINED) {\r\n\t\t\treturn d;\r\n\t\t}\r\n\t\tlet cd: number = 0;\r\n\t\tconst fn = (v1: number, v2: number, v3: number): boolean => {\r\n\t\t\tconst d: number = this.rel.degree(v1, v2, v3);\r\n\t\t\tif (d > cd) {\r\n\t\t\t\tcd = d;\r\n\t\t\t}\r\n\t\t\treturn (cd === 1);\r\n\t\t}\r\n\t\tconst v1: number = this.#xs[0].value();\r\n\t\tconst v2: number = this.#xs[1].value();\r\n\t\tconst v3: number = this.#xs[2].value();\r\n\t\tconst d1: Domain = this.#xs[0].domain();\r\n\t\tconst d2: Domain = this.#xs[1].domain();\r\n\t\tconst d3: Domain = this.#xs[2].domain();\r\n\r\n\t\tif (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t}\r\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v2 of d2) {\r\n\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t}\r\n\t\t} else if (!this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v3 of d3) {\r\n\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t}\r\n\t\t} else if (this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tfor (const v2 of d2) {\r\n\t\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tfor (const v3 of d3) {\r\n\t\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v2 of d2) {\r\n\t\t\t\tfor (const v3 of d3) {\r\n\t\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tfor (const v2 of d2) {\r\n\t\t\t\t\tfor (const v3 of d3) {\r\n\t\t\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tlowestConsistencyDegree(): number {\r\n\t\tconst d: number = this.degree();\r\n\t\tif (d !== Constraint.UNDEFINED) {\r\n\t\t\treturn d;\r\n\t\t}\r\n\t\tlet cd: number = 1;\r\n\t\tconst fn = (v1: number, v2: number, v3: number): boolean => {\r\n\t\t\tconst d: number = this.rel.degree(v1, v2, v3);\r\n\t\t\tif (d < cd) {\r\n\t\t\t\tcd = d;\r\n\t\t\t}\r\n\t\t\treturn (cd === 0);\r\n\t\t}\r\n\t\tconst v1: number = this.#xs[0].value();\r\n\t\tconst v2: number = this.#xs[1].value();\r\n\t\tconst v3: number = this.#xs[2].value();\r\n\t\tconst d1: Domain = this.#xs[0].domain();\r\n\t\tconst d2: Domain = this.#xs[1].domain();\r\n\t\tconst d3: Domain = this.#xs[2].domain();\r\n\r\n\t\tif (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t}\r\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v2 of d2) {\r\n\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t}\r\n\t\t} else if (!this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v3 of d3) {\r\n\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t}\r\n\t\t} else if (this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && !this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tfor (const v2 of d2) {\r\n\t\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (this.#xs[0].isEmpty() && !this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tfor (const v3 of d3) {\r\n\t\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (!this.#xs[0].isEmpty() && this.#xs[1].isEmpty() && this.#xs[2].isEmpty()) {\r\n\t\t\tfor (const v2 of d2) {\r\n\t\t\t\tfor (const v3 of d3) {\r\n\t\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (const v1 of d1) {\r\n\t\t\t\tfor (const v2 of d2) {\r\n\t\t\t\t\tfor (const v3 of d3) {\r\n\t\t\t\t\t\tif (fn(v1, v2, v3)) break;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * The class represents an n-ary constraint.\r\n * The constructor is not called directly, since it is created by the Problem.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { Constraint } from './constraint';\r\nimport { Relation } from './relation';\r\nimport { Variable } from './variable';\r\nimport { Domain } from './domain';\r\n\r\nexport class ConstraintN extends Constraint {\r\n\r\n\t#xs: Variable[];\r\n\t#vs: number[];  // For reuse.\r\n\r\n\t// Called only from Problem.\r\n\tconstructor(r: Relation, ...xs: Variable[]) {\r\n\t\tsuper(r);\r\n\t\tthis.#xs = [...xs];\r\n\t\tthis.#vs = new Array(this.#xs.length);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tsize(): number {\r\n\t\treturn this.#xs.length;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tat(index: number): Variable | undefined {\r\n\t\treturn this.#xs.at(index);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\thas(x: Variable): boolean {\r\n\t\treturn this.#xs.includes(x);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tindexOf(x: Variable): number {\r\n\t\treturn this.#xs.indexOf(x);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tneighbors(): Constraint[] {\r\n\t\tconst cs: Constraint[] = [];\r\n\r\n\t\tfor (const x of this.#xs) {\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tif (c !== this) {\r\n\t\t\t\t\tcs.push(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cs;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\t[Symbol.iterator](): Iterator<Variable> {\r\n\t\treturn this.#xs[Symbol.iterator]();\r\n\t}\r\n\r\n\r\n\t// -------------------------------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\temptyVariableSize(): number {\r\n\t\tlet n: number = 0;\r\n\r\n\t\tfor (const x of this.#xs) {\r\n\t\t\tn += x.isEmpty() ? 1 : 0;\r\n\t\t}\r\n\t\treturn n;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tisDefined(): boolean {\r\n\t\tfor (const x of this.#xs) {\r\n\t\t\tif (x.isEmpty()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tisSatisfied(): -1 | 0 | 1 {\r\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\r\n\t\t\tconst x: Variable = this.#xs[i];\r\n\t\t\tif (x.isEmpty()) {\r\n\t\t\t\treturn Constraint.UNDEFINED;\r\n\t\t\t}\r\n\t\t\tthis.#vs[i] = x.value();\r\n\t\t}\r\n\t\treturn this.rel.isSatisfied(...this.#vs) ? 1 : 0;\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tdegree(): number {\r\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\r\n\t\t\tconst x: Variable = this.#xs[i];\r\n\t\t\tif (x.isEmpty()) {\r\n\t\t\t\treturn Constraint.UNDEFINED;\r\n\t\t\t}\r\n\t\t\tthis.#vs[i] = x.value();\r\n\t\t}\r\n\t\treturn this.rel.degree(...this.#vs);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\thighestConsistencyDegree(): number {\r\n\t\tconst d: number = this.degree();\r\n\t\tif (d !== Constraint.UNDEFINED) {\r\n\t\t\treturn d;\r\n\t\t}\r\n\t\tconst emptyIndices = new Array(this.emptyVariableSize());\r\n\t\tlet c: number = 0;\r\n\r\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\r\n\t\t\tconst x: Variable = this.#xs[i];\r\n\t\t\tif (x.isEmpty()) {\r\n\t\t\t\temptyIndices[c++] = i;\r\n\t\t\t} else {\r\n\t\t\t\tthis.#vs[i] = x.value();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.checkHCD(emptyIndices, 0, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * {@override}\r\n\t */\r\n\tlowestConsistencyDegree(): number {\r\n\t\tconst d: number = this.degree();\r\n\t\tif (d !== Constraint.UNDEFINED) {\r\n\t\t\treturn d;\r\n\t\t}\r\n\t\tconst emptyIndices = new Array(this.emptyVariableSize());\r\n\t\tlet c: number = 0;\r\n\r\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\r\n\t\t\tconst x: Variable = this.#xs[i];\r\n\t\t\tif (x.isEmpty()) {\r\n\t\t\t\temptyIndices[c++] = i;\r\n\t\t\t} else {\r\n\t\t\t\tthis.#vs[i] = x.value();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.checkLCD(emptyIndices, 0, 1);\r\n\t}\r\n\r\n\tcheckHCD(emptyIndices: number[], currentStep: number, cd: number): number {\r\n\t\tconst index: number = emptyIndices[currentStep];\r\n\t\tconst d: Domain = this.#xs[index].domain();\r\n\r\n\t\tif (currentStep === emptyIndices.length - 1) {\r\n\t\t\tfor (const v of d) {\r\n\t\t\t\tthis.#vs[index] = v;\r\n\t\t\t\tconst s: number = this.rel.degree(...this.#vs);\r\n\t\t\t\tif (s > cd) {\r\n\t\t\t\t\tcd = s;\r\n\t\t\t\t}\r\n\t\t\t\tif (cd === 1) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (const v of d) {\r\n\t\t\t\tthis.#vs[index] = v;\r\n\t\t\t\tcd = this.checkHCD(emptyIndices, currentStep + 1, cd);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n\tcheckLCD(emptyIndices: number[], currentStep: number, cd: number): number {\r\n\t\tconst index: number = emptyIndices[currentStep];\r\n\t\tconst d: Domain = this.#xs[index].domain();\r\n\r\n\t\tif (currentStep === emptyIndices.length - 1) {\r\n\t\t\tfor (const v of d) {\r\n\t\t\t\tthis.#vs[index] = v;\r\n\t\t\t\tconst s: number = this.rel.degree(...this.#vs);\r\n\t\t\t\tif (s < cd) {\r\n\t\t\t\t\tcd = s;\r\n\t\t\t\t}\r\n\t\t\t\tif (cd === 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (const v of d) {\r\n\t\t\t\tthis.#vs[index] = v;\r\n\t\t\t\tcd = this.checkLCD(emptyIndices, currentStep + 1, cd);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * The class represents a constraint satisfaction problem.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { Variable } from './variable';\r\nimport { Domain } from './domain';\r\nimport { DomainRanged } from './domain-ranged';\r\nimport { DomainArbitrary } from './domain-arbitrary';\r\nimport { Constraint } from './constraint';\r\nimport { Constraint1 } from './constraint-1';\r\nimport { Constraint2 } from './constraint-2';\r\nimport { Constraint3 } from './constraint-3';\r\nimport { ConstraintN } from './constraint-n';\r\nimport { Relation } from './relation';\r\n\r\nexport class Problem {\r\n\r\n\t#fv: (o: Problem, d: Domain) => Variable = (o: Problem, d: Domain): Variable => new Variable(o, d);\r\n\t#fc: (r: Relation, xs: Variable[]) => Constraint = (r: Relation, xs: Variable[]): Constraint => {\r\n\t\tif (xs.length === 1) {\r\n\t\t\treturn new Constraint1(r, xs[0]);\r\n\t\t}\r\n\t\tif (xs.length === 2) {\r\n\t\t\treturn new Constraint2(r, xs[0], xs[1]);\r\n\t\t}\r\n\t\tif (xs.length === 3) {\r\n\t\t\treturn new Constraint3(r, xs[0], xs[1], xs[2]);\r\n\t\t}\r\n\t\treturn new ConstraintN(r, ...xs);\r\n\t};\r\n\r\n\t#isFuzzy: boolean = false;\r\n\t#xs: Variable[] = [];\r\n\t#cs: Constraint[] = [];\r\n\r\n\r\n\t// Methods for Modifying Factories -----------------------------------------\r\n\r\n\r\n\t/**\r\n\t * Sets a variable factory.\r\n\t */\r\n\tsetVariableFactory(fn: (o: Problem, d: Domain) => Variable): void {\r\n\t\tthis.#fv = fn;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a variable factory.\r\n\t */\r\n\tsetConstraintFactory(fn: (r: Relation, xs: Variable[]) => Constraint): void {\r\n\t\tthis.#fc = fn;\r\n\t}\r\n\r\n\r\n\t// Generation Methods ------------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * Adds a variable to this problem.\r\n\t * @param Variable v A variable.\r\n\t */\r\n\taddVariable(x: Variable): void {\r\n\t\tx.setIndex(this.#xs.length);\r\n\t\tthis.#xs.push(x);\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a domain.\r\n\t * @param args {\r\n\t *   @type Array 'values' Multiple values.\r\n\t *\r\n\t *   @type Number 'min' Minimum value.\r\n\t *   @type Number 'max' Maximum value.\r\n\t * }\r\n\t * @return A domain.\r\n\t */\r\n\tcreateDomain(args: { values: number[]; } | { min: number, max: number; }): Domain | null {\r\n\t\tif ('values' in args) {\r\n\t\t\treturn new DomainArbitrary(args.values);\r\n\t\t} else if ('min' in args && 'max' in args) {\r\n\t\t\treturn new DomainRanged(args.min, args.max);\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a variable.\r\n\t * @param Array args {\r\n\t *   @type string 'name'   Display name.\r\n\t *   @type Domain 'domain' A domain.\r\n\t *   @type *      'value'  A value.\r\n\t * }\r\n\t * @return A variable.\r\n\t */\r\n\tcreateVariable(args: { name: string, domain: Domain, value?: number; } | { variable: Variable; }): Variable {\r\n\t\tif ('variable' in args) {\r\n\t\t\tconst x: Variable = this.#fv(this, args.variable.domain());\r\n\t\t\tthis.addVariable(x);\r\n\t\t\tx.setName(x.name());\r\n\t\t\tx.assign(x.value());\r\n\t\t\treturn x;\r\n\t\t} else {\r\n\t\t\tif (args.value !== undefined && !args.domain.contains(args.value)) {\r\n\t\t\t\tthrow new Error();\r\n\t\t\t}\r\n\t\t\tconst x: Variable = this.#fv(this, args.domain);\r\n\t\t\tthis.addVariable(x);\r\n\t\t\tif (args.name) {\r\n\t\t\t\tx.setName(args.name);\r\n\t\t\t}\r\n\t\t\tif (args.value) {\r\n\t\t\t\tx.assign(args.value);\r\n\t\t\t}\r\n\t\t\treturn x;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a constraint.\r\n\t * @param Array args {\r\n\t *   @type string   'name'      Display name.\r\n\t *   @type Array    'variables' Variables.\r\n\t *   @type Relation 'relation'  A relation.\r\n\t * }\r\n\t * @return A constraint.\r\n\t */\r\n\tcreateConstraint(args: { name?: string, variables: Variable[], relation: Relation; }): Constraint | null {\r\n\t\tfor (const x of args.variables) {\r\n\t\t\tif (x.owner() !== this) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst c: Constraint = this.#fc(args.relation, args.variables);\r\n\t\tc.setIndex(this.#cs.length);\r\n\t\tthis.#cs.push(c);\r\n\t\tfor (const x of args.variables) {\r\n\t\t\tx.connect(c);\r\n\t\t}\r\n\t\tif (c.isFuzzy()) {\r\n\t\t\tthis.#isFuzzy = true;\r\n\t\t}\r\n\t\tif ('name' in args) {\r\n\t\t\tc.setName(args.name as string);\r\n\t\t}\r\n\t\treturn c;\r\n\t}\r\n\r\n\r\n\t//  Modification Methods ---------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * Remove the constraint.\r\n\t * @param c Constraints to be removed.\r\n\t */\r\n\tremoveConstraint(c: Constraint): void {\r\n\t\tconst index: number = this.#cs.indexOf(c);\r\n\t\tthis.#cs.splice(index, 1);\r\n\t\tfor (let i: number = index; i < this.#cs.length; ++i) {\r\n\t\t\tthis.#cs[i].setIndex(i);\r\n\t\t}\r\n\t\tfor (const x of c) {\r\n\t\t\tx.disconnect(c);\r\n\t\t}\r\n\t\tthis.#isFuzzy = false;\r\n\t\tfor (const c of this.#cs) {\r\n\t\t\tif (c.isFuzzy()) {\r\n\t\t\t\tthis.#isFuzzy = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Changes the status of all variables to unassigned.\r\n\t */\r\n\tclearAllVariables(): void {\r\n\t\tfor (const x of this.#xs) {\r\n\t\t\tx.clear();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Reverse the order of variables.\r\n\t * The index of each variable is reassigned.\r\n\t */\r\n\treverseVariables(): void {\r\n\t\tthis.#xs.reverse();\r\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\r\n\t\t\tthis.#xs[i].setIndex(i);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sorts variables using a specified comparator.\r\n\t * The index of each variable is reassigned.\r\n\t * @param comparator A comparator.\r\n\t */\r\n\tsortVariables(comparator: (a: Variable, b: Variable) => number): void {\r\n\t\tthis.#xs.sort(comparator);\r\n\t\tfor (let i: number = 0; i < this.#xs.length; ++i) {\r\n\t\t\tthis.#xs[i].setIndex(i);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Methods for Variables ---------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * Returns the list of variables.\r\n\t * The returned list is not allowed to be modified.\r\n\t * @return The variable list.\r\n\t */\r\n\tvariables(): Variable[] {\r\n\t\treturn this.#xs;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the number of variables in the problem.\r\n\t * @return Number of variables\r\n\t */\r\n\tvariableSize(): number {\r\n\t\treturn this.#xs.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets a variable by index.\r\n\t * @param index Index (0 <= index < variableSize()).\r\n\t * @return A variable\r\n\t */\r\n\tvariableAt(index: number): Variable {\r\n\t\treturn this.#xs[index];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets a variable by name.\r\n\t * @param name Name.\r\n\t * @return A variable.\r\n\t */\r\n\tvariableOf(name: string): Variable | null {\r\n\t\tfor (const x of this.#xs) {\r\n\t\t\tif (x.name() === name) {\r\n\t\t\t\treturn x;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the variable is contained or not.\r\n\t * @param x A variable.\r\n\t * @return True if contained.\r\n\t */\r\n\thasVariable(x: Variable): boolean {\r\n\t\treturn this.#xs.includes(x);\r\n\t}\r\n\r\n\r\n\t// Methods for Constraints -------------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * Returns the list of constraint.\r\n\t * The returned list is not allowed to be modified.\r\n\t * @return The constraint list.\r\n\t */\r\n\tconstraints(): Constraint[] {\r\n\t\treturn this.#cs;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the number of constraints in the problem.\r\n\t * @return Number of constraints\r\n\t */\r\n\tconstraintSize(): number {\r\n\t\treturn this.#cs.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets a constraint by index.\r\n\t * @param index Index (0 <= index < constraintSize()).\r\n\t * @return A constraint.\r\n\t */\r\n\tconstraintAt(index: number): Constraint {\r\n\t\treturn this.#cs[index];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets a constraint by name.\r\n\t * @param name Name.\r\n\t * @return A constraint.\r\n\t */\r\n\tconstraintOf(name: string): Constraint | null {\r\n\t\tfor (const c of this.#cs) {\r\n\t\t\tif (c.name() === name) {\r\n\t\t\t\treturn c;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the constraint is contained or not.\r\n\t * @param c A constraint\r\n\t * @return True if contained.\r\n\t */\r\n\thasConstraint(c: Constraint): boolean {\r\n\t\treturn this.#cs.includes(c);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the constraints that exist between the specified variables.\r\n\t * Returns an empty array if no constraints exist.\r\n\t * If there are multiple constraints between two variables (including the case of n-ary constraints (2 < n)), they will be included in the return array.\r\n\t * @param v1 Variable 1\r\n\t * @param v2 Variable 2\r\n\t * @return Constraints.\r\n\t */\r\n\tconstraintsBetween(v1: Variable, v2: Variable): Constraint[] {\r\n\t\tconst cs: Constraint[] = [];\r\n\t\tfor (const c of v1) {\r\n\t\t\tif (c.has(v2)) {\r\n\t\t\t\tcs.push(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cs;\r\n\t}\r\n\r\n\r\n\t// State acquisition methods -----------------------------------------------\r\n\r\n\r\n\t/**\r\n\t * Returns whether the problem is a fuzzy constraint satisfaction problem, i.e., whether it contains fuzzy constraints.\r\n\t * @return True if it is a fuzzy constraint satisfaction problem.\r\n\t */\r\n\tisFuzzy(): boolean {\r\n\t\treturn this.#isFuzzy;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the constraint density (number of constraints/number of variables).\r\n\t * @return Constraint density.\r\n\t */\r\n\tconstraintDensity(): number {\r\n\t\treturn this.#cs.length / this.#xs.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of variables in the problem that have not been assigned a value.\r\n\t * @return Number of variables with no value assigned.\r\n\t */\r\n\temptyVariableSize(): number {\r\n\t\tlet n: number = 0;\r\n\r\n\t\tfor (const x of this.#xs) {\r\n\t\t\tn += x.isEmpty() ? 1 : 0;\r\n\t\t}\r\n\t\treturn n;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the constraint satisfaction problem has any variables with empty domain.\r\n\t * @return True if it exists.\r\n\t */\r\n\thasEmptyDomain(): boolean {\r\n\t\tfor (const x of this.#xs) {\r\n\t\t\tif (x.domain().size() === 0) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the worst satisfaction degree for the constraints contained in the fuzzy constraint satisfaction problem.\r\n\t * If the degree cannot be determined because the variable has not yet been assigned a value or for some other reason, -1 is returned.\r\n\t * @return Worst satisfaction degree.\r\n\t */\r\n\tdegree(): number {\r\n\t\tlet wd: number = 1;\r\n\t\tfor (const c of this.#cs) {\r\n\t\t\tconst d: number = c.degree();\r\n\t\t\tif (d === Constraint.UNDEFINED) {\r\n\t\t\t\treturn d;\r\n\t\t\t}\r\n\t\t\tif (d < wd) {\r\n\t\t\t\twd = d;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn wd;\r\n\t}\r\n\r\n\t/**\r\n\t * Finds the set of worst satisfiable constraints in a fuzzy constraint satisfaction problem.\r\n\t * @return Array of constraints and worst satisfaction degree.\r\n\t */\r\n\tconstraintsWithDegree(): [Constraint[], number] {\r\n\t\tconst cs: Constraint[] = [];\r\n\t\tlet cur: number = 1;\r\n\t\tfor (const c of this.#cs) {\r\n\t\t\tconst s: number = c.degree();\r\n\t\t\tif (s < cur) {\r\n\t\t\t\tcur = s;\r\n\t\t\t\tcs.length = 0;\r\n\t\t\t\tcs.push(c);\r\n\t\t\t} else if (s - cur < Number.MIN_VALUE * 10) {\r\n\t\t\t\tcs.push(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [cs, cur];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the average of satisfaction degrees of the fuzzy constraints.\r\n\t * @return Average of satisfaction degrees.\r\n\t */\r\n\taverageDegree(): number {\r\n\t\tlet s: number = 0;\r\n\t\tfor (const c of this.#cs) {\r\n\t\t\ts += c.degree();\r\n\t\t}\r\n\t\treturn s / this.#cs.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the rate of constraints that are satisfied out of all constraints.\r\n\t * @return Rate of satisfied constraints.\r\n\t */\r\n\tratio(): number {\r\n\t\treturn this.satisfiedConstraintSize() / this.#cs.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of satisfied constraints.\r\n\t * Undefined constraints are ignored.\r\n\t * @return Number of satisfied constraints.\r\n\t */\r\n\tsatisfiedConstraintSize(): number {\r\n\t\tlet n: number = 0;\r\n\t\tfor (const c of this.#cs) {\r\n\t\t\tn += (c.isSatisfied() === 1) ? 1 : 0;\r\n\t\t}\r\n\t\treturn n;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of violating constraints.\r\n\t * Undefined constraints are ignored.\r\n\t * @return Number of violating constraints.\r\n\t */\r\n\tviolatingConstraintSize(): number {\r\n\t\treturn this.#cs.length - this.satisfiedConstraintSize();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a list of satisfied constraints.\r\n\t * Undefined constraints are ignored.\r\n\t * @return Array of constraints.\r\n\t */\r\n\tsatisfiedConstraints(): Constraint[] {\r\n\t\tconst cs: Constraint[] = [];\r\n\t\tfor (const c of this.#cs) {\r\n\t\t\tif (c.isSatisfied() === 1) {\r\n\t\t\t\tcs.push(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cs;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a list of violating constraints.\r\n\t * Undefined constraints are ignored.\r\n\t * @return Array of constraints.\r\n\t */\r\n\tviolatingConstraints(): Constraint[] {\r\n\t\tconst cs: Constraint[] = [];\r\n\t\tfor (const c of this.#cs) {\r\n\t\t\tif (c.isSatisfied() !== 1) {\r\n\t\t\t\tcs.push(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cs;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Classes of utility variables.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-10-21\r\n */\r\n\r\nimport { Problem } from './problem';\r\nimport { Variable } from './variable';\r\nimport { Domain } from './domain';\r\n\r\n/**\r\n * Class that represents an observable variable.\r\n */\r\nexport class ObservableVariable extends Variable {\r\n\r\n\t#observer: ((x: Variable, v: number) => void) | null;\r\n\r\n\t// Called only from Problem.\r\n\tconstructor(owner: Problem, d: Domain, observer: (x: Variable, v: number) => void) {\r\n\t\tsuper(owner, d);\r\n\t\tthis.#observer = observer;\r\n\t}\r\n\r\n\t/**\r\n\t * Assign a value.\r\n\t * @param v Value.\r\n\t */\r\n\tassign(v: number): void {\r\n\t\tsuper.assign(v);\r\n\t\tif (this.#observer) {\r\n\t\t\tthis.#observer(this, v);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Class that represents an imaginary variable.\r\n */\r\nexport class ImaginaryVariable extends Variable {\r\n\r\n\t#orig: Variable;\r\n\r\n\tconstructor(x: Variable) {\r\n\t\tsuper(x.owner(), x.domain());\r\n\t\tthis.#orig = x;\r\n\t\tthis.setName(x.name());\r\n\t\tthis.assign(x.value());\r\n\t}\r\n\r\n\tassign(v: number): void {\r\n\t\tthis.#orig.assign(v);\r\n\t}\r\n\r\n\tdomain(): Domain;\r\n\r\n\tdomain(d: Domain): void;\r\n\r\n\tdomain(d?: Domain): Domain | void {\r\n\t\tif (d === undefined) {\r\n\t\t\treturn this.#orig.domain();\r\n\t\t} else {\r\n\t\t\tthis.#orig.domain(d);\r\n\t\t}\r\n\t}\r\n\r\n\tvalue(): number {\r\n\t\treturn this.#orig.value();\r\n\t}\r\n\r\n}\r\n", "/**\n * The class for monitoring solvers.\n *\n * @author Takuto Yanagida\n * @version 2024-12-23\n */\n\nimport { AssignmentList } from '../util/assignment-list';\n\nexport class Monitor {\n\n\t/**\n\t * Whether the debugging mode is on.\n\t */\n\t#debugMode: boolean = true;\n\n\t/**\n\t * Output function for debugging.\n\t */\n\t#debugOutput: (e: any) => void = (e: any): void => console.log(e);\n\n\t/**\n\t * Listener of the solver.\n\t */\n\t#listener: ((as: AssignmentList, wd: number) => boolean) = () => false;\n\n\t/**\n\t *  Limit number of iterations.\n\t */\n\t#iterLimit: number = Number.MAX_SAFE_INTEGER;\n\n\t/**\n\t * Time limit.\n\t */\n\t#timeLimit: number | null = null;\n\n\t/**\n\t * Target 'ratio' or 'degree'.\n\t */\n\t#target: number | null = 0.8;\n\n\t/**\n\t * Number of times the evaluation value is the same before stopping the solver.\n\t */\n\t#sameEvaluationLimit: number | null = null;\n\n\t/**\n\t * End time.\n\t */\n\t#endTime: number = 0;\n\n\t/**\n\t * Number of iterations.\n\t */\n\t#iterCount: number = 0;\n\n\t/**\n\t * Last evaluation value.\n\t */\n\t#lastEv: number = -1;\n\n\t/**\n\t * Number of times the evaluation value is the same.\n\t */\n\t#sameEvCount: number = 0;\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Initializes the monitor.\n\t */\n\tinitialize(): void {\n\t\tthis.#endTime = (null === this.#timeLimit) ? (\n\t\t\tNumber.MAX_VALUE\n\t\t) : (\n\t\t\tDate.now() + this.#timeLimit\n\t\t);\n\t\tthis.#iterCount = 0;\n\t}\n\n\t/**\n\t * Checks the current status of the solver.\n\t * @param evaluation Evaluation value.\n\t * @returns True if the solver should stop, false if the solver should stop as a failure, and null if the solver should continue.\n\t */\n\tcheck(evaluation: number | null = null): boolean | null {\n\t\tif (null !== evaluation && null !== this.#target && this.#target <= evaluation) {\n\t\t\tthis.outputDebugString('Stop: Current evaluation value is above the target');\n\t\t\treturn true;\n\t\t}\n\t\tif (this.#iterLimit < this.#iterCount++) {\n\t\t\tthis.outputDebugString('Stop: Number of iterations has reached the limit');\n\t\t\treturn false;\n\t\t}\n\t\tif (this.#endTime < Date.now()) {\n\t\t\tthis.outputDebugString('Stop: Time limit has been reached');\n\t\t\treturn false;\n\t\t}\n\t\tif (null !== evaluation && this.#sameEvaluationLimit !== null) {\n\t\t\tif (evaluation !== -1 && this.#lastEv === evaluation) {\n\t\t\t\tif (this.#sameEvCount++ > this.#sameEvaluationLimit) {\n\t\t\t\t\tthis.outputDebugString('Stop: Evaluation value has not changed for a certain number of times');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.#lastEv      = evaluation;\n\t\t\t\tthis.#sameEvCount = 0;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Called by the solver when a solution is found.\n\t * @param solution Solution.\n\t * @param evaluation Evaluation value.\n\t * @returns Whether to stop the solver.\n\t */\n\tsolutionFound(solution: AssignmentList, evaluation: number): boolean {\n\t\treturn this.#listener(solution, evaluation);\n\t}\n\n\t/**\n\t * Called by the solver to output debug strings.\n\t * @param str String to output.\n\t */\n\toutputDebugString(str: any): void {\n\t\tif (this.#debugMode) this.#debugOutput(str);\n\t}\n\n\t/**\n\t * Called by the solver to check if the debugging mode is on.\n\t * @returns Whether the debugging mode is on.\n\t */\n\tisDebugMode(): boolean {\n\t\treturn this.#debugMode;\n\t}\n\n\t/**\n\t * Called by the solver to check if the target is set.\n\t * @returns Whether the target is set.\n\t */\n\tisTargetAssigned(): boolean {\n\t\treturn null !== this.#target;\n\t}\n\n\t/**\n\t * Called by the solver to check if the target is set.\n\t * @returns Whether the target is set.\n\t */\n\tgetTarget(): number | null {\n\t\treturn this.#target;\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Sets and limits the maximum number of iterations for the solver's behavior.\n\t * After the specified number of iterations, the solver stops as a failure. The specific behavior depends on the solver.\n\t * @param count Maximum value; null means not set.\n\t */\n\tsetIterationLimit(count: number | null = null): void {\n\t\tthis.#iterLimit = (null === count) ? Number.MAX_SAFE_INTEGER : count;\n\t}\n\n\t/**\n\t * Sets a time limit on the solver's behavior.\n\t * If the specified time is exceeded, the solver stops as a failure. The specific behavior depends on the solver.\n\t * @param msec Time limit. null means not set.\n\t */\n\tsetTimeLimit(msec: number | null = null): void {\n\t\tthis.#timeLimit = msec;\n\t}\n\n\t/**\n\t * The goal to be achieved, which is the condition for stopping the solver, is set as the constraint satisfaction degree (fuzzy) or the percentage of constraints satisfied (crisp).\n\t * The solver stops as success if the specified percentage is reached or exceeded. The specific behavior depends on the solver.\n\t * @param rate Degree or rate. null indicates not set.\n\t */\n\tsetTarget(rate: number | null = null): void {\n\t\tthis.#target = rate;\n\t}\n\n\t/**\n\t * Sets the number of times the evaluation value is the same before stopping the solver.\n\t * @param count Count; null means not set.\n\t */\n\tsetSameEvaluationLimit(count: number | null = null): void {\n\t\tthis.#sameEvaluationLimit = count;\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Sets the listener of the solver.\n\t * @param l Listener function.\n\t */\n\tsetListener(l: (solution: AssignmentList, worstDegree: number) => boolean): void {\n\t\tthis.#listener = l;\n\t}\n\n\n\t// -------------------------------------------------------------------------\n\n\n\t/**\n\t * Sets whether to output debug strings.\n\t * @param boolean flag Do output if true.\n\t */\n\tsetDebugMode(flag: boolean): void {\n\t\tthis.#debugMode = flag;\n\t}\n\n\t/**\n\t * Sets a function that used for outputting debug strings.\n\t * @param function fn Function called when debug output.\n\t */\n\tsetDebugOutput(fn: (e: any) => void): void {\n\t\tthis.#debugOutput = fn;\n\t}\n\n}\n", "/**\r\n * The class for solvers for finding solutions to CSPs.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-31\r\n */\r\n\r\nimport { Problem } from '../problem/problem';\r\nimport { Monitor } from './monitor';\r\n\r\nexport class Solver {\r\n\r\n\t/**\r\n\t * The crisp/fuzzy CSP solved by the solver.\r\n\t */\r\n\tprotected pro: Problem;\r\n\r\n\t/**\r\n\t * Monitor for the solver.\r\n\t */\r\n\tprotected monitor: Monitor = new Monitor();\r\n\r\n\t/**\r\n\t * Generates a solver given a CSP.\r\n\t * @param pro A CSP.\r\n\t */\r\n\tconstructor(pro: Problem) {\r\n\t\tthis.pro = pro;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a monitor for the solver.\r\n\t * @param m Monitor.\r\n\t */\r\n\tsetMonitor(m: Monitor): void {\r\n\t\tthis.monitor = m;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the monitor for the solver.\r\n\t * @return Monitor.\r\n\t */\r\n\tgetMonitor(): Monitor {\r\n\t\treturn this.monitor;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the name of the solver.\r\n\t * @return The name.\r\n\t */\r\n\tname(): string {\r\n\t\treturn '';\r\n\t}\r\n\r\n\t/**\r\n\t * Placeholder for implementing an algorithm.\r\n\t * The solve method calls this method and returns the return value of this method.\r\n\t * @return True if the algorithm succeeds,\r\n\t */\r\n\tprotected exec(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the solution to a CSP.\r\n\t * The specific meaning of the return value depends on the implementation of the algorithm.\r\n\t * @return True if the algorithm succeeds\r\n\t */\r\n\tsolve(): boolean {\r\n\t\treturn this.exec();\r\n\t}\r\n\r\n}\r\n", "/**\r\n * This class holds the branch pruning states for a domain.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2025-01-02\r\n */\r\n\r\nimport { Variable } from '../problem/variable';\r\nimport { Domain } from '../problem/domain';\r\n\r\nexport class DomainPruner {\r\n\r\n\tstatic #UNPRUNED: number = Number.MIN_SAFE_INTEGER;\r\n\r\n\t#prunedLvs : number[];\r\n\t#prunedSize: number = 0;\r\n\r\n\t/**\r\n\t * Generates a class that holds branch pruning states for a domain.\r\n\t * @param size Size of the corresponding domain\r\n\t */\r\n\tconstructor(size: number) {\r\n\t\tthis.#prunedLvs = new Array(size);\r\n\t\tthis.#prunedLvs.fill(DomainPruner.#UNPRUNED);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the size of the erased element.\r\n\t * @return Size of the erased element.\r\n\t */\r\n\tprunedSize(): number {\r\n\t\treturn this.#prunedSize;\r\n\t}\r\n\r\n\t/**\r\n\t * Erases the element at the specified index.\r\n\t * @param index Index.\r\n\t * @param level Level.\r\n\t */\r\n\tprune(index: number, level: number): void {\r\n\t\tif (this.#prunedLvs[index] === DomainPruner.#UNPRUNED) {\r\n\t\t\t++this.#prunedSize;\r\n\t\t} else {\r\n\t\t\tthrow new Error();\r\n\t\t}\r\n\t\tthis.#prunedLvs[index] = level;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the element is empty or not.\r\n\t * Returns true if all elements have been erased.\r\n\t * @return True if empty.\r\n\t */\r\n\tisEmpty(): boolean {\r\n\t\treturn this.#prunedLvs.length === this.#prunedSize;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether or not the element at the specified index has been erased.\r\n\t * @param index Index.\r\n\t * @return True if erased.\r\n\t */\r\n\tisPruned(index: number): boolean {\r\n\t\treturn this.#prunedLvs[index] !== DomainPruner.#UNPRUNED;\r\n\t}\r\n\r\n\t/**\r\n\t * Restores the value that had been erased, by specifying a level.\r\n\t * @param level Level\r\n\t */\r\n\trecover(level: number): void {\r\n\t\tfor (let i: number = 0; i < this.#prunedLvs.length; ++i) {\r\n\t\t\tif (this.#prunedLvs[i] === level) {\r\n\t\t\t\tthis.#prunedLvs[i] = DomainPruner.#UNPRUNED;\r\n\t\t\t\t--this.#prunedSize;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Restores all erased values.\r\n\t */\r\n\trecoverAll(): void {\r\n\t\tthis.#prunedLvs.fill(DomainPruner.#UNPRUNED);\r\n\t\tthis.#prunedSize = 0;\r\n\t}\r\n\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * Assigns a domain pruner to each variable.\r\n * @param xs An array of variables.\r\n */\r\nexport function assignDomainPruner(xs: Variable[]): void {\r\n\tfor (const x of xs) {\r\n\t\tx.solverObject = new DomainPruner(x.domain().size());\r\n\t}\r\n}\r\n\r\n/**\r\n * Un-assigns a domain pruner from each variable.\r\n * @param xs An array of variables.\r\n */\r\nexport function unassignDomainPruner(xs: Variable[]): void {\r\n\tfor (const x of xs) {\r\n\t\tx.solverObject = null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Recovers all pruned values of each variable up to the specified level.\r\n * @param xs An array of variables.\r\n * @param level Level.\r\n */\r\nexport function recover(xs: Variable[], level: number): void {\r\n\tfor (const x of xs) {\r\n\t\tx.solverObject.recover(level);\r\n\t}\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * Returns the index of the variable with the minimum remaining values (MRV).\r\n * @param xs An array of variables.\r\n * @return The index of the variable with the minimum remaining values.\r\n */\r\nexport function indexOfVariableWithMRV(xs: Variable[]): number {\r\n\tlet index: number = 0;\r\n\tlet size : number = Number.MAX_VALUE;\r\n\r\n\tfor (let i: number = 0; i < xs.length; ++i) {\r\n\t\tconst x: Variable = xs[i];\r\n\t\tif (!x.isEmpty()) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tconst d: Domain = x.domain();\r\n\t\tconst s: number = d.size() - x.solverObject.prunedSize();\r\n\t\tif (s < size) {\r\n\t\t\tsize  = s;\r\n\t\t\tindex = i;\r\n\t\t}\r\n\t}\r\n\treturn index;\r\n}\r\n", "/**\r\n * The class represents a pair of variables and the values to be assigned to them.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-10-22\r\n */\r\n\r\nimport { Variable } from '../problem/variable';\r\n\r\nexport class Assignment {\r\n\r\n\t#x: Variable;\r\n\t#v: number;\r\n\r\n\tconstructor(args: { assignment: Assignment; } | { variable: Variable; value?: number|null }) {\r\n\t\tif ('assignment' in args) {\r\n\t\t\tthis.#x = args.assignment.variable();\r\n\t\t\tthis.#v = args.assignment.value();\r\n\t\t} else if ('variable' in args) {\r\n\t\t\tthis.#x = args.variable;\r\n\t\t\tthis.#v = args.value ?? args.variable.value();\r\n\t\t} else {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Assigns a value to a stored variable.\r\n\t */\r\n\tapply(): void {\r\n\t\tthis.#x.assign(this.#v);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a string representation.\r\n\t * @return A string representation.\r\n\t */\r\n\ttoString(): string {\r\n\t\treturn `v${this.#x.index()} <- ${this.#v}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the value.\r\n\t * @return Value.\r\n\t */\r\n\tvalue(): number {\r\n\t\treturn this.#v;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the variable.\r\n\t * @return Variable.\r\n\t */\r\n\tvariable(): Variable {\r\n\t\treturn this.#x;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * The class represents multiple variables and their assignments.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-10-22\r\n */\r\n\r\nimport { Assignment } from './assignment';\r\nimport { Variable } from '../problem/variable';\r\nimport { Problem } from '../problem/problem';\r\n\r\nexport class AssignmentList {\r\n\r\n\tstatic fromVariables(xs: Iterable<Variable>): AssignmentList {\r\n\t\tconst al = new AssignmentList();\r\n\t\tal.setVariables(xs);\r\n\t\treturn al;\r\n\t}\r\n\r\n\t#as: Assignment[] = [];\r\n\r\n\tconstructor() {\r\n\t}\r\n\r\n\tsetProblem(p: Problem): void {\r\n\t\tthis.#as.length = 0;\r\n\t\tfor (const x of p.variables()) {\r\n\t\t\tthis.#as.push(new Assignment({ variable: x, value: x.value() }));\r\n\t\t}\r\n\t}\r\n\r\n\tsetAssignmentList(al: AssignmentList): void {\r\n\t\tthis.#as.length = 0;\r\n\t\tfor (const a of al) {\r\n\t\t\tthis.#as.push(new Assignment({ variable: a.variable(), value: a.value() }));\r\n\t\t}\r\n\t}\r\n\r\n\tsetVariables(xs: Iterable<Variable>): void {\r\n\t\tthis.#as.length = 0;\r\n\t\tfor (const x of xs) {\r\n\t\t\tthis.#as.push(new Assignment({ variable: x, value: x.value() }));\r\n\t\t}\r\n\t}\r\n\r\n\taddVariable(variable: Variable, value: number | null = null): void {\r\n\t\tthis.#as.push(new Assignment({ variable, value }));\r\n\t}\r\n\r\n\tapply(): void {\r\n\t\tfor (const a of this.#as) a.apply();\r\n\t}\r\n\r\n\t/**\r\n\t * Remove all assignments.\r\n\t */\r\n\tclear(): void {\r\n\t\tthis.#as.length = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether the list is empty or not.\r\n\t * @return True if empty.\r\n\t */\r\n\tisEmpty(): boolean {\r\n\t\treturn this.#as.length === 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the number of assignments.\r\n\t * @return Number of assignments.\r\n\t */\r\n\tsize(): number {\r\n\t\treturn this.#as.length;\r\n\t}\r\n\r\n\tdifferenceSize(): number {\r\n\t\tlet diff: number = 0;\r\n\r\n\t\tfor (const a of this.#as) {\r\n\t\t\tif (a.variable().value() !== a.value()) {\r\n\t\t\t\t++diff;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn diff;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the assignments by specifying their indices.\r\n\t * @param index Index.\r\n\t * @return An assignment.\r\n\t */\r\n\tat(index: number): Assignment {\r\n\t\treturn this.#as[index];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the iterator of the assignments.\r\n\t */\r\n\t[Symbol.iterator](): Iterator<Assignment> {\r\n\t\treturn this.#as[Symbol.iterator]();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets an arbitrary assignment.\r\n\t *\r\n\t * @return An assignment.\r\n\t */\r\n\trandom(): Assignment {\r\n\t\treturn this.#as[Math.floor(Math.random() * this.#as.length)];\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Relations.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { CrispRelation, FuzzyRelation } from './relation';\r\nimport { Domain } from './domain';\r\n\r\n/**\r\n * Crisp relations defined by functions.\r\n */\r\nexport class CrispRelationFunction extends CrispRelation {\r\n\r\n\t#fn: (...vs: number[]) => -1 | 0 | 1;\r\n\r\n\tconstructor(fn: (...vs: number[]) => -1 | 0 | 1) {\r\n\t\tsuper();\r\n\t\tthis.#fn = fn;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets whether or not the relation is satisfied in this crisp relation.\r\n\t * @param vs Values of each variable\r\n\t * @return Whether or not it is satisfied.\r\n\t */\r\n\tisSatisfied(...vs: number[]): -1 | 0 | 1 {\r\n\t\treturn this.#fn(...vs);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Fuzzy relations defined by functions.\r\n */\r\nexport class FuzzyRelationFunction extends FuzzyRelation {\r\n\r\n\t#fn: (...vs: number[]) => number;\r\n\r\n\tconstructor(fn: (...vs: number[]) => number) {\r\n\t\tsuper();\r\n\t\tthis.#fn = fn;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the satisfaction degree in this fuzzy relation.\r\n\t * @param vs Values of each variable\r\n\t * @return A satisfaction degree d (0 <= d <= 1).\r\n\t */\r\n\tdegree(...vs: number[]): number {\r\n\t\treturn this.#fn(...vs);\r\n\t}\r\n\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * Crisp relations defined by tables.\r\n */\r\nexport class CrispTabledRelation extends CrispRelation {\r\n\r\n\t#es: (0 | 1)[];\r\n\t#ds: Domain[];\r\n\t#ms: number[];\r\n\r\n\tconstructor(elms: (0 | 1)[], doms: Domain[]) {\r\n\t\tsuper();\r\n\t\tthis.#es = [...elms];\r\n\t\tthis.#ds = [...doms];\r\n\t\tthis.#ms = new Array(doms.length);\r\n\r\n\t\tlet m: number = 1;\r\n\t\tfor (let i: number = this.#ms.length - 1; i >= 0; --i) {\r\n\t\t\tthis.#ms[i] = m;\r\n\t\t\tm *= this.#ds[i].size();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets whether or not the relation is satisfied in this crisp relation.\r\n\t * @param vs Values of each variable\r\n\t * @return Whether or not it is satisfied.\r\n\t */\r\n\tisSatisfied(...vs: number[]): -1 | 0 | 1 {\r\n\t\tif (this.#ms.length !== vs.length) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\t\tlet index: number = 0;\r\n\t\tfor (let i: number = 0; i < this.#ms.length; ++i) {\r\n\t\t\tindex += this.#ms[i] * this.#ds[i].indexOf(vs[i]);\r\n\t\t}\r\n\t\treturn this.#es[index];\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Fuzzy relations defined by tables.\r\n */\r\nexport class FuzzyTabledRelation extends FuzzyRelation {\r\n\r\n\t#es: number[];\r\n\t#ds: Domain[];\r\n\t#ms: number[];\r\n\r\n\tconstructor(elms: number[], doms: Domain[]) {\r\n\t\tsuper();\r\n\t\tthis.#es = [...elms];\r\n\t\tthis.#ds = [...doms];\r\n\t\tthis.#ms = new Array(doms.length);\r\n\r\n\t\tlet m: number = 1;\r\n\t\tfor (let i: number = this.#ms.length - 1; i >= 0; --i) {\r\n\t\t\tthis.#ms[i] = m;\r\n\t\t\tm *= this.#ds[i].size();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the satisfaction degree in this fuzzy relation.\r\n\t * @param vs Values of each variable\r\n\t * @return A satisfaction degree d (0 <= d <= 1).\r\n\t */\r\n\tdegree(...vs: number[]): number {\r\n\t\tif (this.#ms.length !== vs.length) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\t\tlet index: number = 0;\r\n\t\tfor (let i: number = 0; i < this.#ms.length; ++i) {\r\n\t\t\tindex += this.#ms[i] * this.#ds[i].indexOf(vs[i]);\r\n\t\t}\r\n\t\treturn this.#es[index];\r\n\t}\r\n\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\nexport class CrispFuzzyRelation extends CrispRelation {\r\n\r\n\t#th: number;\r\n\t#fr: FuzzyRelation;\r\n\r\n\tconstructor(fr: FuzzyRelation, th: number) {\r\n\t\tsuper();\r\n\t\tthis.#fr = fr;\r\n\t\tthis.#th = th;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets whether or not the relation is satisfied in this crisp relation.\r\n\t * @param vs Values of each variable\r\n\t * @return Whether or not it is satisfied.\r\n\t */\r\n\tisSatisfied(...vs: number[]): -1 | 0 | 1 {\r\n\t\tconst d: number = this.#fr.degree(...vs);\r\n\t\treturn (0 < d && d < this.#th) ? 0 : d as -1 | 0 | 1;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Utility class for constraint satisfaction problems.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-29\r\n */\r\n\r\nimport { Problem } from '../problem/problem';\r\nimport { Variable } from '../problem/variable';\r\nimport { ImaginaryVariable } from '../problem/variables';\r\nimport { Constraint } from '../problem/constraint';\r\nimport { Domain } from '../problem/domain';\r\nimport { FuzzyRelation, Relation } from '../problem/relation';\r\nimport { CrispFuzzyRelation } from '../problem/relations';\r\n\r\n/**\r\n * Create a table that caches constraints between two variables.\r\n * @param pro A problem.\r\n * @param xs  An array of variables.\r\n * @return A table that caches constraints between two variables.\r\n */\r\nexport function createRelatedConstraintTable(pro: Problem, xs: Variable[]): Constraint[][][] {\r\n\tconst rct: Constraint[][][] = [];\r\n\r\n\tfor (let j: number = 0; j < xs.length; ++j) {\r\n\t\trct.push(new Array(xs.length));\r\n\r\n\t\tfor (let i: number = 0; i < xs.length; ++i) {\r\n\t\t\tif (i < j) {\r\n\t\t\t\trct[j][i] = pro.constraintsBetween(xs[i], xs[j]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn rct;\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * Calculates the average path length.\r\n * @param p A problem.\r\n * @return Average path length.\r\n */\r\nexport function averagePathLengths(p: Problem): number[] {\r\n\tconst ls = new Array(p.variableSize());\r\n\tfor (const x of p.variables()) {\r\n\t\tls[x.index()] = averagePathLength(p, x);\r\n\t}\r\n\treturn ls;\r\n}\r\n\r\n/**\r\n * Calculates the average path length for a given variable.\r\n * @param p A problem.\r\n * @param x A variable of the problem.\r\n * @return Average path length.\r\n */\r\nexport function averagePathLength(p: Problem, x: Variable): number {\r\n\tconst ls = new Array(p.variableSize());\r\n\tls.fill(Number.MAX_VALUE);\r\n\r\n\tconst xs = new Set<Variable>();\r\n\txs.add(x);\r\n\r\n\tls[x.index()] = 0;\r\n\tgetPathLength(p, x, ls, 0, xs);\r\n\r\n\tlet connectedSize: number = 0;\r\n\tlet sum: number = 0;\r\n\r\n\tfor (let i: number = 0; i < ls.length; ++i) {\r\n\t\tif (ls[i] !== Number.MAX_VALUE && i !== x.index()) {\r\n\t\t\t++connectedSize;\r\n\t\t\tsum += ls[i];\r\n\t\t}\r\n\t}\r\n\tif (connectedSize === 0) {\r\n\t\treturn 0;\r\n\t}\r\n\treturn sum / connectedSize;\r\n}\r\n\r\nfunction getPathLength(p: Problem, x: Variable, length: number[], baseLength: number, xo: Set<Variable>): void {\r\n\tconst xn: Variable[] = [];\r\n\r\n\tfor (const c of x) {\r\n\t\tfor (const xi of c) {\r\n\t\t\tif (length[xi.index()] === Number.MAX_VALUE) {\r\n\t\t\t\txn.push(xi);\r\n\t\t\t\tlength[xi.index()] = baseLength + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (const xi of xn) {\r\n\t\txo.add(xi);\r\n\t}\r\n\tfor (const xi of xn) {\r\n\t\tgetPathLength(p, xi, length, baseLength + 1, xo);\r\n\t}\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * Gets an array containing all domains.\r\n * @param p A problem.\r\n * @return Array of domains.\r\n */\r\nexport function domains(p: Problem): Domain[] {\r\n\tconst ds: Domain[] = [];\r\n\tfor (const x of p.variables()) {\r\n\t\tds.push(x.domain());\r\n\t}\r\n\treturn ds;\r\n}\r\n\r\n/**\r\n * Set up all domains.\r\n * @param p A problem.\r\n * @param ds Array of domains.\r\n */\r\nexport function setDomains(p: Problem, ds: Domain[]): void {\r\n\tfor (let i: number = 0; i < ds.length; ++i) {\r\n\t\tp.variableAt(i).domain(ds[i]);\r\n\t}\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * Returns the array of possible satisfaction degree values for all unary constraints.\r\n * @param p A problem.\r\n * @param degrees Array of degree values.\r\n * @return The array.\r\n */\r\nexport function possibleDegreesOfUnaryConstraints(p: Problem, degrees: number[]): number[] {\r\n\tfor (const c of p.constraints()) {\r\n\t\tif (c.size() !== 1) continue;\r\n\t\tconst x: Variable = c.at(0) as Variable;\r\n\t\tconst origV: number = x.value();  // Save the value.\r\n\r\n\t\tfor (const v of x.domain()) {\r\n\t\t\tx.assign(v);\r\n\t\t\tdegrees.push(c.degree());\r\n\t\t}\r\n\t\tx.assign(origV);  // Restore the value.\r\n\t}\r\n\treturn degrees;\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * Returns a view of the fuzzy constraint satisfaction problem as a crisp constraint satisfaction problem.\r\n * The relations and domains of the specified fuzzy constraint satisfaction problem are reused, but the other elements are newly generated.\r\n * Note: Assignments to variables and changes to domains of the view are reflected in the variables of the original problem.\r\n * @param p A fuzzy constraint satisfaction problem.\r\n * @param threshold The threshold of constraint satisfaction degree. A constraint is considered satisfied when the constraint satisfaction degree is greater than or equal to this value.\r\n * @return A crisp constraint satisfaction problem.\r\n */\r\nexport function toViewAsCrispProblem(p: Problem, threshold: number): CrispFuzzyProblem {\r\n\tconst cp = new CrispFuzzyProblem();\r\n\r\n\tfor (const x of p.variables()) {\r\n\t\tcp.createVariable({ variable: x });\r\n\t}\r\n\tfor (const c of p.constraints()) {\r\n\t\tconst xs: Variable[] = [];\r\n\r\n\t\tfor (const x of c) {\r\n\t\t\txs.push(cp.variableAt(x.index()));\r\n\t\t}\r\n\t\tlet r: Relation = c.relation();\r\n\t\tif (c.isFuzzy()) {\r\n\t\t\tr = new CrispFuzzyRelation(r as FuzzyRelation, threshold);\r\n\t\t}\r\n\t\tcp.createConstraint({ relation: r, variables: xs });\r\n\t}\r\n\treturn cp;\r\n}\r\n\r\nclass CrispFuzzyProblem extends Problem {\r\n\r\n\tcreateVariable(args: { variable: Variable; }): Variable {\r\n\t\tconst iv = new ImaginaryVariable(args.variable);\r\n\t\tthis.addVariable(iv);\r\n\t\treturn iv;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * This class that implements the forward checking method.\r\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\r\n * Searches for variable assignments that satisfy all constraints and fails if none are found.\r\n * Each variable must have its own domain because it hides domain elements as branch pruning.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2025-01-02\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { Domain } from '../../problem/domain';\r\nimport { DomainPruner, assignDomainPruner, unassignDomainPruner, recover, indexOfVariableWithMRV } from '../../util/domain-pruner';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { createRelatedConstraintTable } from '../../util/problems';\r\nimport { Solver } from '../solver';\r\n\r\nexport class ForwardChecking extends Solver {\r\n\r\n\t#xs : Variable[];\r\n\t#rct: Constraint[][][] = [];  // Table to cache constraints between two variables.\r\n\t#sol: AssignmentList   = new AssignmentList();\r\n\r\n\t#useMRV: boolean = true;\r\n\r\n\t/**\r\n\t * Generates a solver given a constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\r\n\t\tthis.#xs  = [...this.pro.variables()];\r\n\t\tthis.#rct = createRelatedConstraintTable(this.pro, this.#xs);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Forward Checking';\r\n\t}\r\n\r\n\t/**\r\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\r\n\t * Use of MRV may increase processing time for some problems.\r\n\t * Default is false.\r\n\t * @param flag Use MRV if true.\r\n\t */\r\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\r\n\t\tthis.#useMRV = flag;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tthis.monitor.initialize();\r\n\t\tassignDomainPruner(this.#xs);\r\n\r\n\t\tthis.pro.clearAllVariables();\r\n\t\tconst ret: boolean | null = this.#branch(0);\r\n\t\tthis.#sol.apply();\r\n\r\n\t\tunassignDomainPruner(this.#xs);\r\n\t\treturn ret === true;\r\n\t}\r\n\r\n\t#branch(level: number): boolean | null {\r\n\t\tif (level === this.pro.variableSize()) {\r\n\t\t\tconst ev: number = this.pro.ratio();\r\n\t\t\tthis.#sol.setProblem(this.pro);\r\n\t\t\tthis.monitor.outputDebugString('\\t' + `Evaluation ${ev}`);\r\n\r\n\t\t\tthis.monitor.solutionFound(this.#sol, ev);\r\n\t\t\treturn true;  // Success.\r\n\t\t}\r\n\t\tlet ret: boolean | null = null;\r\n\t\tif (null !== (ret = this.monitor.check())) {\r\n\t\t\treturn ret;  // Success or failure.\r\n\t\t}\r\n\r\n\t\tconst x : Variable     = this.#xs[this.#useMRV ? indexOfVariableWithMRV(this.#xs) : level];\r\n\t\tconst d : Domain       = x.domain();\r\n\t\tconst dp: DomainPruner = x.solverObject;\r\n\r\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\r\n\t\t\tif (dp.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx.assign(d.at(i));\r\n\r\n\t\t\tconst vc: number = this.#getViolationCountAround(x);\r\n\t\t\tif (vc) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (this.#checkForward(level, x)) {\r\n\t\t\t\tret = this.#branch(level + 1);\r\n\t\t\t\tif (null !== ret) {  // Success or failure.\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trecover(this.#xs, level);\r\n\t\t}\r\n\t\tif (ret === null) {  // When searching back to the parent, undo the branch pruning here.\r\n\t\t\trecover(this.#xs, level);\r\n\t\t\tx.clear();\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t// Checks for possible assignment to a future variable from the current variable assignment.\r\n\t#checkForward(level: number, x: Variable): boolean {\r\n\t\tfor (const x_i of this.#xs) {\r\n\t\t\tif (!x_i.isEmpty()) {\r\n\t\t\t\tcontinue;  // If it is a past or present variable.\r\n\t\t\t}\r\n\t\t\tconst cs  : Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\r\n\t\t\tconst dp_i: DomainPruner = x_i.solverObject;\r\n\t\t\tconst d_i : Domain       = x_i.domain();\r\n\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tif (c.emptyVariableSize() !== 1) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, d_i, dp_i, c)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\r\n\t#getConstraintsBetween(i: number, j: number): Constraint[] {\r\n\t\treturn (i < j) ? this.#rct[j][i] : this.#rct[i][j];\r\n\t}\r\n\r\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\r\n\t#checkForwardConsistency(level: number, x: Variable, d: Domain, dp: DomainPruner, c: Constraint): boolean {\r\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\r\n\t\t\tif (dp.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx.assign(d.at(i));\r\n\r\n\t\t\tif (c.isSatisfied() === 0) {  // Do hide when in violation (not even UNDEFINED).\r\n\t\t\t\tdp.prune(i, level);\r\n\t\t\t}\r\n\t\t}\r\n\t\tx.clear();\r\n\t\treturn !dp.isEmpty();  // Failure if the domain of one of the future variables is empty.\r\n\t}\r\n\r\n\t// Find the number of constraint violations that have increased due to the current value of the variable x.\r\n\t#getViolationCountAround(x: Variable): number {\r\n\t\tlet vc: number = 0;\r\n\r\n\t\tfor (const c of x) {\r\n\t\t\tif (c.isSatisfied() === 0) {  // Neither satisfied nor UNDEFINED.\r\n\t\t\t\t++vc;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn vc;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * This class that implements the forward checking method.\r\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\r\n * Find the solution to the problem as the maximum CSP.\r\n * Each variable must have its own domain because it hides domain elements as branch pruning.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2025-01-02\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { Domain } from '../../problem/domain';\r\nimport { DomainPruner, assignDomainPruner, unassignDomainPruner, recover, indexOfVariableWithMRV } from '../../util/domain-pruner';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { createRelatedConstraintTable } from '../../util/problems';\r\nimport { Solver } from '../solver';\r\n\r\nexport class MaxForwardChecking extends Solver {\r\n\r\n\t#xs : Variable[];\r\n\t#rct: Constraint[][][] = [];  // Table to cache constraints between two variables.\r\n\t#sol: AssignmentList   = new AssignmentList();\r\n\r\n\t#useMRV: boolean = true;\r\n\r\n\t#maxVc: number = 0;\r\n\r\n\t/**\r\n\t * Generates a solver given a constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\r\n\t\tthis.#xs  = [...this.pro.variables()];\r\n\t\tthis.#rct = createRelatedConstraintTable(this.pro, this.#xs);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Forward Checking for Max CSPs';\r\n\t}\r\n\r\n\t/**\r\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\r\n\t * Use of MRV may increase processing time for some problems.\r\n\t * Default is false.\r\n\t * @param flag Use MRV if true.\r\n\t */\r\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\r\n\t\tthis.#useMRV = flag;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tthis.monitor.initialize();\r\n\t\tthis.#maxVc = this.pro.constraintSize();\r\n\t\tassignDomainPruner(this.#xs);\r\n\r\n\t\tthis.pro.clearAllVariables();\r\n\t\tconst ret: boolean | null = this.#branch(0);\r\n\t\tthis.#sol.apply();\r\n\r\n\t\tunassignDomainPruner(this.#xs);\r\n\t\treturn ret === true;\r\n\t}\r\n\r\n\t#branch(level: number, curVc: number = 0): boolean | null {\r\n\t\tif (level === this.pro.variableSize()) {\r\n\t\t\tconst ev: number = this.pro.ratio();\r\n\t\t\tthis.#sol.setProblem(this.pro);\r\n\t\t\tthis.monitor.outputDebugString('\\t' + `Evaluation ${ev}`);\r\n\r\n\t\t\tif (curVc < this.#maxVc) {\r\n\t\t\t\tthis.#maxVc = curVc;\r\n\r\n\t\t\t\tif (this.monitor.solutionFound(this.#sol, ev)) {\r\n\t\t\t\t\treturn true;  // Success.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this.monitor.check(ev);\r\n\t\t}\r\n\t\tlet ret: boolean | null = null;\r\n\t\tif (null !== (ret = this.monitor.check())) {\r\n\t\t\treturn ret;  // Success or failure.\r\n\t\t}\r\n\r\n\t\tconst x : Variable     = this.#xs[this.#useMRV ? indexOfVariableWithMRV(this.#xs) : level];\r\n\t\tconst d : Domain       = x.domain();\r\n\t\tconst dp: DomainPruner = x.solverObject;\r\n\r\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\r\n\t\t\tif (dp.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx.assign(d.at(i));\r\n\r\n\t\t\tconst vc: number = curVc + this.#getViolationCountAround(x);\r\n\t\t\tif (this.#maxVc <= vc) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (curVc + 1 < this.#maxVc || this.#checkForward(level, x)) {\r\n\t\t\t\tret = this.#branch(level + 1, vc);\r\n\t\t\t\tif (null !== ret) {  // Success or failure.\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trecover(this.#xs, level);\r\n\t\t}\r\n\t\tif (ret === null) {  // When searching back to the parent, undo the branch pruning here.\r\n\t\t\trecover(this.#xs, level);\r\n\t\t\tx.clear();\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t// Checks for possible assignment to a future variable from the current variable assignment.\r\n\t#checkForward(level: number, x: Variable): boolean {\r\n\t\tfor (const x_i of this.#xs) {\r\n\t\t\tif (!x_i.isEmpty()) {\r\n\t\t\t\tcontinue;  // If it is a past or present variable.\r\n\t\t\t}\r\n\t\t\tconst cs  : Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\r\n\t\t\tconst dp_i: DomainPruner = x_i.solverObject;\r\n\t\t\tconst d_i : Domain       = x_i.domain();\r\n\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tif (c.emptyVariableSize() !== 1) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, d_i, dp_i, c)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\r\n\t#getConstraintsBetween(i: number, j: number): Constraint[] {\r\n\t\treturn (i < j) ? this.#rct[j][i] : this.#rct[i][j];\r\n\t}\r\n\r\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\r\n\t#checkForwardConsistency(level: number, x: Variable, d: Domain, dp: DomainPruner, c: Constraint): boolean {\r\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\r\n\t\t\tif (dp.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx.assign(d.at(i));\r\n\r\n\t\t\tif (c.isSatisfied() === 0) {  // Do hide when in violation (not even UNDEFINED).\r\n\t\t\t\tdp.prune(i, level);\r\n\t\t\t}\r\n\t\t}\r\n\t\tx.clear();\r\n\t\treturn !dp.isEmpty();  // Failure if the domain of one of the future variables is empty.\r\n\t}\r\n\r\n\t// Find the number of constraint violations that have increased due to the current value of the variable x.\r\n\t#getViolationCountAround(x: Variable): number {\r\n\t\tlet vc: number = 0;\r\n\r\n\t\tfor (const c of x) {\r\n\t\t\tif (c.isSatisfied() === 0) {  // Neither satisfied nor UNDEFINED.\r\n\t\t\t\t++vc;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn vc;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Class implements the local changes method.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-31\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class LocalChanges extends Solver {\r\n\r\n\t#globalReturn: boolean = false;\r\n\r\n\tconstructor(p: Problem, unassignAll: boolean = false) {\r\n\t\tsuper(p);\r\n\t\tif (unassignAll) {\r\n\t\t\tthis.pro.clearAllVariables();\r\n\t\t}\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Local Changes';\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tif (this.pro.emptyVariableSize() === 0) {\r\n\t\t\tthis.pro.clearAllVariables();\r\n\t\t}\r\n\t\tthis.#globalReturn = false;\r\n\r\n\t\tconst notFixed   = new Set<Variable>();\r\n\t\tconst unassigned = new Set<Variable>();\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\t(!x.isEmpty() ? notFixed : unassigned).add(x);\r\n\t\t}\r\n\r\n\t\tthis.monitor.initialize();\r\n\r\n\t\tconst sol: AssignmentList = new AssignmentList();\r\n\t\tconst ret: boolean        = this.#lcVariables(new Set(), notFixed, unassigned);\r\n\r\n\t\tconst ev: number = this.pro.ratio();\r\n\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\r\n\r\n\t\tif (ret) {\r\n\t\t\tsol.setProblem(this.pro);\r\n\r\n\t\t\tif (this.monitor.solutionFound(sol, ev)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n}\r\n\r\n\t#lcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>): boolean {\r\n\t\t{\r\n\t\t\tthis.monitor.outputDebugString(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\r\n\r\n\t\t\tconst r: boolean | null = this.monitor.check(this.pro.degree());\r\n\t\t\tif (r !== null) {\r\n\t\t\t\tthis.#globalReturn = true;\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\t\t\tif (X3.size === 0) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tconst x = X3.values().next().value as Variable;\r\n\t\t\tconst ret: boolean = this.#lcVariable(X1, X2, x, cloneDomain(x));\r\n\r\n\t\t\tif (!ret || this.#globalReturn) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t\tX2 = cloneAndAdd(X2, x);\r\n\t\t\tX3 = cloneAndDelete(X3, x);\r\n\t\t\treturn this.#lcVariables(X1, X2, X3);\r\n\t\t}\r\n\t}\r\n\r\n\t#lcVariable(X1: Set<Variable>, X2: Set<Variable>, x: Variable, d: Set<number>): boolean {\r\n\t\tif (d.size) {\r\n\t\t\tconst v = d.values().next().value as number;\r\n\t\t\tconst al: AssignmentList = AssignmentList.fromVariables(X2);\r\n\t\t\tx.assign(v);\r\n\r\n\t\t\tconst ret: boolean = this.#lcValue(X1, X2, x, v);\r\n\t\t\tif (ret || this.#globalReturn) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t\tx.clear();\r\n\t\t\tal.apply();\r\n\t\t\treturn this.#lcVariable(X1, X2, x, cloneAndDelete(d, v));\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t#lcValue(X1: Set<Variable>, X2: Set<Variable>, x: Variable, v: number): boolean {\r\n\t\tif (!this.#isConsistent(X1, x, v)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tconst X12: Set<Variable> = X1.union(X2);\r\n\t\tif (this.#isConsistent(X12, x, v)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tconst X3: Set<Variable> = this.#createX3(X12, x, v);\r\n\t\tX1 = cloneAndAdd(X1, x);\r\n\t\tX2 = X2.difference(X3);\r\n\t\treturn this.#lcVariables(X1, X2, X3);\r\n\t}\r\n\r\n\t#isConsistent(A: Set<Variable>, x: Variable, v: number): boolean {\r\n\t\tconst cs = new Set<Constraint>();\r\n\r\n\t\tfor (const xa of A) {\r\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xa);\r\n\t\t\tfor (const c of temp) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst origV: number = x.value();  // Save the value.\r\n\t\tx.assign(v);\r\n\r\n\t\tfor (const c of cs) {\r\n\t\t\tif (c.isSatisfied() !== 1) {\r\n\t\t\t\tx.assign(origV);  // Restore the value.\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tx.assign(origV);  // Restore the value.\r\n\t\treturn true;\r\n\t}\r\n\r\n\t#createX3(X12: Set<Variable>, x: Variable, v: number): Set<Variable> {\r\n\t\tconst newX3 = new Set<Variable>();\r\n\t\tconst cs    = new Set<Constraint>();\r\n\r\n\t\tfor (const xa of X12) {\r\n\t\t\tfor (const c of this.pro.constraintsBetween(x, xa)) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst origV: number = x.value();  // Save the value.\r\n\t\tx.assign(v);\r\n\r\n\t\tfor (const c of cs) {\r\n\t\t\tif (c.isSatisfied() !== 1) {\r\n\t\t\t\tfor (const xi of c) {\r\n\t\t\t\t\tnewX3.add(xi);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tx.assign(origV);  // Restore the value.\r\n\t\tnewX3.delete(x);\r\n\t\treturn newX3;\r\n\t}\r\n\r\n}\r\n\r\nfunction cloneAndAdd<T>(s: Set<T>, e: T): Set<T> {\r\n\treturn new Set<T>(s).add(e);\r\n}\r\n\r\nfunction cloneAndDelete<T>(s: Set<T>, e: T): Set<T> {\r\n\tconst sn = new Set<T>(s);\r\n\tsn.delete(e);\r\n\treturn sn;\r\n}\r\n\r\nfunction cloneDomain(x: Variable): Set<number> {\r\n\treturn new Set<number>(x.domain());\r\n}\r\n", "/**\r\n * Class implements the local changes method.\r\n * The implementation is optimized by converting recursive calls to loops.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-23\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class LocalChangesEx extends Solver {\r\n\r\n\t#globalReturn: boolean = false;\r\n\r\n\tconstructor(p: Problem, unassignAll: boolean = false) {\r\n\t\tsuper(p);\r\n\t\tif (unassignAll) {\r\n\t\t\tthis.pro.clearAllVariables();\r\n\t\t}\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Local Changes Ex';\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tif (this.pro.emptyVariableSize() === 0) {\r\n\t\t\tthis.pro.clearAllVariables();\r\n\t\t}\r\n\t\tthis.#globalReturn = false;\r\n\r\n\t\tconst notFixed   = new Set<Variable>();\r\n\t\tconst unassigned = new Set<Variable>();\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\t(!x.isEmpty() ? notFixed : unassigned).add(x);\r\n\t\t}\r\n\r\n\t\tthis.monitor.initialize();\r\n\r\n\t\tconst sol: AssignmentList = new AssignmentList();\r\n\t\tconst ret: boolean        = this.#lcVariables(new Set(), notFixed, unassigned);\r\n\r\n\t\tconst ev: number = this.pro.ratio();\r\n\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\r\n\r\n\t\tif (ret) {\r\n\t\t\tsol.setProblem(this.pro);\r\n\r\n\t\t\tif (this.monitor.solutionFound(sol, ev)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#lcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>): boolean {\r\n\t\tX2 = new Set(X2);  // Clone\r\n\t\tX3 = new Set(X3);  // Clone\r\n\r\n\t\twhile (true) {\r\n\t\t\tthis.monitor.outputDebugString(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\r\n\r\n\t\t\tconst r: boolean | null = this.monitor.check(this.pro.degree());\r\n\t\t\tif (r !== null) {\r\n\t\t\t\tthis.#globalReturn = true;\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\t\t\tif (X3.size === 0) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tconst x = X3.values().next().value as Variable;\r\n\t\t\tconst ret: boolean = this.#lcVariable(X1, X2, x);\r\n\r\n\t\t\tif (!ret || this.#globalReturn) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t\tX2.add(x);\r\n\t\t\tX3.delete(x);\r\n\t\t}\r\n\t}\r\n\r\n\t#lcVariable(X1: Set<Variable>, X2: Set<Variable>, x: Variable): boolean {\r\n\t\tfor (const v of x.domain()) {\r\n\t\t\tconst al: AssignmentList = AssignmentList.fromVariables(X2);\r\n\t\t\tx.assign(v);\r\n\r\n\t\t\tconst ret: boolean = this.#lcValue(X1, X2, x);\r\n\t\t\tif (ret || this.#globalReturn) {\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t\tx.clear();\r\n\t\t\tal.apply();\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t#lcValue(X1: Set<Variable>, X2: Set<Variable>, x: Variable): boolean {\r\n\t\tif (!this.#isConsistent(X1, x, x.value())) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tconst X12: Set<Variable> = X1.union(X2);\r\n\t\tif (this.#isConsistent(X12, x, x.value())) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tconst X3: Set<Variable> = this.#createX3(X12, x, x.value());\r\n\r\n\t\tX1 = cloneAndAdd(X1, x);\r\n\t\tX2 = X2.difference(X3);\r\n\t\treturn this.#lcVariables(X1, X2, X3);\r\n\t}\r\n\r\n\t#isConsistent(A: Set<Variable>, x: Variable, v: number): boolean {\r\n\t\tconst cs = new Set<Constraint>();\r\n\r\n\t\tfor (const xa of A) {\r\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xa);\r\n\t\t\tfor (const c of temp) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst origV: number = x.value();  // Save the value.\r\n\t\tx.assign(v);\r\n\r\n\t\tfor (const c of cs) {\r\n\t\t\tif (c.isSatisfied() !== 1) {\r\n\t\t\t\tx.assign(origV);  // Restore the value.\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tx.assign(origV);  // Restore the value.\r\n\t\treturn true;\r\n\t}\r\n\r\n\t#createX3(X12: Set<Variable>, x: Variable, v: number): Set<Variable> {\r\n\t\tconst newX3 = new Set<Variable>();\r\n\t\tconst cs    = new Set<Constraint>();\r\n\r\n\t\tfor (const xa of X12) {\r\n\t\t\tfor (const c of this.pro.constraintsBetween(x, xa)) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst origV: number = x.value();  // Save the value.\r\n\t\tx.assign(v);\r\n\r\n\t\tfor (const c of cs) {\r\n\t\t\tif (c.isSatisfied() !== 1) {\r\n\t\t\t\tfor (const xi of c) {\r\n\t\t\t\t\tnewX3.add(xi);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tx.assign(origV);  // Restore the value.\r\n\t\tnewX3.delete(x);\r\n\t\treturn newX3;\r\n\t}\r\n\r\n}\r\n\r\nfunction cloneAndAdd<T>(s: Set<T>, e: T): Set<T> {\r\n\treturn new Set<T>(s).add(e);\r\n}\r\n", "/**\r\n * Class implements a solver using the breakout method.\r\n * Solves a problem as a maximum CSP.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-22\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { Assignment } from '../../util/assignment';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class Breakout extends Solver {\r\n\r\n\t#isRandom: boolean = true;\r\n\t#ws      : number[];\r\n\r\n\t/**\r\n\t * Generates a solver given a constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\r\n\t\tthis.#ws = new Array(this.pro.constraintSize());\r\n\t\tthis.#ws.fill(1);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Breakout';\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the randomness of the algorithm.\r\n\t * Enabling randomness reduces the risk of local solutions, but makes the solution unrepeatable.\r\n\t * @param flag Whether the randomness is enabled.\r\n\t */\r\n\tsetRandomness(flag: boolean): void {\r\n\t\tthis.#isRandom = flag;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\tif (x.isEmpty()) {\r\n\t\t\t\tx.assign(x.domain().at(0));\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst defEv: number         = this.pro.ratio();\r\n\t\tconst sol  : AssignmentList = new AssignmentList();\r\n\t\tlet solEv  : number         = defEv;\r\n\r\n\t\tthis.monitor.initialize();\r\n\r\n\t\tconst canList = new AssignmentList();\r\n\t\tlet ret: boolean | null = null;\r\n\r\n\t\twhile (true) {\r\n\t\t\tconst cs: Constraint[] = this.pro.violatingConstraints();\r\n\t\t\tconst ev: number = this.pro.ratio();\r\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\r\n\r\n\t\t\tif (solEv < ev) {\r\n\t\t\t\tsol.setProblem(this.pro);\r\n\t\t\t\tsolEv = ev;\r\n\r\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tthis.#next(cs, canList);\r\n\t\t}\r\n\r\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\r\n\t\t\tsol.apply();\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#next(cs: Constraint[], canList: AssignmentList) {\r\n\t\tthis.#findCandidates(this.#listTargetVariables(cs), canList);\r\n\r\n\t\tif (0 < canList.size()) {\r\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\r\n\t\t\ta.apply();\r\n\t\t\tcanList.clear();\r\n\t\t\tthis.monitor.outputDebugString('\\t' + a);\r\n\t\t} else {\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tthis.#ws[c.index()] += 1;\r\n\t\t\t}\r\n\t\t\tthis.monitor.outputDebugString('Breakout');\r\n\t\t}\r\n\t}\r\n\r\n\t#findCandidates(tarXs: Variable[], canList: AssignmentList): void {\r\n\t\tlet maxDiff: number = 0;\r\n\r\n\t\tfor (const x of tarXs) {\r\n\t\t\tconst x_v: number = x.value();  // Save the value\r\n\r\n\t\t\tlet nowEv: number = 0;\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tnowEv += (1 - c.isSatisfied()) * this.#ws[c.index()];\r\n\t\t\t}\r\n\t\t\tout: for (const v of x.domain()) {\r\n\t\t\t\tif (x_v === v) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tx.assign(v);\r\n\t\t\t\tlet diff: number = nowEv;\r\n\r\n\t\t\t\tfor (const c of x) {\r\n\t\t\t\t\tdiff -= (1 - c.isSatisfied()) * this.#ws[c.index()];\r\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\r\n\t\t\t\t\tif (diff < maxDiff) {\r\n\t\t\t\t\t\tcontinue out;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (maxDiff < diff) {  // An assignment that are better than ever before is found.\r\n\t\t\t\t\tmaxDiff = diff;\r\n\t\t\t\t\tcanList.clear();\r\n\t\t\t\t\tcanList.addVariable(x, v);\r\n\t\t\t\t} else if (maxDiff !== 0) {  // An assignments that can be improved to the same level as before is found.\r\n\t\t\t\t\tcanList.addVariable(x, v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tx.assign(x_v);  // Restore the value.\r\n\t\t}\r\n\t}\r\n\r\n\t#listTargetVariables(tarCs: Constraint[]): Variable[] {\r\n\t\tconst xs = new Set<Variable>();\r\n\r\n\t\tfor (const c of tarCs) {\r\n\t\t\tfor (const x of c) {\r\n\t\t\t\txs.add(x);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Array.from<Variable>(xs);\r\n\t}\r\n\r\n}\r\n", "/**\r\n * This class implements GENET.\r\n * CSP (but only Binary CSP) is supported.\r\n * Find the solution to the problem as the maximum CSP.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-21\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class GENET extends Solver {\r\n\r\n\t#clusters   : Cluster[]    = [];\r\n\t#connections: Connection[] = [];\r\n\r\n\t/**\r\n\t * Generates a solver given a constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'GENET';\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tif (!this.#createNetwork()) {\r\n\t\t\tthrow new Error();\r\n\t\t}\r\n\t\tconst order: number[] = [...Array(this.#clusters.length).keys()];\r\n\r\n\t\tconst defEv: number         = this.pro.ratio();\r\n\t\tconst sol  : AssignmentList = new AssignmentList();\r\n\t\tlet solEv  : number         = defEv;\r\n\r\n\t\tthis.monitor.initialize();\r\n\r\n\t\tlet ret: boolean | null = null;\r\n\r\n\t\twhile(true) {\r\n\t\t\tconst ev: number = this.pro.ratio();\r\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\r\n\r\n\t\t\tif (solEv < ev) {\r\n\t\t\t\tsol.setProblem(this.pro);\r\n\t\t\t\tsolEv = ev;\r\n\r\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tthis.#next(order);\r\n\t\t}\r\n\r\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\r\n\t\t\tsol.apply();\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#createNetwork(): boolean {\r\n\t\tthis.monitor.outputDebugString('Start of Network Generation');\r\n\t\tconst cons: Connection[] = [];\r\n\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\tif (x.domain().size() === 0) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tthis.#clusters.push(new Cluster(x));\r\n\t\t}\r\n\t\tfor (const c of this.pro.constraints()) {\r\n\t\t\tif (c.size() === 1) {  // In the case of unary constraints.\r\n\t\t\t\tconst x: Variable = c.at(0) as Variable;\r\n\t\t\t\tconst cl: Cluster = this.#clusters[x.index()];\r\n\r\n\t\t\t\tfor (const n of cl) {\r\n\t\t\t\t\tconst origV: number = x.value();  // Save the value.\r\n\t\t\t\t\tx.assign(n._value);\r\n\r\n\t\t\t\t\tif (c.isSatisfied() !== 1) {\r\n\t\t\t\t\t\tcons.push(new Connection(c, n));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx.assign(origV);  // Restore the value.\r\n\t\t\t\t}\r\n\t\t\t} else {  // In the case of binary constraints.\r\n\t\t\t\tconst x1: Variable  = c.at(0) as Variable;\r\n\t\t\t\tconst x2: Variable  = c.at(1) as Variable;\r\n\t\t\t\tconst cl_f: Cluster = this.#clusters[x1.index()];\r\n\t\t\t\tconst cl_s: Cluster = this.#clusters[x2.index()];\r\n\r\n\t\t\t\tfor (const n_f of cl_f) {\r\n\t\t\t\t\tconst origV1: number = x1.value();  // Save the value.\r\n\t\t\t\t\tx1.assign(n_f._value);\r\n\r\n\t\t\t\t\tfor (const n_s of cl_s) {\r\n\t\t\t\t\t\tconst origV2: number = x2.value();  // Save the value.\r\n\t\t\t\t\t\tx2.assign(n_s._value);\r\n\r\n\t\t\t\t\t\tif (c.isSatisfied() !== 1) {\r\n\t\t\t\t\t\t\tcons.push(new Connection(c, n_f, n_s));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tx2.assign(origV2);  // Restore the value.\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx1.assign(origV1);  // Restore the value.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const cl of this.#clusters) {\r\n\t\t\tfor (const n of cl._neurons) {\r\n\t\t\t\tn.lockConnections();\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.#connections = cons;\r\n\t\tthis.monitor.outputDebugString('End of Network Generation');\r\n\t\treturn true;\r\n\t}\r\n\r\n\t#next(order: number[]): void {\r\n\t\tlet mod: boolean = false;\r\n\t\tfor (const i of this.#shuffle(order)) {\r\n\t\t\tif (this.#clusters[i].setActivityMaximumInput()) {\r\n\t\t\t\tmod = true; // Turn on the node with the largest input in each cluster\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!mod) { // When the local minimum solution is reached.\r\n\t\t\tfor (const con of this.#connections) {\r\n\t\t\t\tcon.refreshWeight(); // Update weights for all connections\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (const clu of this.#clusters) {\r\n\t\t\t\tclu.applyToVariable();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t#shuffle(is: number[]): number[] {\r\n\t\tfor (let i: number = is.length; i > 1; --i) {\r\n\t\t\tconst j   : number = nextInt(i);\r\n\t\t\tconst temp: number = is[i - 1];\r\n\t\t\tis[i - 1] = is[j];\r\n\t\t\tis[j]     = temp;\r\n\t\t}\r\n\t\treturn is;\r\n\t}\r\n\r\n}\r\n\r\nclass Cluster {\r\n\r\n\t#x         : Variable;  // For avoiding a bug(?) of parcel.\r\n\t#index     : number   = 0;\r\n\t#maxNeurons: number[] = [];\r\n\t_neurons   : Neuron[] = [];\r\n\r\n\tconstructor(x: Variable) {\r\n\t\tthis.#x = x;\r\n\r\n\t\tfor (const v of x.domain()) {\r\n\t\t\tthis._neurons.push(new Neuron(v));\r\n\t\t}\r\n\t\tthis.#setActivity(nextInt(this._neurons.length));\r\n\t}\r\n\r\n\t#setActivity(index: number): void {\r\n\t\tfor (const n of this._neurons) {\r\n\t\t\tn._isActive = false;\r\n\t\t}\r\n\t\tthis._neurons[index]._isActive = true;\r\n\t\tthis.#index = index;\r\n\t}\r\n\r\n\tapplyToVariable(): void {\r\n\t\tthis.#x.assign(this._neurons[this.#index]._value);\r\n\t}\r\n\r\n\t// Turn on the node with the largest input.\r\n\tsetActivityMaximumInput(): boolean {\r\n\t\tthis.#maxNeurons.length = 0;\r\n\r\n\t\tlet max: number = Number.NEGATIVE_INFINITY;\r\n\t\tlet alreadyOn: boolean = false;\r\n\r\n\t\tfor (let i: number = 0; i < this._neurons.length; ++i) {\r\n\t\t\tconst input: number = this._neurons[i].getInput();\r\n\r\n\t\t\tif (max <= input) {\r\n\t\t\t\tif (max < input) {\r\n\t\t\t\t\tmax = input;\r\n\t\t\t\t\tthis.#maxNeurons.length = 0;\r\n\t\t\t\t\talreadyOn = false;\r\n\t\t\t\t}\r\n\t\t\t\tthis.#maxNeurons.push(i);\r\n\t\t\t\tif (this.#index === i) {\r\n\t\t\t\t\talreadyOn = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (alreadyOn || this.#maxNeurons.length === 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tthis.#setActivity(this.#maxNeurons[nextInt(this.#maxNeurons.length)]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t[Symbol.iterator](): Iterator<Neuron> {\r\n\t\treturn this._neurons[Symbol.iterator]();\r\n\t}\r\n\r\n}\r\n\r\nclass Connection {\r\n\r\n\t#c     : Constraint;\r\n\t#first : Neuron;\r\n\t#second: Neuron | null;\r\n\t_weight: number;  // Direct reference (read) allowed.\r\n\r\n\t// Order of neurons must be the same as the order of variables that the constraint has.\r\n\tconstructor(c: Constraint, first: Neuron, second: Neuron | null = null) {\r\n\t\tthis.#c      = c;\r\n\t\tthis.#first  = first;\r\n\t\tthis.#second = second;\r\n\t\tthis._weight = c.isSatisfied() - 1;\r\n\r\n\t\tthis.#first.addConnection(this);\r\n\t\tif (this.#second) {\r\n\t\t\tthis.#second.addConnection(this);\r\n\t\t}\r\n\t}\r\n\r\n\tgetNeuron(self: Neuron): Neuron | null {\r\n\t\tif (self === this.#first) return this.#second;\r\n\t\tif (self === this.#second) return this.#first;\r\n\t\treturn null;\r\n\t}\r\n\r\n\trefreshWeight(): void {\r\n\t\tif (!this.#first._isActive || (this.#second !== null && !this.#second._isActive)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.#c.size() === 1) {\r\n\t\t\tthis._weight += (this.#c.relation().isSatisfied(this.#first._value) - 1);\r\n\t\t} else {\r\n\t\t\tthis._weight += (this.#c.relation().isSatisfied(this.#first._value, (this.#second as Neuron)._value) - 1);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\nclass Neuron {\r\n\r\n\t#connections: Connection[] = [];\r\n\t#conTemp    : Connection[] | null = [];\r\n\r\n\t_value   : number;  // Direct reference (read) allowed.\r\n\t_isActive: boolean = false;  // Direct reference (read, write) allowed.\r\n\r\n\tconstructor(value: number) {\r\n\t\tthis._value = value;\r\n\t}\r\n\r\n\taddConnection(c: Connection): void {\r\n\t\t(this.#conTemp as Connection[]).push(c);\r\n\t}\r\n\r\n\tlockConnections(): void {\r\n\t\tthis.#connections = [...this.#conTemp as Connection[]];\r\n\t\tthis.#conTemp     = null;  // No longer being used.\r\n\t}\r\n\r\n\tgetInput(): number {\r\n\t\tlet ret: number = 0;\r\n\r\n\t\tfor (const c of this.#connections) {\r\n\t\t\tconst n: Neuron | null = c.getNeuron(this);  // If n is null, then the unary constraint.\r\n\t\t\tret += c._weight * ((n === null || n._isActive) ? 1 : 0);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n}\r\n\r\nfunction nextInt(max: number): number {\r\n\treturn Math.floor(Math.random() * Math.floor(max));\r\n}\r\n", "/**\r\n * This class implements the SRS3 algorithm for crisp CSP.\r\n * The given crisp CSP is treated as the maximum CSP.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-23\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { Assignment } from '../../util/assignment';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class CrispSRS3 extends Solver {\r\n\r\n\t#isRandom: boolean = true;\r\n\t#ws      : number[];\r\n\r\n\t#closedList: Set<TreeNode> = new Set();\r\n\t#openList  : Set<TreeNode> = new Set();  // LinkedHashSet is used in the original implementation.\r\n\t#nodes     : TreeNode[] = [];\r\n\t#neighbors : (TreeNode[] | null)[] = [];  // Cache\r\n\r\n\t/**\r\n\t * Generates a solver given a constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\r\n\t\tfor (const c of this.pro.constraints()) {\r\n\t\t\tthis.#nodes.push(new TreeNode(c));\r\n\t\t\tthis.#neighbors.push(null);\r\n\t\t}\r\n\t\tthis.#ws = new Array(this.pro.constraintSize());\r\n\t\tthis.#ws.fill(1);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'SRS3 for Crisp CSPs';\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the randomness of the algorithm.\r\n\t * Enabling randomness reduces the risk of falling into a local solution, but makes the solution unrepeatable.\r\n\t * @param flag If true, randomness is enabled.\r\n\t */\r\n\tsetRandomness(flag: boolean): void {\r\n\t\tthis.#isRandom = flag;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\tif (x.isEmpty()) {\r\n\t\t\t\tx.assign(x.domain().at(0));\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst defEv: number         = this.pro.degree();\r\n\t\tconst sol  : AssignmentList = new AssignmentList();\r\n\t\tlet solEv  : number         = defEv;\r\n\r\n\t\tthis.monitor.initialize();\r\n\r\n\t\tlet ret: boolean | null = null;\r\n\r\n\t\twhile (true) {\r\n\t\t\tconst cs: Constraint[] = this.pro.violatingConstraints();\r\n\t\t\tconst ev: number = this.pro.ratio();\r\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\r\n\r\n\t\t\tif (solEv < ev) {\r\n\t\t\t\tsol.setProblem(this.pro);\r\n\t\t\t\tsolEv = ev;\r\n\r\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tfor (const tn of this.#nodes) {\r\n\t\t\t\ttn.clear();\r\n\t\t\t}\r\n\t\t\tconst c_stars = new Set<TreeNode>();\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tconst tn: TreeNode = this.#nodes[c.index()];\r\n\t\t\t\tc_stars.add(tn);\r\n\t\t\t}\r\n\t\t\tthis.#srs(c_stars);\r\n\t\t}\r\n\r\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\r\n\t\t\tsol.apply();\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#srs(c_stars: Set<TreeNode>): boolean {\r\n\t\tthis.monitor.outputDebugString('SRS');\r\n\r\n\t\tthis.#closedList.clear();\r\n\t\tthis.#openList.clear();\r\n\t\tfor (const tn of c_stars) {\r\n\t\t\tthis.#openList.add(tn);\r\n\t\t}\r\n\r\n\t\twhile (c_stars.size && this.#openList.size) {\r\n\t\t\tconst node: TreeNode = this.#getElementFromSet(this.#openList);\r\n\t\t\tthis.#openList.delete(node);\r\n\r\n\t\t\tif (!this.#repair(node.constraint())) {\r\n\t\t\t\tthis.#spread(node);\r\n\t\t\t} else if (c_stars.delete(node)) {\r\n\t\t\t\t// If the repaired node is included in C* (to be deleted)\r\n\t\t\t} else if (node.parent() && this.#repair((node.parent() as TreeNode).constraint())) {\r\n\t\t\t\tthis.#shrink(node, c_stars);  // When its improvement leads to the improvement of its parents\r\n\t\t\t} else {\r\n\t\t\t\tthis.#spread(node);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn c_stars.size === 0;\r\n\t}\r\n\r\n\t#spread(tn: TreeNode): void {\r\n\t\tthis.monitor.outputDebugString('Spread');\r\n\t\tthis.#closedList.add(tn);\r\n\r\n\t\tfor (const n of this.#getNeighbors(tn)) {\r\n\t\t\t// For constraints that are not included in Open or Closed.\r\n\t\t\tif (!this.#closedList.has(n) && !this.#openList.has(n)) {\r\n\t\t\t\tn.clear();\r\n\t\t\t\ttn.append(n);\r\n\t\t\t\tthis.#openList.add(n);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t#repair(c0: Constraint): boolean {\r\n\t\tthis.monitor.outputDebugString('Repair');\r\n\t\tthis.#ws[c0.index()] += 1;\r\n\r\n\t\tconst canList = new AssignmentList();\r\n\t\tlet maxDiff: number = 0;\r\n\r\n\t\tfor (const x of c0) {\r\n\t\t\tconst x_v: number = x.value();  // Save the value\r\n\r\n\t\t\tlet nowEv: number = 0;\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tnowEv += (1 - c.isSatisfied()) * this.#ws[c.index()];\r\n\t\t\t}\r\n\t\t\tout: for (const v of x.domain()) {\r\n\t\t\t\tif (x_v === v) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tx.assign(v);\r\n\t\t\t\tif (c0.isSatisfied() !== 1) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tlet diff: number = nowEv;\r\n\r\n\t\t\t\tfor (const c of x) {\r\n\t\t\t\t\tdiff -= (1 - c.isSatisfied()) * this.#ws[c.index()];\r\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\r\n\t\t\t\t\tif (diff < maxDiff) {\r\n\t\t\t\t\t\tcontinue out;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (maxDiff < diff) {  // An assignment that are better than ever before is found.\r\n\t\t\t\t\tmaxDiff = diff;\r\n\t\t\t\t\tcanList.clear();\r\n\t\t\t\t\tcanList.addVariable(x, v);\r\n\t\t\t\t} else if (maxDiff !== 0) {  // An assignments that can be improved to the same level as before is found.\r\n\t\t\t\t\tcanList.addVariable(x, v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tx.assign(x_v);  // Restore the value\r\n\t\t}\r\n\t\tif (0 < canList.size()) {\r\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\r\n\t\t\ta.apply();\r\n\t\t\tthis.monitor.outputDebugString('\\t' + a);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t#shrink(node: TreeNode, c_stars: Set<TreeNode>): void {\r\n\t\tthis.monitor.outputDebugString('Shrink');\r\n\r\n\t\tlet cur         : TreeNode = node;\r\n\t\tlet curIsRemoved: boolean  = false;\r\n\r\n\t\twhile (true) {\r\n\t\t\tcur = cur.parent() as TreeNode;\r\n\t\t\tif (c_stars.delete(cur)) {\r\n\t\t\t\tcurIsRemoved = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (!cur.parent() || !this.#repair((cur.parent() as TreeNode).constraint())) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst temp: TreeNode[] = [];\r\n\t\tcur.getDescendants(temp);  // temp contains node.\r\n\t\tcur.clear();  // Prepare for reuse\r\n\r\n\t\tfor (const n of temp) {\r\n\t\t\tthis.#openList.delete(n);\r\n\t\t\tthis.#closedList.delete(n);\r\n\t\t}\r\n\t\tif (!curIsRemoved) {\r\n\t\t\tthis.#openList.add(cur);\r\n\t\t}\r\n\t}\r\n\r\n\t// #shrink(node: TreeNode, c_stars: Set<TreeNode>): void {\r\n\t// \tthis.debugOutput('Shrink');\r\n\r\n\t// \tconst temp: TreeNode[] = [];\r\n\t// \tlet cur: TreeNode = node;\r\n\r\n\t// \twhile (true) {  // This procedure is originally a recursive call, but converted to a loop\r\n\t// \t\tcur = cur.parent() as TreeNode;\r\n\t// \t\ttemp.length = 0;\r\n\t// \t\tcur.getDescendants(temp);\r\n\t// \t\tcur.clear();\r\n\r\n\t// \t\tfor (const n of temp) {\r\n\t// \t\t\tthis.#openList.delete(n);\r\n\t// \t\t\tthis.#closedList.delete(n);\r\n\t// \t\t}\r\n\t// \t\tif (c_stars.delete(cur)) {\r\n\t// \t\t} else {\r\n\t// \t\t\tthis.#openList.add(cur);\r\n\t// \t\t\tif (!cur.parent() || !this.#repair((cur.parent() as TreeNode).constraint())) {\r\n\t// \t\t\t\tbreak;\r\n\t// \t\t\t}\r\n\t// \t\t}\r\n\t// \t}\r\n\t// }\r\n\r\n\t#getNeighbors(tn: TreeNode): TreeNode[] {\r\n\t\tconst c: Constraint = tn.constraint();\r\n\t\tconst i: number     = c.index();\r\n\r\n\t\tif (this.#neighbors[i] === null) {\r\n\t\t\tconst ns: TreeNode[] = [];\r\n\t\t\tfor (const d of c.neighbors()) {\r\n\t\t\t\tns.push(this.#nodes[d.index()]);\r\n\t\t\t}\r\n\t\t\tthis.#neighbors[i] = ns;\r\n\t\t}\r\n\t\treturn this.#neighbors[i];\r\n\t}\r\n\r\n\t#getElementFromSet(set: Set<TreeNode>): TreeNode {\r\n\t\tconst ms : TreeNode[] = this.#selectLightestNode(this.#selectNearestNode(set));\r\n\t\treturn this.#isRandom ? ms[Math.floor(Math.random() * ms.length)] : ms[0];\r\n\t}\r\n\r\n\t#selectLightestNode(set: Iterable<TreeNode>): TreeNode[] {\r\n\t\tlet curW: number     = Number.MAX_VALUE;\r\n\t\tlet ms  : TreeNode[] = [];\r\n\r\n\t\tfor (const tn of set) {\r\n\t\t\tconst w: number = this.#ws[tn.constraint().index()];\r\n\t\t\tif (w < curW) {\r\n\t\t\t\tcurW = w;\r\n\t\t\t\tms.length = 0;\r\n\t\t\t\tms.push(tn);\r\n\t\t\t} else if (w === curW) {\r\n\t\t\t\tms.push(tn);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ms;\r\n\t}\r\n\r\n\t#selectNearestNode(set: Iterable<TreeNode>): TreeNode[] {\r\n\t\tlet curD: number     = Number.MAX_VALUE;\r\n\t\tlet ms  : TreeNode[] = [];\r\n\r\n\t\tfor (const tn of set) {\r\n\t\t\tconst d: number = tn.depth();\r\n\t\t\tif (d < curD) {\r\n\t\t\t\tcurD = d;\r\n\t\t\t\tms.length = 0;\r\n\t\t\t\tms.push(tn);\r\n\t\t\t} else if (d === curD) {\r\n\t\t\t\tms.push(tn);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ms;\r\n\t}\r\n\r\n}\r\n\r\nclass TreeNode {\r\n\r\n\t#c       : Constraint;\r\n\t#depth   : number = 0;\r\n\t#parent  : TreeNode | null = null;\r\n\t#children: TreeNode[] = [];\r\n\r\n\tconstructor(c: Constraint) {\r\n\t\tthis.#c = c;\r\n\t}\r\n\r\n\tappend(tn: TreeNode): void {\r\n\t\ttn.#parent = this;\r\n\t\ttn.#depth  = this.#depth + 1;\r\n\t\tthis.#children.push(tn);\r\n\t}\r\n\r\n\tclear(): void {\r\n\t\tthis.#parent = null;\r\n\t\tthis.#depth  = 0;\r\n\t\tfor (const tn of this.#children) {\r\n\t\t\ttn.clear();\r\n\t\t}\r\n\t\tthis.#children.length = 0;\r\n\t}\r\n\r\n\tconstraint(): Constraint {\r\n\t\treturn this.#c;\r\n\t}\r\n\r\n\tdepth(): number {\r\n\t\treturn this.#depth;\r\n\t}\r\n\r\n\tparent(): TreeNode | null {\r\n\t\treturn this.#parent;\r\n\t}\r\n\r\n\tgetDescendants(tns: TreeNode[]): void {\r\n\t\ttns.push(this);\r\n\r\n\t\tfor (const tn of this.#children) {\r\n\t\t\ttn.getDescendants(tns);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n", "/**\r\n * This class implements the forward and backward checking method for fuzzy CSP.\r\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\r\n * Each variable must have its own domain because it hides domain elements as branch pruning.\r\n * Forward checking is also performed for problems with polynomial constraints.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2025-01-02\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { Domain } from '../../problem/domain';\r\nimport { DomainPruner, assignDomainPruner, unassignDomainPruner, recover, indexOfVariableWithMRV } from '../../util/domain-pruner';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { createRelatedConstraintTable } from '../../util/problems';\r\nimport { Solver } from '../solver';\r\n\r\nexport class FullChecking extends Solver {\r\n\r\n\t#xs : Variable[];\r\n\t#rct: Constraint[][][] = [];  // Table to cache constraints between two variables.\r\n\t#sol: AssignmentList   = new AssignmentList();\r\n\r\n\t#useMRV: boolean = true;\r\n\r\n\t#minDeg   : number  = 0;  // Degree of existing solutions (no need to find a solution less than this).\r\n\t#globalRet: boolean = false;\r\n\r\n\t#checkedCs       : Set<Constraint> = new Set();\r\n\t#sequence        : Variable[];\r\n\t#unaryCs         : Constraint[]    = [];\r\n\t#pruneIntensively: boolean         = false;\r\n\r\n\t/**\r\n\t * Generates the solver given a fuzzy constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\r\n\t\tthis.#xs  = [...this.pro.variables()];\r\n\t\tthis.#rct = createRelatedConstraintTable(this.pro, this.#xs);\r\n\r\n\t\tthis.#sequence = new Array(this.pro.variableSize());\r\n\t\tthis.#unaryCs  = this.pro.constraints().filter((c: Constraint): boolean => c.size() === 1);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Full Checking for Fuzzy CSPs';\r\n\t}\r\n\r\n\t/**\r\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\r\n\t * Use of MRV may increase processing time for some problems.\r\n\t * Default is false.\r\n\t * @param flag Use MRV if true.\r\n\t */\r\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\r\n\t\tthis.#useMRV = flag;\r\n\t}\r\n\r\n\t/**\r\n\t * Specifies whether or not to intensively prune branches when the problem contains 3- or n-ary constraints.\r\n\t * Depending on the problem, intensive pruning may increase processing time.\r\n\t * Default is false.\r\n\t * @param flag Whether or not to intensively prune branches.\r\n\t */\r\n\tsetIntensivePruning(flag: boolean): void {\r\n\t\tthis.#pruneIntensively = flag;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tthis.monitor.initialize();\r\n\t\tthis.#minDeg = 0;\r\n\t\tassignDomainPruner(this.#xs);\r\n\r\n\t\tlet ret: boolean | null = null;\r\n\t\twhile (ret === null) {\r\n\t\t\tif (!this.#pruneUnaryConstraints()) {\r\n\t\t\t\tret = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tthis.pro.clearAllVariables();\r\n\t\t\tret = this.#branch(0);\r\n\t\t\tthis.#sol.apply();\r\n\r\n\t\t\tthis.#globalRet = false;\r\n\t\t}\r\n\r\n\t\tunassignDomainPruner(this.#xs);\r\n\t\treturn ret === true;\r\n\t}\r\n\r\n\t// Prune elements of the domain that make the unary constraint worse than the current worst degree.\r\n\t#pruneUnaryConstraints(): boolean {\r\n\t\tfor (const c of this.#unaryCs) {\r\n\t\t\tconst x    : Variable     = c.at(0) as Variable;\r\n\t\t\tconst origV: number       = x.value();  // Save the value.\r\n\t\t\tconst d    : Domain       = x.domain();\r\n\t\t\tconst dp   : DomainPruner = x.solverObject;\r\n\r\n\t\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\r\n\t\t\t\tx.assign(d.at(i));\r\n\t\t\t\tif (c.degree() <= this.#minDeg) {\r\n\t\t\t\t\tdp.prune(i, -1);  // Here's a branch pruning!\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tx.assign(origV);  // Restore the value.\r\n\t\t\tif (dp.isEmpty()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t#branch(level: number, curDeg: number = 1): boolean | null {\r\n\t\tif (level === this.pro.variableSize()) {\r\n\t\t\tconst ev: number = this.pro.degree();\r\n\t\t\tthis.#sol.setProblem(this.pro);\r\n\t\t\tthis.monitor.outputDebugString('\\t' + `Evaluation ${ev}`);\r\n\r\n\t\t\tif (this.#minDeg < ev) {\r\n\t\t\t\tthis.#minDeg    = ev;\r\n\t\t\t\tthis.#globalRet = true;\r\n\r\n\t\t\t\tif (this.monitor.solutionFound(this.#sol, ev)) {\r\n\t\t\t\t\treturn true;  // Success.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this.monitor.check(ev);\r\n\t\t}\r\n\t\tlet ret: boolean | null = null;\r\n\t\tif (null !== (ret = this.monitor.check())) {\r\n\t\t\treturn ret;  // Success or failure.\r\n\t\t}\r\n\r\n\t\tconst x : Variable     = this.#xs[this.#useMRV ? indexOfVariableWithMRV(this.#xs) : level];\r\n\t\tconst d : Domain       = x.domain();\r\n\t\tconst dp: DomainPruner = x.solverObject;\r\n\r\n\t\tthis.#sequence[level] = x;\r\n\r\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\r\n\t\t\tif (dp.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx.assign(d.at(i));\r\n\r\n\t\t\tconst deg: number = Math.min(curDeg, this.#getBackwardConsistency(x));\r\n\t\t\tif (deg <= this.#minDeg) {  // A new solution is assumed when 'greater than'.\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (this.#checkForward(level, x)) {\r\n\t\t\t\tret = this.#branch(level + 1, deg);\r\n\t\t\t\tif (null !== ret || this.#globalRet) {  // Success or failure.\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trecover(this.#xs, level);\r\n\t\t}\r\n\t\tif (ret === null) {  // When searching back to the parent, undo the branch pruning here.\r\n\t\t\trecover(this.#xs, level);\r\n\t\t\tx.clear();\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t// Checks for possible assignment to a future variable from the current variable assignment.\r\n\t#checkForward(level: number, x: Variable): boolean {\r\n\t\tfor (const x_i of this.#xs) {\r\n\t\t\tif (!x_i.isEmpty()) {\r\n\t\t\t\tcontinue;  // If it is a past or present variable.\r\n\t\t\t}\r\n\t\t\tconst cs  : Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\r\n\t\t\tconst dp_i: DomainPruner = x_i.solverObject;\r\n\t\t\tconst d_i : Domain       = x_i.domain();\r\n\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tconst evs: number = c.emptyVariableSize();\r\n\t\t\t\tif (evs === 1) {\r\n\t\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, d_i, dp_i, c)) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (this.#pruneIntensively) {  // Depends on options\r\n\t\t\t\t\tif (evs === 2) {\r\n\t\t\t\t\t\tif (!this.#checkForwardConsistency2(level, x_i, d_i, dp_i, c)) {\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (evs === 3) {\r\n\t\t\t\t\t\tif (!this.#checkForwardConsistency3(level, x_i, d_i, dp_i, c)) {\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (evs > 3) {\r\n\t\t\t\t\t\tif (!this.#checkForwardConsistencyN(level, x_i, d_i, dp_i, c, evs)) {\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\r\n\t#getConstraintsBetween(i: number, j: number): Constraint[] {\r\n\t\treturn (i < j) ? this.#rct[j][i] : this.#rct[i][j];\r\n\t}\r\n\r\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\r\n\t#checkForwardConsistency(level: number, x: Variable, d: Domain, dp: DomainPruner, c: Constraint): boolean {\r\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\r\n\t\t\tif (dp.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx.assign(d.at(i));\r\n\r\n\t\t\tif (c.degree() <= this.#minDeg) {  // It is not a solution when it is 'smaller than or equals' (not even UNDEFINED).\r\n\t\t\t\tdp.prune(i, level);\r\n\t\t\t}\r\n\t\t}\r\n\t\tx.clear();\r\n\t\treturn !dp.isEmpty();  // Failure if the domain of one of the future variables is empty.\r\n\t}\r\n\r\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there are two unassigned variables in the scope of the constraint).\r\n\t#checkForwardConsistency2(level: number, x_i: Variable, d_i: Domain, dp_i: DomainPruner, c: Constraint): boolean {\r\n\t\tlet x_j: Variable | null = null;\r\n\r\n\t\tfor (const x of c) {\r\n\t\t\tif (x.isEmpty() && x !== x_i) {\r\n\t\t\t\tx_j = x;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst d_j : Domain       = x_j!.domain();\r\n\t\tconst dp_j: DomainPruner = x_j!.solverObject;\r\n\r\n\t\tloop_i: for (let i: number = 0, ni: number = d_i.size(); i < ni; ++i) {\r\n\t\t\tif (dp_i.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx_i.assign(d_i.at(i));  // Tentative assignment to x_i\r\n\r\n\t\t\tfor (let j: number = 0, nj: number = d_j.size(); j < nj; ++j) {\r\n\t\t\t\tif (dp_j.isPruned(j)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tx_j!.assign(d_j.at(j));  // Tentative assignment to x_j\r\n\r\n\t\t\t\tif (c.degree() > this.#minDeg) {\r\n\t\t\t\t\tcontinue loop_i;  // Tentative assignment to x_i was OK -> next tentative assignment.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdp_i.prune(i, level);  // It is not a solution when it is 'smaller than or equals'.\r\n\t\t}\r\n\t\tx_j!.clear();\r\n\t\tx_i.clear();\r\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable is not empty.\r\n\t}\r\n\r\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there are three unassigned variables in the scope of the constraint).\r\n\t#checkForwardConsistency3(level: number, x_i: Variable, d_i: Domain, dp_i: DomainPruner, c: Constraint): boolean {\r\n\t\tlet x_j: Variable | null = null;\r\n\t\tlet x_k: Variable | null = null;\r\n\r\n\t\tfor (const x of c) {\r\n\t\t\tif (x.isEmpty() && x !== x_i) {\r\n\t\t\t\tif (x_j === null) {\r\n\t\t\t\t\tx_j = x;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tx_k = x;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst d_j : Domain       = x_j!.domain();\r\n\t\tconst d_k : Domain       = x_k!.domain();\r\n\t\tconst dp_j: DomainPruner = x_j!.solverObject;\r\n\t\tconst dp_k: DomainPruner = x_k!.solverObject;\r\n\r\n\t\tloop_i: for (let i: number = 0, ni: number = d_i.size(); i < ni; ++i) {\r\n\t\t\tif (dp_i.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx_i.assign(d_i.at(i));  // Tentative assignment to x_i\r\n\r\n\t\t\tfor (let j: number = 0, nj: number = d_j.size(); j < nj; ++j) {\r\n\t\t\t\tif (dp_j.isPruned(j)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tx_j!.assign(d_j.at(j));  // Tentative assignment to x_j\r\n\r\n\t\t\t\tfor (let k: number = 0, nk: number = d_k.size(); k < nk; ++k) {\r\n\t\t\t\t\tif (dp_k.isPruned(k)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx_k!.assign(d_k.at(k));  // Tentative assignment to x_k\r\n\r\n\t\t\t\t\tif (c.degree() > this.#minDeg) {\r\n\t\t\t\t\t\tcontinue loop_i;  // Tentative assignment to x_i was OK -> next tentative assignment.\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdp_i.prune(i, level);  // It is not a solution when it is 'smaller than or equals'.\r\n\t\t}\r\n\t\tx_k!.clear();\r\n\t\tx_j!.clear();\r\n\t\tx_i.clear();\r\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable is not empty.\r\n\t}\r\n\r\n\t// In the case of polynomial constraints and when there are four or more unassigned variables, all combinations of assignments of unassigned variables are examined and pruned.\r\n\t#checkForwardConsistencyN(level: number, x_i: Variable, d_i: Domain, dp_i: DomainPruner, c: Constraint, emptySize: number): boolean {\r\n\t\tconst x_ = new Array(emptySize - 1);\r\n\t\tlet j: number = 0;\r\n\r\n\t\tfor (const x of c) {\r\n\t\t\tif (x.isEmpty() && x !== x_i) {\r\n\t\t\t\tx_[j++] = x;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst indexes = new Array(x_.length);\r\n\r\n\t\tloop_i: for (let i: number = 0, n: number = d_i.size(); i < n; ++i) {\r\n\t\t\tif (dp_i.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx_i.assign(d_i.at(i));  // Tentative assignment to x_i\r\n\t\t\tindexes.fill(0);\r\n\r\n\t\t\tcomLoop: while (true) {\r\n\t\t\t\tlet hidden: boolean = false;\r\n\r\n\t\t\t\tfor (let k: number = 0; k < x_.length; ++k) {\r\n\t\t\t\t\tconst d_k : Domain       = x_[k].domain();\r\n\t\t\t\t\tconst dp_k: DomainPruner = x_[k].solverObject;\r\n\r\n\t\t\t\t\tif (dp_k.isPruned(indexes[k])) {\r\n\t\t\t\t\t\thidden = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx_[k].assign(d_k.at(indexes[k]));\r\n\t\t\t\t}\r\n\t\t\t\tif (!hidden) {\r\n\t\t\t\t\tif (c.degree() > this.#minDeg) {\r\n\t\t\t\t\t\tcontinue loop_i;  // Tentative assignment to x_i was OK -> next tentative assignment.\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (let k: number = 0; k < x_.length; ++k) {\r\n\t\t\t\t\tindexes[k] += 1;\r\n\t\t\t\t\tif (indexes[k] < x_[k].domain().size()) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tindexes[k] = 0;\r\n\t\t\t\t\tif (k === x_.length - 1) {\r\n\t\t\t\t\t\tbreak comLoop;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdp_i.prune(i, level);\r\n\t\t}\r\n\t\tfor (const x of x_) {\r\n\t\t\tx.clear();\r\n\t\t}\r\n\t\tx_i.clear();\r\n\t\treturn !dp_i.isEmpty();  // Succeeds if the domain di of the future variable is not empty.\r\n\t}\r\n\r\n\t// Checks to see if the current variable assignment makes the degree of the past variable worse than the current worst degree.\r\n\t#getBackwardConsistency(x: Variable): number {\r\n\t\tlet min: number = Number.MAX_VALUE;\r\n\t\tthis.#checkedCs.clear();  // Reuse.\r\n\r\n\t\tfor (const x_i of this.#xs) {  // Find past variables.\r\n\t\t\tif (x_i === x || x_i.isEmpty()) {  // If it is a future variable or a present variable.\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst cs: Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\r\n\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tif (!this.#checkedCs.has(c)) {  // Because of the possibility of duplication in polynomial constraints\r\n\t\t\t\t\tconst deg: number = c.degree();\r\n\t\t\t\t\tif (deg !== Constraint.UNDEFINED && deg < min) {  // It is not a solution when it is 'smaller than or equals'.\r\n\t\t\t\t\t\tmin = deg;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.#checkedCs.add(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn min;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * This class implements the forward checking method for fuzzy CSPs.\r\n * The minimum-remaining-values (MRV) heuristic can also be used by specifying the option.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2025-01-02\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { Domain } from '../../problem/domain';\r\nimport { DomainPruner, assignDomainPruner, unassignDomainPruner, recover, indexOfVariableWithMRV } from '../../util/domain-pruner';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { createRelatedConstraintTable } from '../../util/problems';\r\nimport { Solver } from '../solver';\r\n\r\nexport class FuzzyForwardChecking extends Solver {\r\n\r\n\t#xs : Variable[];\r\n\t#rct: Constraint[][][] = [];  // Table to cache constraints between two variables.\r\n\t#sol: AssignmentList   = new AssignmentList();\r\n\r\n\t#useMRV: boolean = true;\r\n\r\n\t#minDeg   : number  = 0;  // Degree of existing solutions (no need to find a solution less than this).\r\n\t#globalRet: boolean = false;\r\n\r\n\t/**\r\n\t * Generates the solver given a fuzzy constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\r\n\t\tthis.#xs  = [...this.pro.variables()];\r\n\t\tthis.#rct = createRelatedConstraintTable(this.pro, this.#xs);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Forward Checking for Fuzzy CSPs';\r\n\t}\r\n\r\n\t/**\r\n\t * Specify whether to use the minimum-remaining-values (MRV) heuristic.\r\n\t * Use of MRV may increase processing time for some problems.\r\n\t * Default is false.\r\n\t * @param flag Use MRV if true.\r\n\t */\r\n\tsetUsingMinimumRemainingValuesHeuristics(flag: boolean): void {\r\n\t\tthis.#useMRV = flag;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tthis.monitor.initialize();\r\n\t\tthis.#minDeg = 0;\r\n\t\tassignDomainPruner(this.#xs);\r\n\r\n\t\tlet ret: boolean | null = null;\r\n\t\twhile (ret === null) {\r\n\t\t\tthis.pro.clearAllVariables();\r\n\t\t\tret = this.#branch(0);\r\n\t\t\tthis.#sol.apply();\r\n\r\n\t\t\tthis.#globalRet = false;\r\n\t\t}\r\n\r\n\t\tunassignDomainPruner(this.#xs);\r\n\t\treturn ret === true;\r\n\t}\r\n\r\n\t#branch(level: number, curDeg: number = 1): boolean | null {\r\n\t\tif (level === this.pro.variableSize()) {\r\n\t\t\tconst ev: number = this.pro.degree();\r\n\t\t\tthis.#sol.setProblem(this.pro);\r\n\t\t\tthis.monitor.outputDebugString('\\t' + `Evaluation ${ev}`);\r\n\r\n\t\t\tif (this.#minDeg < ev) {\r\n\t\t\t\tthis.#minDeg    = ev;\r\n\t\t\t\tthis.#globalRet = true;\r\n\r\n\t\t\t\tif (this.monitor.solutionFound(this.#sol, ev)) {\r\n\t\t\t\t\treturn true;  // Success.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this.monitor.check(ev);\r\n\t\t}\r\n\t\tlet ret: boolean | null = null;\r\n\t\tif (null !== (ret = this.monitor.check())) {\r\n\t\t\treturn ret;  // Success or failure.\r\n\t\t}\r\n\r\n\t\tconst x : Variable     = this.#xs[this.#useMRV ? indexOfVariableWithMRV(this.#xs) : level];\r\n\t\tconst d : Domain       = x.domain();\r\n\t\tconst dp: DomainPruner = x.solverObject;\r\n\r\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\r\n\t\t\tif (dp.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx.assign(d.at(i));\r\n\r\n\t\t\tconst deg: number = Math.min(curDeg, this.#getWorstDegreeAround(x));\r\n\t\t\tif (deg <= this.#minDeg) {  // A new solution is assumed when 'greater than'.\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (this.#checkForward(level, x)) {\r\n\t\t\t\tret = this.#branch(level + 1, deg);\r\n\t\t\t\tif (null !== ret || this.#globalRet) {  // Success or failure.\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trecover(this.#xs, level);\r\n\t\t}\r\n\t\tif (ret === null) {  // When searching back to the parent, undo the branch pruning here.\r\n\t\t\trecover(this.#xs, level);\r\n\t\t\tx.clear();\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t// Checks for possible assignment to a future variable from the current variable assignment.\r\n\t#checkForward(level: number, x: Variable): boolean {\r\n\t\tfor (const x_i of this.#xs) {\r\n\t\t\tif (!x_i.isEmpty()) {\r\n\t\t\t\tcontinue;  // If it is a past or present variable.\r\n\t\t\t}\r\n\t\t\tconst cs  : Constraint[] = this.#getConstraintsBetween(x.index(), x_i.index());\r\n\t\t\tconst dp_i: DomainPruner = x_i.solverObject;\r\n\t\t\tconst d_i : Domain       = x_i.domain();\r\n\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tif (c.emptyVariableSize() !== 1) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.#checkForwardConsistency(level, x_i, d_i, dp_i, c)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Retrieves an array of constraints from a table that caches constraints between two variables.\r\n\t#getConstraintsBetween(i: number, j: number): Constraint[] {\r\n\t\treturn (i < j) ? this.#rct[j][i] : this.#rct[i][j];\r\n\t}\r\n\r\n\t// Check for consistency between the current variable and one future variable, and prune elements of the domain that are inconsistent (when there is one unassigned variable in the scope of the constraint).\r\n\t#checkForwardConsistency(level: number, x: Variable, d: Domain, dp: DomainPruner, c: Constraint): boolean {\r\n\t\tfor (let i: number = 0, n: number = d.size(); i < n; ++i) {\r\n\t\t\tif (dp.isPruned(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tx.assign(d.at(i));\r\n\r\n\t\t\tif (c.degree() <= this.#minDeg) {  // It is not a solution when it is 'smaller than or equals' (not even UNDEFINED).\r\n\t\t\t\tdp.prune(i, level);\r\n\t\t\t}\r\n\t\t}\r\n\t\tx.clear();\r\n\t\treturn !dp.isEmpty();  // Failure if the domain of one of the future variables is empty.\r\n\t}\r\n\r\n\t// Find the number of constraint violations that have increased due to the current value of the variable x.\r\n\t#getWorstDegreeAround(x: Variable): number {\r\n\t\tlet min: number = Number.MAX_VALUE;\r\n\r\n\t\tfor (const c of x) {\r\n\t\t\tconst deg: number = c.degree();\r\n\t\t\tif (deg !== Constraint.UNDEFINED && deg < min) {\r\n\t\t\t\tmin = deg;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn min;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * A class that implements the flexible local changes method.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-23\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class FlexibleLocalChanges extends Solver {\r\n\r\n\t#lt: number = 0;\r\n\t#lb: number = 0;\r\n\r\n\t#globalReturn: number = 0;\r\n\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\t\tthis.#computeHighestAndLowestConsistencyDegree();\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Flexible Local Changes';\r\n\t}\r\n\r\n\t#choose(x2: Set<Variable>, cr: Set<Constraint>): Set<Variable> {\r\n\t\tconst res = new Map<Variable, number>();\r\n\r\n\t\tfor (const c of cr) {\r\n\t\t\tif (!c.isDefined()) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (const x of c) {\r\n\t\t\t\tif (!res.has(x)) {\r\n\t\t\t\t\tres.set(x, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tres.set(x, (res.get(x) ?? 0) + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst xs: Variable[] = [...x2];\r\n\t\txs.sort((o1: Variable, o2: Variable): -1 | 0 | 1 => {\r\n\t\t\tlet res1: number = 0;\r\n\t\t\tlet res2: number = 0;\r\n\t\t\tif (res.has(o1)) res1 = res.get(o1) ?? 0;\r\n\t\t\tif (res.has(o2)) res2 = res.get(o2) ?? 0;\r\n\r\n\t\t\tif (res1 < res2) return 1;\r\n\t\t\tif (res1 > res2) return -1;\r\n\t\t\treturn 0;\r\n\t\t});\r\n\r\n\t\tconst ret = new Set<Variable>();\r\n\r\n\t\tfor (const x of xs) {\r\n\t\t\tlet remain: boolean = false;\r\n\t\t\tfor (const c of cr) {\r\n\t\t\t\tif (c.isDefined()) {\r\n\t\t\t\t\tremain = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!remain) break;\r\n\t\t\tx.clear();\r\n\t\t\tret.add(x);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#computeHighestAndLowestConsistencyDegree(): void {\r\n\t\tlet low : number = 1;\r\n\t\tlet high: number = 0;\r\n\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tconst l: number = c.lowestConsistencyDegree();\r\n\t\t\t\tconst h: number = c.highestConsistencyDegree();\r\n\t\t\t\tif (l < low) low = l;\r\n\t\t\t\tif (h > high) high = h;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.#lb = low;\r\n\t\tthis.#lt = high;\r\n\t}\r\n\r\n\t#flcRepair(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>, rc: number): number {\r\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr);\r\n\t\tconst X1p: Set<Variable> = cloneAndAdd(X1, xi);\r\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\r\n\t\treturn this.#flcVariables(X1p, X2p, X3p, consX1xi, Math.min(consX12, consX1xi), rc);\r\n\t}\r\n\r\n\t#flcVariable(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1: number, consX12: number, rc: number): number {\r\n\t\tlet bestCons: number = this.#lb;\r\n\t\tif (xi.domain().size() === 0) {\r\n\t\t\treturn bestCons;\r\n\t\t}\r\n\t\tlet bestX2: AssignmentList = AssignmentList.fromVariables(X2);\r\n\t\tlet bestDij: number = xi.domain().at(0);\r\n\r\n\t\tconst x2Store: AssignmentList = AssignmentList.fromVariables(X2);\r\n\r\n\t\tfor (let j: number = 0; j < xi.domain().size() && bestCons < consX12; ++j) {\r\n\t\t\tconst dij: number = xi.domain().at(j);\r\n\t\t\txi.assign(dij);\r\n\t\t\tconst consX1_xi: number = Math.min(consX1, this.#testX1(X1, xi, bestCons, rc));\r\n\r\n\t\t\tif (consX1_xi > Math.max(bestCons, rc)) {\r\n\t\t\t\tconst crNew = new Set<Constraint>();\r\n\t\t\t\tconst consX12_xi: number = Math.min(Math.min(consX1_xi, consX12), this.#testX12(X1, X2, xi, consX1_xi, consX12, crNew));\r\n\r\n\t\t\t\tif (consX12_xi > bestCons) {\r\n\t\t\t\t\tbestCons = consX12_xi;\r\n\t\t\t\t\tbestDij = dij;\r\n\t\t\t\t\tbestX2 = AssignmentList.fromVariables(X2);\r\n\t\t\t\t}\r\n\t\t\t\tif (crNew.size) {\r\n\t\t\t\t\tconst repairCons: number = this.#flcRepair(X1, X2, xi, consX1_xi, consX12, crNew, Math.max(rc, bestCons));\r\n\t\t\t\t\tif (this.#globalReturn !== -1) {\r\n\t\t\t\t\t\treturn bestCons;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (repairCons > bestCons) {\r\n\t\t\t\t\t\tbestCons = repairCons;\r\n\t\t\t\t\t\tbestDij = dij;\r\n\t\t\t\t\t\tbestX2 = AssignmentList.fromVariables(X2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx2Store.apply();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbestX2.apply();\r\n\t\txi.assign(bestDij);\r\n\t\treturn bestCons;\r\n\t}\r\n\r\n\t#flcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>, consX1: number, consX12: number, rc: number): number {\r\n\t\t{\r\n\t\t\tthis.monitor.outputDebugString(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\r\n\r\n\t\t\tconst ret: boolean | null = this.monitor.check(this.pro.degree());\r\n\t\t\tif (ret !== null) {\r\n\t\t\t\tthis.#globalReturn = ret ? 1 : 0;\r\n\t\t\t\treturn consX12;\r\n\t\t\t}\r\n\t\t\tif (X3.size === 0) {\r\n\t\t\t\treturn consX12;\r\n\t\t\t}\r\n\t\t\tconst xi = X3.values().next().value as Variable;\r\n\t\t\tconst consX12xi: number = this.#flcVariable(X1, X2, xi, consX1, consX12, rc);\r\n\r\n\t\t\tif (this.#globalReturn !== -1) {\r\n\t\t\t\treturn consX12;\r\n\t\t\t}\r\n\t\t\tif (consX12xi < rc) {\r\n\t\t\t\treturn this.#lb;\r\n\t\t\t}\r\n\t\t\tX2 = cloneAndAdd(X2, xi);\r\n\t\t\tX3 = cloneAndDelete(X3, xi);\r\n\t\t\treturn this.#flcVariables(X1, X2, X3, consX1, consX12xi, rc);\r\n\t\t}\r\n\t}\r\n\r\n\t#initTest(X: Set<Variable>, cr: Set<Constraint>): number {\r\n\t\tconst cs = new Set<Constraint>();\r\n\r\n\t\tfor (const x of X) {\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tcs.add(c);  // All variables in X have been assigned.\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet ret: number = 1;\r\n\t\tfor (const c of cs) {\r\n\t\t\tconst sd: number = c.degree();\r\n\t\t\tif (sd === Constraint.UNDEFINED) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (sd < ret) {\r\n\t\t\t\tret = sd;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const c of this.pro.constraints()) {\r\n\t\t\tconst cd: number = c.lowestConsistencyDegree();\r\n\t\t\tif (cd < this.#lt) {\r\n\t\t\t\tcr.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#testX1(X1: Set<Variable>, xi: Variable, bestCons: number, rc: number): number {\r\n\t\tlet cd: number = 1;\r\n\t\tconst cs = new Set<Constraint>();\r\n\r\n\t\tfor (const x of X1) {\r\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xi);\r\n\t\t\tfor (const c of temp) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const c of cs) {\r\n\t\t\tconst d: number = c.degree();\r\n\t\t\tif (d === Constraint.UNDEFINED) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (d < cd) {\r\n\t\t\t\tcd = d;\r\n\t\t\t}\r\n\t\t\t// If it is determined that a better solution than the current solution cannot be obtained\r\n\t\t\tif (cd <= bestCons || cd <= rc) {\r\n\t\t\t\treturn cd;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n\t#testX12(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>): number {\r\n\t\tlet csd: number = 1;\r\n\t\tconst cs = new Set<Constraint>();\r\n\r\n\t\tfor (const x of X1) {\r\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xi);\r\n\t\t\tfor (const c of temp) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const x of X2) {\r\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xi);\r\n\t\t\tfor (const c of temp) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const c of cs) {\r\n\t\t\tconst sd: number = c.degree();\r\n\t\t\tif (sd === Constraint.UNDEFINED) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (sd < csd) {\r\n\t\t\t\tcsd = sd;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const c of cs) {\r\n\t\t\tconst sd: number = c.degree();\r\n\t\t\tif (sd === Constraint.UNDEFINED) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (sd < consX1xi || sd < consX12) {\r\n\t\t\t\tcr.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn csd;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tthis.monitor.initialize();\r\n\t\tthis.#globalReturn = -1;\r\n\r\n\t\tconst wsd: number = this.pro.degree();\r\n\t\tif (this.pro.emptyVariableSize() === 0) {\r\n\t\t\tthis.pro.clearAllVariables();\r\n\t\t}\r\n\t\tconst X1 = new Set<Variable>();\r\n\t\tconst X2 = new Set<Variable>();  // Currently assigned variables.\r\n\t\tconst X3 = new Set<Variable>();  // Currently unassigned variables.\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\t(!x.isEmpty() ? X2 : X3).add(x);\r\n\t\t}\r\n\r\n\t\tconst cr = new Set<Constraint>();\r\n\t\tconst initCons: number = this.#initTest(X2, cr);\r\n\t\tlet rc;\r\n\t\tlet initSol: AssignmentList | null = null;\r\n\r\n\t\tif (X3.size === 0) {\r\n\t\t\trc = initCons;\r\n\t\t\tinitSol = AssignmentList.fromVariables(X2);\r\n\t\t} else {\r\n\t\t\trc = this.#lb;\r\n\t\t}\r\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr).union(X3);\r\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\r\n\t\tlet result: number = this.#flcVariables(X1, X2p, X3p, this.#lt, this.#lt, rc);\r\n\t\tif (result < rc) {\r\n\t\t\tif (initSol !== null) {\r\n\t\t\t\tinitSol.apply();\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult = this.pro.degree();\r\n\t\treturn result > wsd && result > 0 && (this.#globalReturn !== 0 || this.targetDeg === null);\r\n\t}\r\n\r\n}\r\n\r\nfunction cloneAndAdd<T>(s: Set<T>, e: T): Set<T> {\r\n\treturn new Set<T>(s).add(e);\r\n}\r\n\r\nfunction cloneAndDelete<T>(s: Set<T>, e: T): Set<T> {\r\n\tconst sn = new Set<T>(s);\r\n\tsn.delete(e);\r\n\treturn sn;\r\n}\r\n", "/**\r\n * A class that implements the flexible local changes method.\r\n * The implementation is optimized by converting recursive calls to loops.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-23\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class FlexibleLocalChangesEx extends Solver {\r\n\r\n\t#lt: number = 0;\r\n\t#lb: number = 0;\r\n\r\n\t#globalReturn: number = 0;\r\n\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\t\tthis.#computeHighestAndLowestConsistencyDegree();\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Flexible Local Changes Ex';\r\n\t}\r\n\r\n\t#choose(x2: Set<Variable>, cr: Set<Constraint>): Set<Variable> {\r\n\t\tconst res = new Map<Variable, number>();\r\n\r\n\t\tfor (const c of cr) {\r\n\t\t\tif (!c.isDefined()) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (const x of c) {\r\n\t\t\t\tif (!res.has(x)) {\r\n\t\t\t\t\tres.set(x, 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tres.set(x, (res.get(x) ?? 0) + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst xs: Variable[] = [...x2];\r\n\t\txs.sort((o1: Variable, o2: Variable): -1 | 0 | 1 => {\r\n\t\t\tlet res1: number = 0;\r\n\t\t\tlet res2: number = 0;\r\n\t\t\tif (res.has(o1)) res1 = res.get(o1) ?? 0;\r\n\t\t\tif (res.has(o2)) res2 = res.get(o2) ?? 0;\r\n\r\n\t\t\tif (res1 < res2) return 1;\r\n\t\t\tif (res1 > res2) return -1;\r\n\t\t\treturn 0;\r\n\t\t});\r\n\r\n\t\tconst ret = new Set<Variable>();\r\n\r\n\t\tfor (const x of xs) {\r\n\t\t\tlet remain: boolean = false;\r\n\t\t\tfor (const c of cr) {\r\n\t\t\t\tif (c.isDefined()) {\r\n\t\t\t\t\tremain = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!remain) break;\r\n\t\t\tx.clear();\r\n\t\t\tret.add(x);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#computeHighestAndLowestConsistencyDegree(): void {\r\n\t\tlet low : number = 1;\r\n\t\tlet high: number = 0;\r\n\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tconst l: number = c.lowestConsistencyDegree();\r\n\t\t\t\tconst h: number = c.highestConsistencyDegree();\r\n\t\t\t\tif (l < low) low = l;\r\n\t\t\t\tif (h > high) high = h;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.#lb = low;\r\n\t\tthis.#lt = high;\r\n\t}\r\n\r\n\t#flcRepair(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>, rc: number): number {\r\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr);\r\n\t\tconst X1p: Set<Variable> = cloneAndAdd(X1, xi);\r\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\r\n\t\treturn this.#flcVariables(X1p, X2p, X3p, consX1xi, Math.min(consX12, consX1xi), rc);\r\n\t}\r\n\r\n\t#flcVariable(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1: number, consX12: number, rc: number): number {\r\n\t\tlet bestCons: number = this.#lb;\r\n\t\tif (xi.domain().size() === 0) {\r\n\t\t\treturn bestCons;\r\n\t\t}\r\n\t\tlet bestX2: AssignmentList = AssignmentList.fromVariables(X2);\r\n\t\tlet bestDij: number = xi.domain().at(0);\r\n\r\n\t\tconst x2Store: AssignmentList = AssignmentList.fromVariables(X2);\r\n\r\n\t\tfor (let j: number = 0; j < xi.domain().size() && bestCons < consX12; ++j) {\r\n\t\t\tconst dij: number = xi.domain().at(j);\r\n\t\t\txi.assign(dij);\r\n\t\t\tconst consX1_xi: number = Math.min(consX1, this.#testX1(X1, xi, bestCons, rc));\r\n\r\n\t\t\tif (consX1_xi > Math.max(bestCons, rc)) {\r\n\t\t\t\tconst crNew = new Set<Constraint>();\r\n\t\t\t\tconst consX12_xi: number = Math.min(Math.min(consX1_xi, consX12), this.#testX12(X1, X2, xi, consX1_xi, consX12, crNew));\r\n\r\n\t\t\t\tif (consX12_xi > bestCons) {\r\n\t\t\t\t\tbestCons = consX12_xi;\r\n\t\t\t\t\tbestDij = dij;\r\n\t\t\t\t\tbestX2 = AssignmentList.fromVariables(X2);\r\n\t\t\t\t}\r\n\t\t\t\tif (crNew.size) {\r\n\t\t\t\t\tconst repairCons: number = this.#flcRepair(X1, X2, xi, consX1_xi, consX12, crNew, Math.max(rc, bestCons));\r\n\t\t\t\t\tif (this.#globalReturn !== -1) {\r\n\t\t\t\t\t\treturn bestCons;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (repairCons > bestCons) {\r\n\t\t\t\t\t\tbestCons = repairCons;\r\n\t\t\t\t\t\tbestDij = dij;\r\n\t\t\t\t\t\tbestX2 = AssignmentList.fromVariables(X2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx2Store.apply();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbestX2.apply();\r\n\t\txi.assign(bestDij);\r\n\t\treturn bestCons;\r\n\t}\r\n\r\n\t#flcVariables(X1: Set<Variable>, X2: Set<Variable>, X3: Set<Variable>, consX1: number, consX12: number, rc: number): number {\r\n\t\tX2 = new Set<Variable>(X2);  // Clone\r\n\t\tX3 = new Set<Variable>(X3);  // Clone\r\n\r\n\t\twhile (true) {\r\n\t\t\tthis.monitor.outputDebugString(`X1 ${X1.size}, X2' ${X2.size}, X3' ${X3.size}`);\r\n\r\n\t\t\tconst ret: boolean | null = this.monitor.check(this.pro.degree());\r\n\t\t\tif (ret !== null) {\r\n\t\t\t\tthis.#globalReturn = ret ? 1 : 0;\r\n\t\t\t\treturn consX12;\r\n\t\t\t}\r\n\t\t\tif (X3.size === 0) {\r\n\t\t\t\treturn consX12;\r\n\t\t\t}\r\n\t\t\tconst xi = X3.values().next().value as Variable;\r\n\t\t\tconst consX12xi: number = this.#flcVariable(X1, X2, xi, consX1, consX12, rc);\r\n\r\n\t\t\tif (this.#globalReturn !== -1) {\r\n\t\t\t\treturn consX12;\r\n\t\t\t}\r\n\t\t\tif (consX12xi < rc) {\r\n\t\t\t\treturn this.#lb;\r\n\t\t\t}\r\n\t\t\tX2.add(xi);\r\n\t\t\tX3.delete(xi);\r\n\t\t\tconsX12 = consX12xi;\r\n\t\t}\r\n\t}\r\n\r\n\t#initTest(X: Set<Variable>, cr: Set<Constraint>): number {\r\n\t\tconst cs = new Set<Constraint>();\r\n\r\n\t\tfor (const x of X) {\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tcs.add(c);  // All variables in X have been assigned.\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet ret: number = 1;\r\n\t\tfor (const c of cs) {\r\n\t\t\tconst sd: number = c.degree();\r\n\t\t\tif (sd === Constraint.UNDEFINED) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (sd < ret) {\r\n\t\t\t\tret = sd;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const c of this.pro.constraints()) {\r\n\t\t\tconst cd: number = c.lowestConsistencyDegree();\r\n\t\t\tif (cd < this.#lt) {\r\n\t\t\t\tcr.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#testX1(X1: Set<Variable>, xi: Variable, bestCons: number, rc: number): number {\r\n\t\tlet cd: number = 1;\r\n\t\tconst cs = new Set<Constraint>();\r\n\r\n\t\tfor (const x of X1) {\r\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xi);\r\n\t\t\tfor (const c of temp) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const c of cs) {\r\n\t\t\tconst d: number = c.degree();\r\n\t\t\tif (d === Constraint.UNDEFINED) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (d < cd) {\r\n\t\t\t\tcd = d;\r\n\t\t\t}\r\n\t\t\t// If it is determined that a better solution than the current solution cannot be obtained\r\n\t\t\tif (cd <= bestCons || cd <= rc) {\r\n\t\t\t\treturn cd;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cd;\r\n\t}\r\n\r\n\t#testX12(X1: Set<Variable>, X2: Set<Variable>, xi: Variable, consX1xi: number, consX12: number, cr: Set<Constraint>): number {\r\n\t\tlet csd: number = 1;\r\n\t\tconst cs = new Set<Constraint>();\r\n\r\n\t\tfor (const x of X1) {\r\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xi);\r\n\t\t\tfor (const c of temp) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const x of X2) {\r\n\t\t\tconst temp: Constraint[] = this.pro.constraintsBetween(x, xi);\r\n\t\t\tfor (const c of temp) {\r\n\t\t\t\tcs.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const c of cs) {\r\n\t\t\tconst sd: number = c.degree();\r\n\t\t\tif (sd === Constraint.UNDEFINED) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (sd < csd) {\r\n\t\t\t\tcsd = sd;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const c of cs) {\r\n\t\t\tconst sd: number = c.degree();\r\n\t\t\tif (sd === Constraint.UNDEFINED) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (sd < consX1xi || sd < consX12) {\r\n\t\t\t\tcr.add(c);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn csd;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tthis.monitor.initialize();\r\n\t\tthis.#globalReturn = -1;\r\n\r\n\t\tconst wsd: number = this.pro.degree();\r\n\t\tif (this.pro.emptyVariableSize() === 0) {\r\n\t\t\tthis.pro.clearAllVariables();\r\n\t\t}\r\n\t\tconst X1 = new Set<Variable>();\r\n\t\tconst X2 = new Set<Variable>();  // Currently assigned variables.\r\n\t\tconst X3 = new Set<Variable>();  // Currently unassigned variables.\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\t(!x.isEmpty() ? X2 : X3).add(x);\r\n\t\t}\r\n\r\n\t\tconst cr = new Set<Constraint>();\r\n\t\tconst initCons: number = this.#initTest(X2, cr);\r\n\t\tlet rc;\r\n\t\tlet initSol: AssignmentList | null = null;\r\n\r\n\t\tif (X3.size === 0) {\r\n\t\t\trc = initCons;\r\n\t\t\tinitSol = AssignmentList.fromVariables(X2);\r\n\t\t} else {\r\n\t\t\trc = this.#lb;\r\n\t\t}\r\n\t\tconst X3p: Set<Variable> = this.#choose(X2, cr).union(X3);\r\n\t\tconst X2p: Set<Variable> = X2.difference(X3p);\r\n\t\tlet result: number = this.#flcVariables(X1, X2p, X3p, this.#lt, this.#lt, rc);\r\n\t\tif (result < rc) {\r\n\t\t\tif (initSol !== null) {\r\n\t\t\t\tinitSol.apply();\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult = this.pro.degree();\r\n\t\treturn result > wsd && result > 0 && (this.#globalReturn !== 0 || this.targetDeg === null);\r\n\t}\r\n\r\n}\r\n\r\nfunction cloneAndAdd<T>(s: Set<T>, e: T): Set<T> {\r\n\treturn new Set<T>(s).add(e);\r\n}\r\n", "/**\r\n * Class implements a solver using the breakout method for fuzzy CSP.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-22\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { Assignment } from '../../util/assignment';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class FuzzyBreakout extends Solver {\r\n\r\n\t#isRandom: boolean = true;\r\n\t#ws      : number[];\r\n\r\n\t/**\r\n\t * Generates a solver given a constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\r\n\t\tthis.#ws = new Array(this.pro.constraintSize());\r\n\t\tthis.#ws.fill(1);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Fuzzy Breakout';\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the randomness of the algorithm.\r\n\t * Enabling randomness reduces the risk of local solutions, but makes the solution unrepeatable.\r\n\t * @param flag Whether the randomness is enabled.\r\n\t */\r\n\tsetRandomness(flag: boolean): void {\r\n\t\tthis.#isRandom = flag;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\tif (x.isEmpty()) {\r\n\t\t\t\tx.assign(x.domain().at(0));\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst defEv: number         = this.pro.degree();\r\n\t\tconst sol  : AssignmentList = new AssignmentList();\r\n\t\tlet solEv  : number         = defEv;\r\n\r\n\t\tthis.monitor.initialize();\r\n\r\n\t\tconst canList = new AssignmentList();\r\n\t\tlet ret: boolean | null = null;\r\n\r\n\t\twhile (true) {\r\n\t\t\tconst [cs, ev] = this.pro.constraintsWithDegree();\r\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\r\n\r\n\t\t\tif (solEv < ev) {\r\n\t\t\t\tsol.setProblem(this.pro);\r\n\t\t\t\tsolEv = ev;\r\n\r\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tthis.#next(cs, canList);\r\n\t\t}\r\n\r\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\r\n\t\t\tsol.apply();\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#next(cs: Constraint[], canList: AssignmentList): void {\r\n\t\tthis.#findCandidates(this.#listTargetVariables(cs), canList);\r\n\r\n\t\tif (0 < canList.size()) {\r\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\r\n\t\t\ta.apply();\r\n\t\t\tcanList.clear();\r\n\t\t\tthis.monitor.outputDebugString('\\t' + a);\r\n\t\t} else {\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tthis.#ws[c.index()] += 1;\r\n\t\t\t}\r\n\t\t\tthis.monitor.outputDebugString('Breakout');\r\n\t\t}\r\n\t}\r\n\r\n\t#findCandidates(tarXs: Variable[], canList: AssignmentList): void {\r\n\t\tlet maxDiff: number = 0;\r\n\r\n\t\tfor (const x of tarXs) {\r\n\t\t\tconst x_v: number = x.value();  // Save the value\r\n\r\n\t\t\tlet nowEv: number = 0;\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tnowEv += (1 - c.degree()) * this.#ws[c.index()];\r\n\t\t\t}\r\n\t\t\tout: for (const v of x.domain()) {\r\n\t\t\t\tif (x_v === v) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tx.assign(v);\r\n\t\t\t\tlet diff: number = nowEv;\r\n\r\n\t\t\t\tfor (const c of x) {\r\n\t\t\t\t\tdiff -= (1 - c.degree()) * this.#ws[c.index()];\r\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\r\n\t\t\t\t\tif (diff < maxDiff) {\r\n\t\t\t\t\t\tcontinue out;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (maxDiff < diff) {  // An assignment that are better than ever before is found.\r\n\t\t\t\t\tmaxDiff = diff;\r\n\t\t\t\t\tcanList.clear();\r\n\t\t\t\t\tcanList.addVariable(x, v);\r\n\t\t\t\t} else if (maxDiff !== 0) {  // An assignments that can be improved to the same level as before is found.\r\n\t\t\t\t\tcanList.addVariable(x, v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tx.assign(x_v);  // Restore the value.\r\n\t\t}\r\n\t}\r\n\r\n\t#listTargetVariables(tarCs: Constraint[]): Variable[] {\r\n\t\tconst xs = new Set<Variable>();\r\n\r\n\t\tfor (const c of tarCs) {\r\n\t\t\tfor (const x of c) {\r\n\t\t\t\txs.add(x);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Array.from<Variable>(xs);\r\n\t}\r\n\r\n}\r\n", "/**\r\n * This class implements fuzzy GENET.\r\n * CSPs and FCSPs (but only Binary (F)CSPs) is supported.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-21\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class FuzzyGENET extends Solver {\r\n\r\n\t#clusters   : Cluster[]    = [];\r\n\t#connections: Connection[] = [];\r\n\t#degree     : number;\r\n\r\n\t/**\r\n\t * Generates a solver given a constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem, degree: number = 1) {\r\n\t\tsuper(p);\r\n\t\tthis.#degree = degree;\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'Fuzzy GENET';\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tif (!this.#createNetwork()) {\r\n\t\t\tthrow new Error();\r\n\t\t}\r\n\t\tconst order: number[] = [...Array(this.#clusters.length).keys()];\r\n\r\n\t\tconst defEv: number         = this.pro.degree();\r\n\t\tconst sol  : AssignmentList = new AssignmentList();\r\n\t\tlet solEv  : number         = defEv;\r\n\r\n\t\tthis.monitor.initialize();\r\n\r\n\t\tlet ret: boolean | null = null;\r\n\r\n\t\twhile(true) {\r\n\t\t\tconst ev: number = this.pro.degree();\r\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\r\n\r\n\t\t\tif (solEv < ev) {\r\n\t\t\t\tsol.setProblem(this.pro);\r\n\t\t\t\tsolEv = ev;\r\n\r\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tthis.#next(order);\r\n\t\t}\r\n\r\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\r\n\t\t\tsol.apply();\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#createNetwork(): boolean {\r\n\t\tthis.monitor.outputDebugString('Start of Network Generation');\r\n\t\tconst cons: Connection[] = [];\r\n\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\tif (x.domain().size() === 0) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tthis.#clusters.push(new Cluster(x));\r\n\t\t}\r\n\t\tfor (const c of this.pro.constraints()) {\r\n\t\t\tif (c.size() === 1) {  // In the case of unary constraints.\r\n\t\t\t\tconst x: Variable = c.at(0) as Variable;\r\n\t\t\t\tconst cl: Cluster = this.#clusters[x.index()];\r\n\r\n\t\t\t\tfor (const n of cl) {\r\n\t\t\t\t\tconst origV: number = x.value();  // Save the value.\r\n\t\t\t\t\tx.assign(n._value);\r\n\r\n\t\t\t\t\tif (c.degree() <= this.#degree) {\r\n\t\t\t\t\t\tcons.push(new Connection(c, n));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx.assign(origV);  // Restore the value.\r\n\t\t\t\t}\r\n\t\t\t} else {  // In the case of binary constraints.\r\n\t\t\t\tconst x1: Variable  = c.at(0) as Variable;\r\n\t\t\t\tconst x2: Variable  = c.at(1) as Variable;\r\n\t\t\t\tconst cl_f: Cluster = this.#clusters[x1.index()];\r\n\t\t\t\tconst cl_s: Cluster = this.#clusters[x2.index()];\r\n\r\n\t\t\t\tfor (const n_f of cl_f) {\r\n\t\t\t\t\tconst origV1: number = x1.value();  // Save the value.\r\n\t\t\t\t\tx1.assign(n_f._value);\r\n\r\n\t\t\t\t\tfor (const n_s of cl_s) {\r\n\t\t\t\t\t\tconst origV2: number = x2.value();  // Save the value.\r\n\t\t\t\t\t\tx2.assign(n_s._value);\r\n\r\n\t\t\t\t\t\tif (c.degree() <= this.#degree) {\r\n\t\t\t\t\t\t\tcons.push(new Connection(c, n_f, n_s));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tx2.assign(origV2);  // Restore the value.\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx1.assign(origV1);  // Restore the value.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const cl of this.#clusters) {\r\n\t\t\tfor (const n of cl._neurons) {\r\n\t\t\t\tn.lockConnections();\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.#connections = cons;\r\n\t\tthis.monitor.outputDebugString('End of Network Generation');\r\n\t\treturn true;\r\n\t}\r\n\r\n\t#next(order: number[]): void {\r\n\t\tlet mod: boolean = false;\r\n\t\tfor (const i of this.#shuffle(order)) {\r\n\t\t\tif (this.#clusters[i].setActivityMaximumInput()) {\r\n\t\t\t\tmod = true; // Turn on the node with the largest input in each cluster\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!mod) { // When the local minimum solution is reached.\r\n\t\t\tfor (const con of this.#connections) {\r\n\t\t\t\tcon.refreshWeight(); // Update weights for all connections\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (const clu of this.#clusters) {\r\n\t\t\t\tclu.applyToVariable();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t#shuffle(is: number[]): number[] {\r\n\t\tfor (let i: number = is.length; i > 1; --i) {\r\n\t\t\tconst j   : number = nextInt(i);\r\n\t\t\tconst temp: number = is[i - 1];\r\n\t\t\tis[i - 1] = is[j];\r\n\t\t\tis[j]     = temp;\r\n\t\t}\r\n\t\treturn is;\r\n\t}\r\n\r\n}\r\n\r\nclass Cluster {\r\n\r\n\t#x         : Variable;  // For avoiding a bug(?) of parcel.\r\n\t#index     : number   = 0;\r\n\t#maxNeurons: number[] = [];\r\n\t_neurons   : Neuron[] = [];\r\n\r\n\tconstructor(x: Variable) {\r\n\t\tthis.#x = x;\r\n\r\n\t\tfor (const v of x.domain()) {\r\n\t\t\tthis._neurons.push(new Neuron(v));\r\n\t\t}\r\n\t\tthis.#setActivity(nextInt(this._neurons.length));\r\n\t}\r\n\r\n\t#setActivity(index: number): void {\r\n\t\tfor (const n of this._neurons) {\r\n\t\t\tn._isActive = false;\r\n\t\t}\r\n\t\tthis._neurons[index]._isActive = true;\r\n\t\tthis.#index = index;\r\n\t}\r\n\r\n\tapplyToVariable(): void {\r\n\t\tthis.#x.assign(this._neurons[this.#index]._value);\r\n\t}\r\n\r\n\t// Turn on the node with the largest input.\r\n\tsetActivityMaximumInput(): boolean {\r\n\t\tthis.#maxNeurons.length = 0;\r\n\r\n\t\tlet max: number = Number.NEGATIVE_INFINITY;\r\n\t\tlet alreadyOn: boolean = false;\r\n\r\n\t\tfor (let i: number = 0; i < this._neurons.length; ++i) {\r\n\t\t\tconst input: number = this._neurons[i].getInput();\r\n\r\n\t\t\tif (max <= input) {\r\n\t\t\t\tif (max < input) {\r\n\t\t\t\t\tmax = input;\r\n\t\t\t\t\tthis.#maxNeurons.length = 0;\r\n\t\t\t\t\talreadyOn = false;\r\n\t\t\t\t}\r\n\t\t\t\tthis.#maxNeurons.push(i);\r\n\t\t\t\tif (this.#index === i) {\r\n\t\t\t\t\talreadyOn = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (alreadyOn || this.#maxNeurons.length === 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tthis.#setActivity(this.#maxNeurons[nextInt(this.#maxNeurons.length)]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t[Symbol.iterator](): Iterator<Neuron> {\r\n\t\treturn this._neurons[Symbol.iterator]();\r\n\t}\r\n\r\n}\r\n\r\nclass Connection {\r\n\r\n\t#c     : Constraint;\r\n\t#first : Neuron;\r\n\t#second: Neuron | null;\r\n\t_weight: number;  // Direct reference (read) allowed.\r\n\r\n\t// Order of neurons must be the same as the order of variables that the constraint has.\r\n\tconstructor(c: Constraint, first: Neuron, second: Neuron | null = null) {\r\n\t\tthis.#c      = c;\r\n\t\tthis.#first  = first;\r\n\t\tthis.#second = second;\r\n\t\tthis._weight = c.degree() - 1;\r\n\r\n\t\tthis.#first.addConnection(this);\r\n\t\tif (this.#second) {\r\n\t\t\tthis.#second.addConnection(this);\r\n\t\t}\r\n\t}\r\n\r\n\tgetNeuron(self: Neuron): Neuron | null {\r\n\t\tif (self === this.#first) return this.#second;\r\n\t\tif (self === this.#second) return this.#first;\r\n\t\treturn null;\r\n\t}\r\n\r\n\trefreshWeight(): void {\r\n\t\tif (!this.#first._isActive || (this.#second !== null && !this.#second._isActive)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.#c.size() === 1) {\r\n\t\t\tthis._weight += (this.#c.relation().degree(this.#first._value) - 1);\r\n\t\t} else {\r\n\t\t\tthis._weight += (this.#c.relation().degree(this.#first._value, (this.#second as Neuron)._value) - 1);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\nclass Neuron {\r\n\r\n\t#connections: Connection[] = [];\r\n\t#conTemp    : Connection[] | null = [];\r\n\r\n\t_value   : number;  // Direct reference (read) allowed.\r\n\t_isActive: boolean = false;  // Direct reference (read, write) allowed.\r\n\r\n\tconstructor(value: number) {\r\n\t\tthis._value = value;\r\n\t}\r\n\r\n\taddConnection(c: Connection): void {\r\n\t\t(this.#conTemp as Connection[]).push(c);\r\n\t}\r\n\r\n\tlockConnections(): void {\r\n\t\tthis.#connections = [...this.#conTemp as Connection[]];\r\n\t\tthis.#conTemp     = null;  // No longer being used.\r\n\t}\r\n\r\n\tgetInput(): number {\r\n\t\tlet ret: number = 0;\r\n\r\n\t\tfor (const c of this.#connections) {\r\n\t\t\tconst n: Neuron | null = c.getNeuron(this);  // If n is null, then the unary constraint.\r\n\t\t\tret += c._weight * ((n === null || n._isActive) ? 1 : 0);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n}\r\n\r\nfunction nextInt(max: number): number {\r\n\treturn Math.floor(Math.random() * Math.floor(max));\r\n}\r\n", "/**\r\n * This class implements the SRS3 algorithm.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-23\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { Assignment } from '../../util/assignment';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\nexport class SRS3 extends Solver {\r\n\r\n\t#isRandom: boolean = true;\r\n\t#ws      : number[];\r\n\r\n\t#closedList: Set<TreeNode> = new Set();\r\n\t#openList  : Set<TreeNode> = new Set();  // LinkedHashSet is used in the original implementation.\r\n\t#nodes     : TreeNode[] = [];\r\n\t#neighbors : (TreeNode[] | null)[] = [];  // Cache\r\n\r\n\t/**\r\n\t * Generates a solver given a constraint satisfaction problem.\r\n\t * @param p A problem.\r\n\t */\r\n\tconstructor(p: Problem) {\r\n\t\tsuper(p);\r\n\r\n\t\tfor (const c of this.pro.constraints()) {\r\n\t\t\tthis.#nodes.push(new TreeNode(c));\r\n\t\t\tthis.#neighbors.push(null);\r\n\t\t}\r\n\t\tthis.#ws = new Array(this.pro.constraintSize());\r\n\t\tthis.#ws.fill(1);\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn 'SRS3';\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the randomness of the algorithm.\r\n\t * Enabling randomness reduces the risk of falling into a local solution, but makes the solution unrepeatable.\r\n\t * @param flag If true, randomness is enabled.\r\n\t */\r\n\tsetRandomness(flag: boolean): void {\r\n\t\tthis.#isRandom = flag;\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tfor (const x of this.pro.variables()) {\r\n\t\t\tif (x.isEmpty()) {\r\n\t\t\t\tx.assign(x.domain().at(0));\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst defEv: number         = this.pro.degree();\r\n\t\tconst sol  : AssignmentList = new AssignmentList();\r\n\t\tlet solEv  : number         = defEv;\r\n\r\n\t\tthis.monitor.initialize();\r\n\r\n\t\tlet ret: boolean | null = null;\r\n\r\n\t\twhile (true) {\r\n\t\t\tconst [cs, ev] = this.pro.constraintsWithDegree();\r\n\t\t\tthis.monitor.outputDebugString(`Evaluation: ${ev}`);\r\n\r\n\t\t\tif (solEv < ev) {\r\n\t\t\t\tsol.setProblem(this.pro);\r\n\t\t\t\tsolEv = ev;\r\n\r\n\t\t\t\tif (this.monitor.solutionFound(sol, solEv)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (null !== (ret = this.monitor.check(ev))) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tfor (const tn of this.#nodes) {\r\n\t\t\t\ttn.clear();\r\n\t\t\t}\r\n\t\t\tconst c_stars = new Set<TreeNode>();\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tconst tn: TreeNode = this.#nodes[c.index()];\r\n\t\t\t\tc_stars.add(tn);\r\n\t\t\t}\r\n\t\t\tthis.#srs(c_stars);\r\n\t\t}\r\n\r\n\t\tif (false === ret && !this.monitor.isTargetAssigned() && defEv < solEv) {\r\n\t\t\tsol.apply();\r\n\t\t\tret = true;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t#srs(c_stars: Set<TreeNode>): boolean {\r\n\t\tthis.monitor.outputDebugString('SRS');\r\n\r\n\t\tthis.#closedList.clear();\r\n\t\tthis.#openList.clear();\r\n\t\tfor (const tn of c_stars) {\r\n\t\t\tthis.#openList.add(tn);\r\n\t\t}\r\n\r\n\t\twhile (c_stars.size && this.#openList.size) {\r\n\t\t\tconst node: TreeNode = this.#getElementFromSet(this.#openList);\r\n\t\t\tthis.#openList.delete(node);\r\n\r\n\t\t\tif (!this.#repair(node.constraint())) {\r\n\t\t\t\tthis.#spread(node);\r\n\t\t\t} else if (c_stars.delete(node)) {\r\n\t\t\t\t// If the repaired node is included in C* (to be deleted)\r\n\t\t\t} else if (node.parent() && this.#repair((node.parent() as TreeNode).constraint())) {\r\n\t\t\t\tthis.#shrink(node, c_stars);  // When its improvement leads to the improvement of its parents\r\n\t\t\t} else {\r\n\t\t\t\tthis.#spread(node);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn c_stars.size === 0;\r\n\t}\r\n\r\n\t#spread(tn: TreeNode): void {\r\n\t\tthis.monitor.outputDebugString('Spread');\r\n\t\tthis.#closedList.add(tn);\r\n\r\n\t\tfor (const n of this.#getNeighbors(tn)) {\r\n\t\t\t// For constraints that are not included in Open or Closed.\r\n\t\t\tif (!this.#closedList.has(n) && !this.#openList.has(n)) {\r\n\t\t\t\tn.clear();\r\n\t\t\t\ttn.append(n);\r\n\t\t\t\tthis.#openList.add(n);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// #repair(c0: Constraint): boolean {\r\n\t// \tthis.monitor.outputDebugString('Repair');\r\n\t// \tthis.#ws[c0.index()] += 1;\r\n\r\n\t// \tconst canList: AssignmentList = new AssignmentList();\r\n\t// \tconst defD0  : number         = c0.degree();  // Target c0 should certainly be an improvement over this.\r\n\r\n\t// \t// If a candidate satisfying the condition is stronger than the previous candidates,\r\n\t// \t// it is replaced, and if no candidate is found until the end, it fails.\r\n\t// \tfor (const x of c0) {\r\n\t// \t\tconst x_v: number = x.value();  // Save the value\r\n\r\n\t// \t\tout: for (const v of x.domain()) {\r\n\t// \t\t\tif (x_v === v) {\r\n\t// \t\t\t\tcontinue;\r\n\t// \t\t\t}\r\n\t// \t\t\tx.assign(v);\r\n\t// \t\t\tconst d0: number = c0.degree();\r\n\t// \t\t\t// If target c0 cannot be improved, the assignment is rejected.\r\n\t// \t\t\tif (d0 <= defD0) {\r\n\t// \t\t\t\tcontinue;\r\n\t// \t\t\t}\r\n\t// \t\t\tfor (const c of x) {\r\n\t// \t\t\t\tif (c === c0) {\r\n\t// \t\t\t\t\tcontinue;\r\n\t// \t\t\t\t}\r\n\t// \t\t\t\tconst d: number = c.degree();\r\n\t// \t\t\t\t// If one of the neighborhood constraints c is less than or equal to the worst, the assignment is rejected.\r\n\t// \t\t\t\tif (d < defD0) {\r\n\t// \t\t\t\t\tcontinue out;\r\n\t// \t\t\t\t}\r\n\t// \t\t\t}\r\n\t// \t\t\tcanList.addVariable(x, v);\r\n\t// \t\t}\r\n\t// \t\tx.assign(x_v);  // Restore the value\r\n\t// \t}\r\n\t// \tif (0 < canList.size()) {\r\n\t// \t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\r\n\t// \t\ta.apply();\r\n\t// \t\tthis.monitor.outputDebugString('\\t' + a);\r\n\t// \t\treturn true;\r\n\t// \t}\r\n\t// \treturn false;\r\n\t// }\r\n\r\n\t#repair(c0: Constraint): boolean {\r\n\t\tthis.monitor.outputDebugString('Repair');\r\n\t\tthis.#ws[c0.index()] += 1;\r\n\r\n\t\tconst defD0: number = c0.degree();  // Target c0 should certainly be an improvement over this.\r\n\t\tconst canList = new AssignmentList();\r\n\t\tlet maxDiff: number = 0;\r\n\r\n\t\tfor (const x of c0) {\r\n\t\t\tconst x_v: number = x.value();  // Save the value\r\n\r\n\t\t\tlet nowEv: number = 0;\r\n\t\t\tfor (const c of x) {\r\n\t\t\t\tnowEv += (1 - c.degree()) * this.#ws[c.index()];\r\n\t\t\t}\r\n\t\t\tout: for (const v of x.domain()) {\r\n\t\t\t\tif (x_v === v) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tx.assign(v);\r\n\t\t\t\tif (c0.degree() <= defD0) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tlet diff: number = nowEv;\r\n\r\n\t\t\t\tfor (const c of x) {\r\n\t\t\t\t\tdiff -= (1 - c.degree()) * this.#ws[c.index()];\r\n\t\t\t\t\t// If the improvement is less than the previous improvement, try the next variable.\r\n\t\t\t\t\tif (diff < maxDiff) {\r\n\t\t\t\t\t\tcontinue out;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (maxDiff < diff) {  // An assignment that are better than ever before is found.\r\n\t\t\t\t\tmaxDiff = diff;\r\n\t\t\t\t\tcanList.clear();\r\n\t\t\t\t\tcanList.addVariable(x, v);\r\n\t\t\t\t} else if (maxDiff !== 0) {  // An assignments that can be improved to the same level as before is found.\r\n\t\t\t\t\tcanList.addVariable(x, v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tx.assign(x_v);  // Restore the value\r\n\t\t}\r\n\t\tif (0 < canList.size()) {\r\n\t\t\tconst a: Assignment = this.#isRandom ? canList.random() : canList.at(0);\r\n\t\t\ta.apply();\r\n\t\t\tthis.monitor.outputDebugString('\\t' + a);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t#shrink(node: TreeNode, c_stars: Set<TreeNode>): void {\r\n\t\tthis.monitor.outputDebugString('Shrink');\r\n\r\n\t\tlet cur         : TreeNode = node;\r\n\t\tlet curIsRemoved: boolean  = false;\r\n\r\n\t\twhile (true) {\r\n\t\t\tcur = cur.parent() as TreeNode;\r\n\t\t\tif (c_stars.delete(cur)) {\r\n\t\t\t\tcurIsRemoved = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (!cur.parent() || !this.#repair((cur.parent() as TreeNode).constraint())) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst temp: TreeNode[] = [];\r\n\t\tcur.getDescendants(temp);  // temp contains node.\r\n\t\tcur.clear();  // Prepare for reuse\r\n\r\n\t\tfor (const n of temp) {\r\n\t\t\tthis.#openList.delete(n);\r\n\t\t\tthis.#closedList.delete(n);\r\n\t\t}\r\n\t\tif (!curIsRemoved) {\r\n\t\t\tthis.#openList.add(cur);\r\n\t\t}\r\n\t}\r\n\r\n\t// #shrink(node: TreeNode, c_stars: Set<TreeNode>): void {\r\n\t// \tthis.debugOutput('Shrink');\r\n\r\n\t// \tconst temp: TreeNode[] = [];\r\n\t// \tlet cur: TreeNode = node;\r\n\r\n\t// \twhile (true) {  // This procedure is originally a recursive call, but converted to a loop\r\n\t// \t\tcur = cur.parent() as TreeNode;\r\n\t// \t\ttemp.length = 0;\r\n\t// \t\tcur.getDescendants(temp);\r\n\t// \t\tcur.clear();\r\n\r\n\t// \t\tfor (const n of temp) {\r\n\t// \t\t\tthis.#openList.delete(n);\r\n\t// \t\t\tthis.#closedList.delete(n);\r\n\t// \t\t}\r\n\t// \t\tif (c_stars.delete(cur)) {\r\n\t// \t\t} else {\r\n\t// \t\t\tthis.#openList.add(cur);\r\n\t// \t\t\tif (!cur.parent() || !this.#repair((cur.parent() as TreeNode).constraint())) {\r\n\t// \t\t\t\tbreak;\r\n\t// \t\t\t}\r\n\t// \t\t}\r\n\t// \t}\r\n\t// }\r\n\r\n\t#getNeighbors(tn: TreeNode): TreeNode[] {\r\n\t\tconst c: Constraint = tn.constraint();\r\n\t\tconst i: number     = c.index();\r\n\r\n\t\tif (this.#neighbors[i] === null) {\r\n\t\t\tconst ns: TreeNode[] = [];\r\n\t\t\tfor (const d of c.neighbors()) {\r\n\t\t\t\tns.push(this.#nodes[d.index()]);\r\n\t\t\t}\r\n\t\t\tthis.#neighbors[i] = ns;\r\n\t\t}\r\n\t\treturn this.#neighbors[i];\r\n\t}\r\n\r\n\t#getElementFromSet(set: Set<TreeNode>): TreeNode {\r\n\t\tconst ms : TreeNode[] = this.#selectLightestNode(this.#selectNearestNode(set));\r\n\t\treturn this.#isRandom ? ms[Math.floor(Math.random() * ms.length)] : ms[0];\r\n\t}\r\n\r\n\t#selectLightestNode(set: Iterable<TreeNode>): TreeNode[] {\r\n\t\tlet curW: number     = Number.MAX_VALUE;\r\n\t\tlet ms  : TreeNode[] = [];\r\n\r\n\t\tfor (const tn of set) {\r\n\t\t\tconst w: number = this.#ws[tn.constraint().index()];\r\n\t\t\tif (w < curW) {\r\n\t\t\t\tcurW = w;\r\n\t\t\t\tms.length = 0;\r\n\t\t\t\tms.push(tn);\r\n\t\t\t} else if (w === curW) {\r\n\t\t\t\tms.push(tn);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ms;\r\n\t}\r\n\r\n\t#selectNearestNode(set: Iterable<TreeNode>): TreeNode[] {\r\n\t\tlet curD: number     = Number.MAX_VALUE;\r\n\t\tlet ms  : TreeNode[] = [];\r\n\r\n\t\tfor (const tn of set) {\r\n\t\t\tconst d: number = tn.depth();\r\n\t\t\tif (d < curD) {\r\n\t\t\t\tcurD = d;\r\n\t\t\t\tms.length = 0;\r\n\t\t\t\tms.push(tn);\r\n\t\t\t} else if (d === curD) {\r\n\t\t\t\tms.push(tn);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ms;\r\n\t}\r\n\r\n}\r\n\r\nclass TreeNode {\r\n\r\n\t#c       : Constraint;\r\n\t#depth   : number = 0;\r\n\t#parent  : TreeNode | null = null;\r\n\t#children: TreeNode[] = [];\r\n\r\n\tconstructor(c: Constraint) {\r\n\t\tthis.#c = c;\r\n\t}\r\n\r\n\tappend(tn: TreeNode): void {\r\n\t\ttn.#parent = this;\r\n\t\ttn.#depth  = this.#depth + 1;\r\n\t\tthis.#children.push(tn);\r\n\t}\r\n\r\n\tclear(): void {\r\n\t\tthis.#parent = null;\r\n\t\tthis.#depth  = 0;\r\n\t\tfor (const tn of this.#children) {\r\n\t\t\ttn.clear();\r\n\t\t}\r\n\t\tthis.#children.length = 0;\r\n\t}\r\n\r\n\tconstraint(): Constraint {\r\n\t\treturn this.#c;\r\n\t}\r\n\r\n\tdepth(): number {\r\n\t\treturn this.#depth;\r\n\t}\r\n\r\n\tparent(): TreeNode | null {\r\n\t\treturn this.#parent;\r\n\t}\r\n\r\n\tgetDescendants(tns: TreeNode[]): void {\r\n\t\ttns.push(this);\r\n\r\n\t\tfor (const tn of this.#children) {\r\n\t\t\ttn.getDescendants(tns);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Class of post-stabilization.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-23\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Assignment } from '../../util/assignment';\r\nimport { AssignmentList } from '../../util/assignment-list';\r\nimport { Solver } from '../solver';\r\n\r\n/**\r\n * Apply post-stabilization.\r\n *\r\n * @param p    Problem.\r\n * @param orig Original assignment list.\r\n * @param log  Log function.\r\n */\r\nexport function applyPostStabilization(p: Problem, orig: AssignmentList, log: (e: string) => void = (e: string): void => console.log(e)): boolean {\r\n\tlog('Start Post-Stabilization');\r\n\r\n\tlet stabilized: boolean;\r\n\tlet count: number = 0;\r\n\r\n\tdo {\r\n\t\tlog('\\tPost-Stabilization: count ' + count++);\r\n\r\n\t\tstabilized = false;\r\n\t\tlet ev_min: number = p.degree();\r\n\r\n\t\tconst xs: Variable[] = p.variables();\r\n\t\tfor (let i: number = 0; i < xs.length; ++i) {\r\n\t\t\tconst x: Variable = xs[i];\r\n\t\t\tconst v: number   = x.value();\r\n\r\n\t\t\tconst a: Assignment = orig.at(i);\r\n\t\t\tif (v === a.value()) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\ta.apply();  // Try to assign the original.\r\n\t\t\tif (ev_min <= p.degree()) {\r\n\t\t\t\tstabilized = true;\r\n\t\t\t} else {\r\n\t\t\t\tx.assign(v);  // Restore.\r\n\t\t\t}\r\n\t\t}\r\n\t} while (stabilized);\r\n\r\n\tlog('Finish Post-Stabilization');\r\n\treturn stabilized;\r\n}\r\n\r\n/**\r\n * Wrap the solver with post-stabilizer.\r\n *\r\n * @param p      Problem.\r\n * @param solver Solver.\r\n * @return Wrapped solver.\r\n */\r\nexport function wrapWithPostStabilizer(p: Problem, solver: Solver): Solver {\r\n\treturn new PostStabilizerWrapper(p, solver);\r\n}\r\n\r\n/**\r\n * Class of post-stabilizer wrapper.\r\n */\r\nexport class PostStabilizerWrapper extends Solver {\r\n\r\n\t#solver: Solver;\r\n\r\n\tconstructor(p: Problem, solver: Solver) {\r\n\t\tsuper(p);\r\n\t\tthis.#solver = solver;\r\n\t\tthis.setMonitor(solver.getMonitor());\r\n\t}\r\n\r\n\tname(): string {\r\n\t\treturn this.#solver.name() + ' + PF';\r\n\t}\r\n\r\n\texec(): boolean {\r\n\t\tlet ev : number = 0;\r\n\t\tlet evs: number = 0;\r\n\t\tif (this.monitor.isDebugMode()) {\r\n\t\t\tev  = this.pro.isFuzzy() ? this.pro.degree() : this.pro.ratio();\r\n\t\t\tevs = this.pro.emptyVariableSize();\r\n\t\t}\r\n\t\tconst orig = new AssignmentList();\r\n\t\torig.setProblem(this.pro);\r\n\r\n\t\tconst res: boolean = this.#solver.exec();\r\n\t\tif (res) {\r\n\t\t\tapplyPostStabilization(this.pro, orig, this.monitor.outputDebugString.bind(this.monitor));\r\n\t\t}\r\n\t\tthis.monitor.outputDebugString(`Solver result: ${res ? 'Success' : 'Failure'}`);\r\n\t\tthis.monitor.outputDebugString(`Evaluation: ${ev} -> ${this.pro.isFuzzy() ? this.pro.degree() : this.pro.ratio()}`);\r\n\t\tthis.monitor.outputDebugString(`Empty variable size: ${evs} -> ${this.pro.emptyVariableSize()}`);\r\n\t\treturn res;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Solver factory class.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-27\r\n */\r\n\r\nimport { Solver } from './solver';\r\nimport { Problem } from '../problem/problem';\r\n\r\nimport { ForwardChecking } from './crisp/forward-checking';\r\nimport { MaxForwardChecking } from './crisp/max-forward-checking';\r\nimport { LocalChanges } from './crisp/local-changes';\r\nimport { LocalChangesEx } from './crisp/local-changes-ex';\r\nimport { Breakout } from './crisp/breakout';\r\nimport { GENET } from './crisp/genet';\r\nimport { CrispSRS3 } from './crisp/crisp-srs3';\r\nimport { FullChecking } from './fuzzy/full-checking';\r\nimport { FuzzyForwardChecking } from './fuzzy/fuzzy-forward-checking';\r\nimport { FlexibleLocalChanges } from './fuzzy/flexible-local-changes';\r\nimport { FlexibleLocalChangesEx } from './fuzzy/flexible-local-changes-ex';\r\nimport { FuzzyBreakout } from './fuzzy/fuzzy-breakout';\r\nimport { FuzzyGENET } from './fuzzy/fuzzy-genet';\r\nimport { SRS3 } from './fuzzy/srs3';\r\nimport { wrapWithPostStabilizer } from './filter/post-stabilizer.js';\r\n\r\nexport class SolverFactory {\r\n\r\n\tstatic crispSolverNames(): string[] {\r\n\t\treturn [\r\n\t\t\t/* 0 */ 'Forward Checking',\r\n\t\t\t/* 1 */ 'Max Forward Checking',\r\n\t\t\t/* 2 */ 'Local Changes',\r\n\t\t\t/* 3 */ 'Local Changes Ex',\r\n\t\t\t/* 4 */ 'Breakout',\r\n\t\t\t/* 5 */ 'GENET',\r\n\t\t\t/* 6 */ 'Crisp SRS3',\r\n\t\t];\r\n\t}\r\n\r\n\tstatic fuzzySolverNames(): string[] {\r\n\t\treturn [\r\n\t\t\t/* 0 */ 'Full Checking',\r\n\t\t\t/* 1 */ 'Fuzzy Forward Checking',\r\n\t\t\t/* 2 */ 'Flexible Local Changes',\r\n\t\t\t/* 3 */ 'Flexible Local Changes Ex',\r\n\t\t\t/* 4 */ 'Fuzzy Breakout',\r\n\t\t\t/* 5 */ 'Fuzzy GENET',\r\n\t\t\t/* 6 */ 'SRS3',\r\n\t\t\t/* 7 */ 'SRS3 PF',\r\n\t\t];\r\n\t}\r\n\r\n\tstatic async createSolver(type: string, p: Problem): Promise<Solver | null> {\r\n\t\tconst cs: Solver | null = await SolverFactory.createCrispSolver(type, p);\r\n\t\tif (cs) {\r\n\t\t\treturn cs;\r\n\t\t}\r\n\t\tconst fs: Solver | null = await SolverFactory.createFuzzySolver(type, p);\r\n\t\tif (fs) {\r\n\t\t\treturn fs;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tstatic async createCrispSolver(type: string, p: Problem): Promise<Solver | null> {\r\n\t\tswitch (type.replaceAll(' ', '')) {\r\n\t\t\tcase 'ForwardChecking':\r\n\t\t\tcase 'forward-checking':\r\n\t\t\t\treturn new ForwardChecking(p);\r\n\t\t\tcase 'MaxForwardChecking':\r\n\t\t\tcase 'max-forward-checking':\r\n\t\t\t\treturn new MaxForwardChecking(p);\r\n\t\t\tcase 'LocalChanges':\r\n\t\t\tcase 'local-changes':\r\n\t\t\t\treturn new LocalChanges(p);\r\n\t\t\tcase 'LocalChangesEx':\r\n\t\t\tcase 'local-changes-ex':\r\n\t\t\t\treturn new LocalChangesEx(p);\r\n\t\t\tcase 'Breakout':\r\n\t\t\tcase 'breakout':\r\n\t\t\t\treturn new Breakout(p);\r\n\t\t\tcase 'GENET':\r\n\t\t\tcase 'genet':\r\n\t\t\t\treturn new GENET(p);\r\n\t\t\tcase 'CrispSRS3':\r\n\t\t\tcase 'crisp-srs3':\r\n\t\t\t\treturn new CrispSRS3(p);\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tstatic async createFuzzySolver(type: string, p: Problem): Promise<Solver | null> {\r\n\t\tswitch (type.replaceAll(' ', '')) {\r\n\t\t\tcase 'FullChecking':\r\n\t\t\tcase 'full-checking':\r\n\t\t\t\treturn new FullChecking(p);\r\n\t\t\tcase 'FuzzyForwardChecking':\r\n\t\t\tcase 'fuzzy-forward-checking':\r\n\t\t\t\treturn new FuzzyForwardChecking(p);\r\n\t\t\tcase 'FlexibleLocalChanges':\r\n\t\t\tcase 'flexible-local-changes':\r\n\t\t\t\treturn new FlexibleLocalChanges(p);\r\n\t\t\tcase 'FlexibleLocalChangesEx':\r\n\t\t\tcase 'flexible-local-changes-ex':\r\n\t\t\t\treturn new FlexibleLocalChangesEx(p);\r\n\t\t\tcase 'FuzzyBreakout':\r\n\t\t\tcase 'fuzzy-breakout':\r\n\t\t\t\treturn new FuzzyBreakout(p);\r\n\t\t\tcase 'FuzzyGENET':\r\n\t\t\tcase 'fuzzy-genet':\r\n\t\t\t\treturn new FuzzyGENET(p);\r\n\t\t\tcase 'SRS3':\r\n\t\t\tcase 'srs3':\r\n\t\t\t\treturn new SRS3(p);\r\n\t\t\tcase 'SRS3PF':\r\n\t\t\tcase 'SRS3_PF':\r\n\t\t\tcase 'srs3-pf':\r\n\t\t\t\treturn wrapWithPostStabilizer(p, new SRS3(p));\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * The class implements AC-3, one of the arc consistency algorithms.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-10-21\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Variable } from '../../problem/variable';\r\nimport { Constraint } from '../../problem/constraint';\r\nimport { Domain } from '../../problem/domain';\r\n\r\nexport class AC3 {\r\n\r\n\tstatic #checkConsistency(c: Constraint, x_j: Variable): boolean {\r\n\t\tfor (const v of x_j.domain()) {  // Is there a partner that satisfies the constraint?\r\n\t\t\tx_j.assign(v);\r\n\r\n\t\t\tif (c.isSatisfied() === 1) {  // It exists!\r\n\t\t\t\treturn true;  // Current assignment of v_i is consistent.\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tstatic #reviseDomain(p: Problem, x_i: Variable, x_j: Variable): boolean {\r\n\t\tconst v_i: number = x_i.value();\r\n\t\tconst v_j: number = x_j.value();  // Save the value.\r\n\t\tconst d_i: Domain = x_i.domain();\r\n\t\tconst temp: number[] = [];\r\n\r\n\t\tconst cs: Constraint[] = p.constraintsBetween(x_i, x_j);\r\n\r\n\t\tvs: for (const v of d_i) {\r\n\t\t\tx_i.assign(v);\r\n\r\n\t\t\tfor (const c of cs) {\r\n\t\t\t\tif (c.size() !== 2) continue;  // Check the next constraint\r\n\t\t\t\tif (!AC3.#checkConsistency(c, x_j)) continue vs;   // Since there is no partner satisfying the constraint, check the next value.\r\n\t\t\t}\r\n\t\t\ttemp.push(v);\r\n\t\t}\r\n\t\tx_i.assign(v_i);  // Restore the value.\r\n\t\tx_j.assign(v_j);  // Restore the value.\r\n\r\n\t\tif (temp.length !== d_i.size()) {\r\n\t\t\tconst nd = p.createDomain({ values: temp }) as Domain;\r\n\t\t\tx_i.domain(nd);\r\n\t\t\tconsole.log(d_i.size() + ' -> ' + nd.size());\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tstatic apply(p: Problem): void {\r\n\t\tconst cs: Constraint[] = [];\r\n\r\n\t\tfor (const c of p.constraints()) {\r\n\t\t\tif (c.size() === 2) cs.push(c);\r\n\t\t}\r\n\t\twhile (cs.length) {\r\n\t\t\tconst c = cs.pop() as Constraint;\r\n\t\t\tconst v_k = c.at(0) as Variable;\r\n\t\t\tconst v_m = c.at(1) as Variable;\r\n\r\n\t\t\tif (AC3.#reviseDomain(p, v_k, v_m)) {\r\n\t\t\t\tfor (const c1 of p.constraints()) {\r\n\t\t\t\t\tif (c1.size() === 2 && c1.at(1) === v_k && c1.at(0) !== v_m) {\r\n\t\t\t\t\t\tcs.unshift(c1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Utility class that performs node consistency.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-12-17\r\n */\r\n\r\nimport { Problem } from '../../problem/problem';\r\nimport { Domain } from '../../problem/domain';\r\n\r\n/**\r\n * Guarantees consistency of fuzzy unary constraints. The domain of each variable is replaced as needed.\r\n * Deletes elements from domains that do not meet the specified worst satisfaction degree.\r\n * @param p A problem.\r\n * @param threshold Worst satisfaction degree.\r\n * @return True if there is no empty domain.\r\n */\r\nexport function applyNodeConsistencyToProblem(p: Problem, threshold: number): boolean {\r\n\tfor (const x of p.variables()) {\r\n\t\tconst d    : Domain   = x.domain();\r\n\t\tconst origV: number   = x.value();  // Save the value.\r\n\t\tconst elms : number[] = [];\r\n\r\n\t\tfor (const c of x) {\r\n\t\t\tif (c.size() !== 1) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (const v of d) {\r\n\t\t\t\tx.assign(v);\r\n\r\n\t\t\t\tif (threshold <= c.degree()) {\r\n\t\t\t\t\telms.push(v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tp.removeConstraint(c);\r\n\t\t}\r\n\t\tx.assign(origV);  // Restore the value.\r\n\t\tif (0 === elms.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tx.domain(p.createDomain({ values: elms }) as Domain);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * Guarantees consistency of crisp unary constraints. The domain of each variable is replaced as needed.\r\n * It cannot be applied to crisp views of fuzzy constraint satisfaction problems because it changes the structure of the constraint graph.\r\n * @param p A crisp problem.\r\n * @return True if there is no empty domain.\r\n */\r\nexport function applyNodeConsistencyToCrispProblem(p: Problem): boolean {\r\n\tfor (const x of p.variables()) {\r\n\t\tconst d    : Domain   = x.domain();\r\n\t\tconst origV: number   = x.value();  // Save the value.\r\n\t\tconst elms : number[] = [];\r\n\r\n\t\tfor (const c of x) {\r\n\t\t\tif (c.size() !== 1) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (const v of d) {\r\n\t\t\t\tx.assign(v);\r\n\r\n\t\t\t\tif (c.isSatisfied() === 1) {\r\n\t\t\t\t\telms.push(v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tp.removeConstraint(c);\r\n\t\t}\r\n\t\tx.assign(origV);  // Restore the value.\r\n\t\tif (0 === elms.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tx.domain(p.createDomain({ values: elms }) as Domain);\r\n\t}\r\n\treturn true;\r\n}\r\n", "/**\r\n * This class detects that a solver's operation is looping.\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-10-22\r\n */\r\n\r\nexport class LoopDetector {\r\n\r\n\t#loopLength: number;\r\n\t#iterCount: number;\r\n\r\n\t#is: number[] = [];\r\n\t#vs: number[] = [];\r\n\r\n\t#cur: number = 0;\r\n\r\n\tconstructor(loopLength: number = 30, iterCount: number = 3) {\r\n\t\tthis.#loopLength = loopLength;\r\n\t\tthis.#iterCount = iterCount;\r\n\t\tthis.#initArrays();\r\n\t}\r\n\r\n\t#assignToVariable(index: number, value: number): void {\r\n\t\tthis.#is[this.#cur] = index;\r\n\t\tthis.#vs[this.#cur] = value;\r\n\r\n\t\tif (--this.#cur === -1) {\r\n\t\t\tthis.#cur = this.#is.length - 1;\r\n\t\t}\r\n\t}\r\n\r\n\t#checkLooping(): number {\r\n\t\tconst is = new Array(this.#loopLength);\r\n\t\tconst vs = new Array(this.#loopLength);\r\n\r\n\t\tout: for (let length: number = 1; length <= this.#loopLength; ++length) {\r\n\t\t\tlet offset: number = this.#cur + 1;\r\n\t\t\tfor (let i: number = 0; i < length; ++i) {\r\n\t\t\t\tif (i + offset === this.#is.length) {\r\n\t\t\t\t\toffset -= this.#is.length;\r\n\t\t\t\t}\r\n\t\t\t\tis[i] = this.#is[i + offset];\r\n\t\t\t\tvs[i] = this.#vs[i + offset];\r\n\t\t\t}\r\n\t\t\tlet fi: number = length;\r\n\t\t\tfor (let i: number = 0; i < this.#iterCount - 1; ++i) {\r\n\t\t\t\toffset = this.#cur + 1;\r\n\t\t\t\tfor (let j: number = 0; j < length; ++j) {\r\n\t\t\t\t\tif (fi + j + offset >= this.#is.length) {\r\n\t\t\t\t\t\toffset -= this.#is.length;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.#is[fi + j + offset] !== is[j] || this.#vs[fi + j + offset] !== vs[j]) {\r\n\t\t\t\t\t\tcontinue out;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfi += length;\r\n\t\t\t}\r\n\t\t\treturn length;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t#initArrays(): void {\r\n\t\tthis.#is = new Array(this.#loopLength * this.#iterCount);\r\n\t\tthis.#vs = new Array(this.#loopLength * this.#iterCount);\r\n\t\tthis.#is.fill(-1);\r\n\t\tthis.#vs.fill(-1);\r\n\t\tthis.#cur = this.#is.length - 1;\r\n\t}\r\n\r\n\tcheckLoop(variableIndex: number, value: number): number {\r\n\t\tthis.#assignToVariable(variableIndex, value);\r\n\t\treturn this.#checkLooping();\r\n\t}\r\n\r\n\tclear(): void {\r\n\t\tthis.#is.fill(-1);\r\n\t\tthis.#vs.fill(-1);\r\n\t}\r\n\r\n\titerationCount(): number {\r\n\t\treturn this.#iterCount;\r\n\t}\r\n\r\n\tloopLength(): number {\r\n\t\treturn this.#loopLength;\r\n\t}\r\n\r\n\tvalues(): number[] {\r\n\t\treturn this.#vs.slice();\r\n\t}\r\n\r\n\tvariableIndices(): number[] {\r\n\t\treturn this.#is.slice();\r\n\t}\r\n\r\n}\r\n"],
  "mappings": "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",
  "names": ["Element", "#index", "#name", "index", "name", "Variable", "_Variable", "Element", "#INVALID", "#owner", "#d", "#v", "#cs", "owner", "d", "n", "np", "v", "index", "c", "xs", "x", "i", "value", "Domain", "DomainRanged", "Domain", "#min", "#max", "min", "max", "v", "index", "DomainArbitrary", "Domain", "#vs", "vs", "v", "index", "Relation", "CrispRelation", "vs", "FuzzyRelation", "d", "Constraint", "_Constraint", "Element", "r", "FuzzyRelation", "n", "np", "s", "sn", "Constraint1", "Constraint", "#xs", "r", "x", "index", "cs", "c", "d", "cd", "fn", "v", "Constraint2", "Constraint", "#xs", "r", "x1", "x2", "index", "x", "cs", "c", "n", "d", "cd", "fn", "v1", "v2", "d1", "d2", "Constraint3", "Constraint", "#xs", "r", "x1", "x2", "x3", "index", "x", "cs", "c", "n", "d", "cd", "fn", "v1", "v2", "v3", "d1", "d2", "d3", "ConstraintN", "Constraint", "#xs", "#vs", "r", "xs", "index", "x", "cs", "c", "n", "i", "d", "emptyIndices", "currentStep", "cd", "v", "s", "Problem", "#fv", "o", "d", "Variable", "#fc", "r", "xs", "Constraint1", "Constraint2", "Constraint3", "ConstraintN", "#isFuzzy", "#xs", "#cs", "fn", "x", "args", "DomainArbitrary", "DomainRanged", "c", "index", "i", "comparator", "name", "v1", "v2", "cs", "n", "wd", "Constraint", "cur", "s", "ObservableVariable", "Variable", "#observer", "owner", "d", "observer", "v", "ImaginaryVariable", "#orig", "x", "Monitor", "#debugMode", "#debugOutput", "#listener", "#iterLimit", "#timeLimit", "#target", "#sameEvaluationLimit", "#endTime", "#iterCount", "#lastEv", "#sameEvCount", "evaluation", "solution", "str", "count", "msec", "rate", "l", "flag", "fn", "Solver", "Monitor", "pro", "m", "DomainPruner", "_DomainPruner", "#UNPRUNED", "#prunedLvs", "#prunedSize", "size", "index", "level", "i", "assignDomainPruner", "xs", "x", "unassignDomainPruner", "recover", "indexOfVariableWithMRV", "Assignment", "#x", "#v", "args", "AssignmentList", "_AssignmentList", "xs", "al", "#as", "p", "x", "Assignment", "a", "variable", "value", "diff", "index", "CrispFuzzyRelation", "CrispRelation", "#th", "#fr", "fr", "th", "vs", "d", "createRelatedConstraintTable", "pro", "xs", "rct", "j", "i", "averagePathLengths", "p", "ls", "x", "averagePathLength", "getPathLength", "connectedSize", "sum", "length", "baseLength", "xo", "xn", "c", "xi", "domains", "ds", "setDomains", "possibleDegreesOfUnaryConstraints", "degrees", "origV", "v", "toViewAsCrispProblem", "threshold", "cp", "CrispFuzzyProblem", "r", "CrispFuzzyRelation", "Problem", "args", "iv", "ImaginaryVariable", "ForwardChecking", "Solver", "#xs", "#rct", "#sol", "AssignmentList", "#useMRV", "p", "createRelatedConstraintTable", "flag", "assignDomainPruner", "ret", "#branch", "unassignDomainPruner", "level", "ev", "x", "indexOfVariableWithMRV", "d", "dp", "i", "n", "#getViolationCountAround", "#checkForward", "recover", "x_i", "cs", "#getConstraintsBetween", "dp_i", "d_i", "c", "#checkForwardConsistency", "j", "vc", "MaxForwardChecking", "Solver", "#xs", "#rct", "#sol", "AssignmentList", "#useMRV", "#maxVc", "p", "createRelatedConstraintTable", "flag", "assignDomainPruner", "ret", "#branch", "unassignDomainPruner", "level", "curVc", "ev", "x", "indexOfVariableWithMRV", "d", "dp", "i", "n", "vc", "#getViolationCountAround", "#checkForward", "recover", "x_i", "cs", "#getConstraintsBetween", "dp_i", "d_i", "c", "#checkForwardConsistency", "j", "LocalChanges", "Solver", "#globalReturn", "p", "unassignAll", "notFixed", "unassigned", "x", "sol", "AssignmentList", "ret", "#lcVariables", "ev", "X1", "X2", "X3", "r", "#lcVariable", "cloneDomain", "cloneAndAdd", "cloneAndDelete", "d", "v", "al", "#lcValue", "#isConsistent", "X12", "#createX3", "A", "cs", "xa", "temp", "c", "origV", "newX3", "xi", "s", "sn", "LocalChangesEx", "Solver", "#globalReturn", "p", "unassignAll", "notFixed", "unassigned", "x", "sol", "AssignmentList", "ret", "#lcVariables", "ev", "X1", "X2", "X3", "r", "#lcVariable", "v", "al", "#lcValue", "#isConsistent", "X12", "#createX3", "cloneAndAdd", "A", "cs", "xa", "temp", "c", "origV", "newX3", "xi", "s", "Breakout", "Solver", "#isRandom", "#ws", "p", "flag", "x", "defEv", "sol", "AssignmentList", "solEv", "canList", "ret", "cs", "ev", "#next", "#findCandidates", "#listTargetVariables", "a", "c", "tarXs", "maxDiff", "x_v", "nowEv", "out", "v", "diff", "tarCs", "xs", "GENET", "Solver", "#clusters", "#connections", "p", "#createNetwork", "order", "defEv", "sol", "AssignmentList", "solEv", "ret", "ev", "#next", "cons", "x", "Cluster", "c", "cl", "n", "origV", "Connection", "x1", "x2", "cl_f", "cl_s", "n_f", "origV1", "n_s", "origV2", "mod", "i", "#shuffle", "clu", "con", "is", "j", "nextInt", "temp", "#x", "#index", "#maxNeurons", "v", "Neuron", "#setActivity", "index", "max", "alreadyOn", "input", "#c", "#first", "#second", "first", "second", "self", "#conTemp", "value", "CrispSRS3", "Solver", "#isRandom", "#ws", "#closedList", "#openList", "#nodes", "#neighbors", "p", "c", "TreeNode", "flag", "x", "defEv", "sol", "AssignmentList", "solEv", "ret", "cs", "ev", "tn", "c_stars", "#srs", "node", "#getElementFromSet", "#repair", "#shrink", "#spread", "n", "#getNeighbors", "c0", "canList", "maxDiff", "x_v", "nowEv", "out", "v", "diff", "a", "cur", "curIsRemoved", "temp", "i", "ns", "d", "set", "ms", "#selectLightestNode", "#selectNearestNode", "curW", "w", "curD", "#c", "#depth", "#parent", "#children", "tns", "FullChecking", "Solver", "#xs", "#rct", "#sol", "AssignmentList", "#useMRV", "#minDeg", "#globalRet", "#checkedCs", "#sequence", "#unaryCs", "#pruneIntensively", "p", "createRelatedConstraintTable", "c", "flag", "assignDomainPruner", "ret", "#pruneUnaryConstraints", "#branch", "unassignDomainPruner", "x", "origV", "d", "dp", "i", "n", "level", "curDeg", "ev", "indexOfVariableWithMRV", "deg", "#getBackwardConsistency", "#checkForward", "recover", "x_i", "cs", "#getConstraintsBetween", "dp_i", "d_i", "evs", "#checkForwardConsistency", "#checkForwardConsistency2", "#checkForwardConsistency3", "#checkForwardConsistencyN", "j", "x_j", "d_j", "dp_j", "loop_i", "ni", "nj", "x_k", "d_k", "dp_k", "k", "nk", "emptySize", "x_", "indexes", "comLoop", "hidden", "min", "Constraint", "FuzzyForwardChecking", "Solver", "#xs", "#rct", "#sol", "AssignmentList", "#useMRV", "#minDeg", "#globalRet", "p", "createRelatedConstraintTable", "flag", "assignDomainPruner", "ret", "#branch", "unassignDomainPruner", "level", "curDeg", "ev", "x", "indexOfVariableWithMRV", "d", "dp", "i", "n", "deg", "#getWorstDegreeAround", "#checkForward", "recover", "x_i", "cs", "#getConstraintsBetween", "dp_i", "d_i", "c", "#checkForwardConsistency", "j", "min", "Constraint", "FlexibleLocalChanges", "Solver", "#lt", "#lb", "#globalReturn", "p", "#computeHighestAndLowestConsistencyDegree", "#choose", "x2", "cr", "res", "c", "x", "xs", "o1", "o2", "res1", "res2", "ret", "remain", "low", "high", "l", "h", "#flcRepair", "X1", "X2", "xi", "consX1xi", "consX12", "rc", "X3p", "X1p", "cloneAndAdd", "X2p", "#flcVariables", "#flcVariable", "consX1", "bestCons", "bestX2", "AssignmentList", "bestDij", "x2Store", "j", "dij", "consX1_xi", "#testX1", "crNew", "consX12_xi", "#testX12", "repairCons", "X3", "consX12xi", "cloneAndDelete", "#initTest", "X", "cs", "sd", "Constraint", "cd", "temp", "d", "csd", "wsd", "initCons", "initSol", "result", "s", "sn", "FlexibleLocalChangesEx", "Solver", "#lt", "#lb", "#globalReturn", "p", "#computeHighestAndLowestConsistencyDegree", "#choose", "x2", "cr", "res", "c", "x", "xs", "o1", "o2", "res1", "res2", "ret", "remain", "low", "high", "l", "h", "#flcRepair", "X1", "X2", "xi", "consX1xi", "consX12", "rc", "X3p", "X1p", "cloneAndAdd", "X2p", "#flcVariables", "#flcVariable", "consX1", "bestCons", "bestX2", "AssignmentList", "bestDij", "x2Store", "j", "dij", "consX1_xi", "#testX1", "crNew", "consX12_xi", "#testX12", "repairCons", "X3", "consX12xi", "#initTest", "X", "cs", "sd", "Constraint", "cd", "temp", "d", "csd", "wsd", "initCons", "initSol", "result", "s", "FuzzyBreakout", "Solver", "#isRandom", "#ws", "p", "flag", "x", "defEv", "sol", "AssignmentList", "solEv", "canList", "ret", "cs", "ev", "#next", "#findCandidates", "#listTargetVariables", "a", "c", "tarXs", "maxDiff", "x_v", "nowEv", "out", "v", "diff", "tarCs", "xs", "FuzzyGENET", "Solver", "#clusters", "#connections", "#degree", "p", "degree", "#createNetwork", "order", "defEv", "sol", "AssignmentList", "solEv", "ret", "ev", "#next", "cons", "x", "Cluster", "c", "cl", "n", "origV", "Connection", "x1", "x2", "cl_f", "cl_s", "n_f", "origV1", "n_s", "origV2", "mod", "i", "#shuffle", "clu", "con", "is", "j", "nextInt", "temp", "#x", "#index", "#maxNeurons", "v", "Neuron", "#setActivity", "index", "max", "alreadyOn", "input", "#c", "#first", "#second", "first", "second", "self", "#conTemp", "value", "SRS3", "Solver", "#isRandom", "#ws", "#closedList", "#openList", "#nodes", "#neighbors", "p", "c", "TreeNode", "flag", "x", "defEv", "sol", "AssignmentList", "solEv", "ret", "cs", "ev", "tn", "c_stars", "#srs", "node", "#getElementFromSet", "#repair", "#shrink", "#spread", "n", "#getNeighbors", "c0", "defD0", "canList", "maxDiff", "x_v", "nowEv", "out", "v", "diff", "a", "cur", "curIsRemoved", "temp", "i", "ns", "d", "set", "ms", "#selectLightestNode", "#selectNearestNode", "curW", "w", "curD", "#c", "#depth", "#parent", "#children", "tns", "applyPostStabilization", "p", "orig", "log", "e", "stabilized", "count", "ev_min", "xs", "i", "x", "v", "a", "wrapWithPostStabilizer", "solver", "PostStabilizerWrapper", "Solver", "#solver", "ev", "evs", "AssignmentList", "res", "SolverFactory", "_SolverFactory", "type", "p", "cs", "fs", "ForwardChecking", "MaxForwardChecking", "LocalChanges", "LocalChangesEx", "Breakout", "GENET", "CrispSRS3", "FullChecking", "FuzzyForwardChecking", "FlexibleLocalChanges", "FlexibleLocalChangesEx", "FuzzyBreakout", "FuzzyGENET", "SRS3", "wrapWithPostStabilizer", "AC3", "_AC3", "#checkConsistency", "c", "x_j", "v", "#reviseDomain", "p", "x_i", "v_i", "v_j", "d_i", "temp", "cs", "vs", "nd", "v_k", "v_m", "c1", "applyNodeConsistencyToProblem", "p", "threshold", "x", "d", "origV", "elms", "c", "v", "applyNodeConsistencyToCrispProblem", "LoopDetector", "#loopLength", "#iterCount", "#is", "#vs", "#cur", "loopLength", "iterCount", "#initArrays", "#assignToVariable", "index", "value", "#checkLooping", "is", "vs", "out", "length", "offset", "i", "fi", "j", "variableIndex"]
}
